import { useAnimation } from '@angular/animations';
import { NgIf, NgTemplateOutlet, NgFor } from '@angular/common';
import { Component, ContentChild, ContentChildren, EventEmitter, HostBinding, Inject, Input, Output, TemplateRef } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { growVerIn, growVerOut } from '../animations/grow';
import { fadeIn } from '../animations/main';
import { IgxCarouselComponentBase } from '../carousel/carousel-base';
import { IgxAngularAnimationService } from '../services/animation/angular-animation-service';
import { IgxStepComponent } from './step/step.component';
import { IgxStepperOrientation, IgxStepperTitlePosition, IgxStepType, IGX_STEPPER_COMPONENT, VerticalAnimationType } from './stepper.common';
import { IgxStepActiveIndicatorDirective, IgxStepCompletedIndicatorDirective, IgxStepInvalidIndicatorDirective } from './stepper.directive';
import { IgxStepperService } from './stepper.service';
import * as i0 from "@angular/core";
import * as i1 from "./stepper.service";
// TODO: common interface between IgxCarouselComponentBase and ToggleAnimationPlayer?
/**
 * IgxStepper provides a wizard-like workflow by dividing content into logical steps.
 *
 * @igxModule IgxStepperModule
 *
 * @igxKeywords stepper
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI for Angular Stepper component allows the user to navigate between multiple steps.
 * It supports horizontal and vertical orientation as well as keyboard navigation and provides API methods to control the active step.
 * The component offers keyboard navigation and API to control the active step.
 *
 * @example
 * ```html
 * <igx-stepper>
 *  <igx-step [active]="true">
 *      <igx-icon igxStepIndicator>home</igx-icon>
 *      <p igxStepTitle>Home</p>
 *      <div igxStepContent>
 *         ...
 *      </div>
 *  </igx-step>
 *  <igx-step [optional]="true">
 *      <div igxStepContent>
 *          ...
 *      </div>
 *  </igx-step>
 *  <igx-step>
 *      <div igxStepContent>
 *          ...
 *      </div>
 *  </igx-step>
 * </igx-stepper>
 * ```
 */
export class IgxStepperComponent extends IgxCarouselComponentBase {
    /**
     * Get/Set the animation type of the stepper when the orientation direction is vertical.
     *
     * @remarks
     * Default value is `grow`. Other possible values are `fade` and `none`.
     *
     * ```html
     * <igx-stepper verticalAnimationType="none">
     * <igx-stepper>
     * ```
     */
    get verticalAnimationType() {
        return this._verticalAnimationType;
    }
    set verticalAnimationType(value) {
        // TODO: activeChange event is not emitted for the collapsing steps (loop through collapsing steps and emit)
        this.stepperService.collapsingSteps.clear();
        this._verticalAnimationType = value;
        switch (value) {
            case 'grow':
                this.verticalAnimationSettings = this.updateVerticalAnimationSettings(growVerIn, growVerOut);
                break;
            case 'fade':
                this.verticalAnimationSettings = this.updateVerticalAnimationSettings(fadeIn, null);
                break;
            case 'none':
                this.verticalAnimationSettings = this.updateVerticalAnimationSettings(null, null);
                break;
        }
    }
    /**
     * Get/Set the animation type of the stepper when the orientation direction is horizontal.
     *
     * @remarks
     * Default value is `grow`. Other possible values are `fade` and `none`.
     *
     * ```html
     * <igx-stepper animationType="none">
     * <igx-stepper>
     * ```
     */
    get horizontalAnimationType() {
        return this.animationType;
    }
    set horizontalAnimationType(value) {
        // TODO: activeChange event is not emitted for the collapsing steps (loop through collapsing steps and emit)
        this.stepperService.collapsingSteps.clear();
        this.animationType = value;
    }
    /**
     * Get/Set the animation duration.
     * ```html
     * <igx-stepper [animationDuration]="500">
     * <igx-stepper>
     * ```
     */
    get animationDuration() {
        return this.defaultAnimationDuration;
    }
    set animationDuration(value) {
        if (value && value > 0) {
            this.defaultAnimationDuration = value;
            return;
        }
        this.defaultAnimationDuration = this._defaultAnimationDuration;
    }
    /**
     * Get/Set whether the stepper is linear.
     *
     * @remarks
     * If the stepper is in linear mode and if the active step is valid only then the user is able to move forward.
     *
     * ```html
     * <igx-stepper [linear]="true"></igx-stepper>
     * ```
     */
    get linear() {
        return this._linear;
    }
    set linear(value) {
        this._linear = value;
        if (this._linear && this.steps.length > 0) {
            // when the stepper is in linear mode we should calculate which steps should be disabled
            // and which are visited i.e. their validity should be correctly displayed.
            this.stepperService.calculateVisitedSteps();
            this.stepperService.calculateLinearDisabledSteps();
        }
        else {
            this.stepperService.linearDisabledSteps.clear();
        }
    }
    /**
     * Get/Set the stepper orientation.
     *
     * ```typescript
     * this.stepper.orientation = IgxStepperOrientation.Vertical;
     * ```
     */
    get orientation() {
        return this._orientation;
    }
    set orientation(value) {
        if (this._orientation === value) {
            return;
        }
        // TODO: activeChange event is not emitted for the collapsing steps
        this.stepperService.collapsingSteps.clear();
        this._orientation = value;
        this._defaultTitlePosition = this._orientation === IgxStepperOrientation.Horizontal ?
            IgxStepperTitlePosition.Bottom : IgxStepperTitlePosition.End;
    }
    /** @hidden @internal **/
    get directionClass() {
        return this.orientation === IgxStepperOrientation.Horizontal;
    }
    /**
     * Get all steps.
     *
     * ```typescript
     * const steps: IgxStepComponent[] = this.stepper.steps;
     * ```
     */
    get steps() {
        return this._steps?.toArray() || [];
    }
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    constructor(cdr, animationService, stepperService, element) {
        super(animationService, cdr);
        this.stepperService = stepperService;
        this.element = element;
        /**
         * Get/Set the type of the steps.
         *
         * ```typescript
         * this.stepper.stepType = IgxStepType.Indicator;
         * ```
         */
        this.stepType = IgxStepType.Full;
        /**
         * Get/Set whether the content is displayed above the steps.
         *
         * @remarks
         * Default value is `false` and the content is below the steps.
         *
         * ```typescript
         * this.stepper.contentTop = true;
         * ```
         */
        this.contentTop = false;
        /**
         * Get/Set the position of the steps title.
         *
         * @remarks
         * The default value when the stepper is horizontally orientated is `bottom`.
         * In vertical layout the default title position is `end`.
         *
         * ```typescript
         * this.stepper.titlePosition = IgxStepperTitlePosition.Top;
         * ```
         */
        this.titlePosition = null;
        /** @hidden @internal **/
        this.cssClass = 'igx-stepper';
        /** @hidden @internal **/
        this.role = 'tablist';
        /**
         * Emitted when the stepper's active step is changing.
         *
         *```html
         * <igx-stepper (activeStepChanging)="handleActiveStepChanging($event)">
         * </igx-stepper>
         * ```
         *
         *```typescript
         * public handleActiveStepChanging(event: IStepChangingEventArgs) {
         *  if (event.newIndex < event.oldIndex) {
         *      event.cancel = true;
         *  }
         * }
         *```
         */
        this.activeStepChanging = new EventEmitter();
        /**
         * Emitted when the active step is changed.
         *
         * @example
         * ```
         * <igx-stepper (activeStepChanged)="handleActiveStepChanged($event)"></igx-stepper>
         * ```
         */
        this.activeStepChanged = new EventEmitter();
        /** @hidden @internal */
        this.verticalAnimationSettings = {
            openAnimation: growVerIn,
            closeAnimation: growVerOut,
        };
        /** @hidden @internal */
        this._defaultTitlePosition = IgxStepperTitlePosition.Bottom;
        this.destroy$ = new Subject();
        this._orientation = IgxStepperOrientation.Horizontal;
        this._verticalAnimationType = VerticalAnimationType.Grow;
        this._linear = false;
        this._defaultAnimationDuration = 350;
        this.stepperService.stepper = this;
    }
    /** @hidden @internal */
    ngOnChanges(changes) {
        if (changes['animationDuration']) {
            this.verticalAnimationType = this._verticalAnimationType;
        }
    }
    /** @hidden @internal */
    ngOnInit() {
        this.enterAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.activeStepChanged.emit({ owner: this, index: this.stepperService.activeStep.index });
        });
        this.leaveAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            if (this.stepperService.collapsingSteps.size === 1) {
                this.stepperService.collapse(this.stepperService.previousActiveStep);
            }
            else {
                Array.from(this.stepperService.collapsingSteps).slice(0, this.stepperService.collapsingSteps.size - 1)
                    .forEach(step => this.stepperService.collapse(step));
            }
        });
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        let activeStep;
        this.steps.forEach((step, index) => {
            this.updateStepAria(step, index);
            if (!activeStep && step.active) {
                activeStep = step;
            }
        });
        if (!activeStep) {
            this.activateFirstStep(true);
        }
        if (this.linear) {
            this.stepperService.calculateLinearDisabledSteps();
        }
        this.handleStepChanges();
    }
    /** @hidden @internal */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * Activates the step at a given index.
     *
     *```typescript
     * this.stepper.navigateTo(1);
     *```
     */
    navigateTo(index) {
        const step = this.steps[index];
        if (!step || this.stepperService.activeStep === step) {
            return;
        }
        this.activateStep(step);
    }
    /**
     * Activates the next enabled step.
     *
     *```typescript
     * this.stepper.next();
     *```
     */
    next() {
        this.moveToNextStep();
    }
    /**
     * Activates the previous enabled step.
     *
     *```typescript
     * this.stepper.prev();
     *```
     */
    prev() {
        this.moveToNextStep(false);
    }
    /**
     * Resets the stepper to its initial state i.e. activates the first step.
     *
     * @remarks
     * The steps' content will not be automatically reset.
     *```typescript
     * this.stepper.reset();
     *```
     */
    reset() {
        this.stepperService.visitedSteps.clear();
        const activeStep = this.steps.find(s => !s.disabled);
        if (activeStep) {
            this.activateStep(activeStep);
        }
    }
    /** @hidden @internal */
    playHorizontalAnimations() {
        this.previousItem = this.stepperService.previousActiveStep;
        this.currentItem = this.stepperService.activeStep;
        this.triggerAnimations();
    }
    getPreviousElement() {
        return this.stepperService.previousActiveStep?.contentContainer.nativeElement;
    }
    getCurrentElement() {
        return this.stepperService.activeStep.contentContainer.nativeElement;
    }
    updateVerticalAnimationSettings(openAnimation, closeAnimation) {
        const customCloseAnimation = useAnimation(closeAnimation, {
            params: {
                duration: this.animationDuration + 'ms'
            }
        });
        const customOpenAnimation = useAnimation(openAnimation, {
            params: {
                duration: this.animationDuration + 'ms'
            }
        });
        return {
            openAnimation: openAnimation ? customOpenAnimation : null,
            closeAnimation: closeAnimation ? customCloseAnimation : null
        };
    }
    updateStepAria(step, index) {
        step._index = index;
        step.renderer.setAttribute(step.nativeElement, 'aria-setsize', (this.steps.length).toString());
        step.renderer.setAttribute(step.nativeElement, 'aria-posinset', (index + 1).toString());
    }
    handleStepChanges() {
        this._steps.changes.pipe(takeUntil(this.destroy$)).subscribe(steps => {
            Promise.resolve().then(() => {
                steps.forEach((step, index) => {
                    this.updateStepAria(step, index);
                });
                // when the active step is removed
                const hasActiveStep = this.steps.find(s => s === this.stepperService.activeStep);
                if (!hasActiveStep) {
                    this.activateFirstStep();
                }
                // TO DO: mark step added before the active as visited?
                if (this.linear) {
                    this.stepperService.calculateLinearDisabledSteps();
                }
            });
        });
    }
    activateFirstStep(activateInitially = false) {
        const firstEnabledStep = this.steps.find(s => !s.disabled);
        if (firstEnabledStep) {
            firstEnabledStep.active = true;
            if (activateInitially) {
                firstEnabledStep.activeChange.emit(true);
                this.activeStepChanged.emit({ owner: this, index: firstEnabledStep.index });
            }
        }
    }
    activateStep(step) {
        if (this.orientation === IgxStepperOrientation.Horizontal) {
            step.changeHorizontalActiveStep();
        }
        else {
            this.stepperService.expand(step);
        }
    }
    moveToNextStep(next = true) {
        let steps = this.steps;
        let activeStepIndex = this.stepperService.activeStep.index;
        if (!next) {
            steps = this.steps.reverse();
            activeStepIndex = steps.findIndex(s => s === this.stepperService.activeStep);
        }
        const nextStep = steps.find((s, i) => i > activeStepIndex && s.isAccessible);
        if (nextStep) {
            this.activateStep(nextStep);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxStepperComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: IgxAngularAnimationService }, { token: i1.IgxStepperService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxStepperComponent, isStandalone: true, selector: "igx-stepper", inputs: { verticalAnimationType: "verticalAnimationType", horizontalAnimationType: "horizontalAnimationType", animationDuration: "animationDuration", linear: "linear", orientation: "orientation", stepType: "stepType", contentTop: "contentTop", titlePosition: "titlePosition" }, outputs: { activeStepChanging: "activeStepChanging", activeStepChanged: "activeStepChanged" }, host: { properties: { "attr.aria-orientation": "this.orientation", "class.igx-stepper": "this.cssClass", "attr.role": "this.role", "class.igx-stepper--horizontal": "this.directionClass" } }, providers: [
            IgxStepperService,
            { provide: IGX_STEPPER_COMPONENT, useExisting: IgxStepperComponent },
        ], queries: [{ propertyName: "invalidIndicatorTemplate", first: true, predicate: IgxStepInvalidIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "completedIndicatorTemplate", first: true, predicate: IgxStepCompletedIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "activeIndicatorTemplate", first: true, predicate: IgxStepActiveIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "_steps", predicate: IgxStepComponent }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div *ngIf=\"!contentTop || orientation !== 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<div *ngIf=\"orientation === 'horizontal'\" class=\"igx-stepper__body\">\n    <ng-container *ngFor=\"let step of steps\">\n        <ng-container *ngTemplateOutlet=\"step.contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<div *ngIf=\"contentTop && orientation === 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<ng-template #stepTemplate>\n    <ng-content select=\"igx-step\"></ng-content>\n</ng-template>\n", dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxStepperComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-stepper', providers: [
                        IgxStepperService,
                        { provide: IGX_STEPPER_COMPONENT, useExisting: IgxStepperComponent },
                    ], standalone: true, imports: [NgIf, NgTemplateOutlet, NgFor], template: "<div *ngIf=\"!contentTop || orientation !== 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<div *ngIf=\"orientation === 'horizontal'\" class=\"igx-stepper__body\">\n    <ng-container *ngFor=\"let step of steps\">\n        <ng-container *ngTemplateOutlet=\"step.contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<div *ngIf=\"contentTop && orientation === 'horizontal'\" class=\"igx-stepper__header\">\n    <ng-template *ngTemplateOutlet=\"stepTemplate\"></ng-template>\n</div>\n\n<ng-template #stepTemplate>\n    <ng-content select=\"igx-step\"></ng-content>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [IgxAngularAnimationService]
                }] }, { type: i1.IgxStepperService }, { type: i0.ElementRef }]; }, propDecorators: { verticalAnimationType: [{
                type: Input
            }], horizontalAnimationType: [{
                type: Input
            }], animationDuration: [{
                type: Input
            }], linear: [{
                type: Input
            }], orientation: [{
                type: HostBinding,
                args: ['attr.aria-orientation']
            }, {
                type: Input
            }], stepType: [{
                type: Input
            }], contentTop: [{
                type: Input
            }], titlePosition: [{
                type: Input
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-stepper']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], directionClass: [{
                type: HostBinding,
                args: ['class.igx-stepper--horizontal']
            }], activeStepChanging: [{
                type: Output
            }], activeStepChanged: [{
                type: Output
            }], invalidIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxStepInvalidIndicatorDirective, { read: TemplateRef }]
            }], completedIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxStepCompletedIndicatorDirective, { read: TemplateRef }]
            }], activeIndicatorTemplate: [{
                type: ContentChild,
                args: [IgxStepActiveIndicatorDirective, { read: TemplateRef }]
            }], _steps: [{
                type: ContentChildren,
                args: [IgxStepComponent, { descendants: false }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc3RlcHBlci9zdGVwcGVyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zdGVwcGVyL3N0ZXBwZXIuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUE4QixZQUFZLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUMvRSxPQUFPLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFLEtBQUssRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2hFLE9BQU8sRUFDa0MsU0FBUyxFQUFFLFlBQVksRUFBRSxlQUFlLEVBQ2pFLFlBQVksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFDNUMsTUFBTSxFQUEyQixXQUFXLEVBQ3ZELE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDM0QsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQzVDLE9BQU8sRUFBMkIsd0JBQXdCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUc5RixPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxpREFBaUQsQ0FBQztBQUU3RixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN6RCxPQUFPLEVBQ1MscUJBQXFCLEVBQUUsdUJBQXVCLEVBQUUsV0FBVyxFQUN2RSxxQkFBcUIsRUFBaUQscUJBQXFCLEVBQzlGLE1BQU0sa0JBQWtCLENBQUM7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RSxJQUFJLEVBQUUsV0FBVyxFQUFFO2dCQUs5RCwwQkFBMEI7c0JBRGhDLFlBQVk7dUJBQUMsa0NBQWtDLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFO2dCQUtoRSx1QkFBdUI7c0JBRDdCLFlBQVk7dUJBQUMsK0JBQStCLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFO2dCQUs1RCxNQUFNO3NCQURiLGVBQWU7dUJBQUMsZ0JBQWdCLEVBQUUsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQW5pbWF0aW9uUmVmZXJlbmNlTWV0YWRhdGEsIHVzZUFuaW1hdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgTmdJZiwgTmdUZW1wbGF0ZU91dGxldCwgTmdGb3IgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIENvbnRlbnRDaGlsZHJlbixcbiAgICBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBJbmplY3QsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSxcbiAgICBPbkluaXQsIE91dHB1dCwgUXVlcnlMaXN0LCBTaW1wbGVDaGFuZ2VzLFRlbXBsYXRlUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgZ3Jvd1ZlckluLCBncm93VmVyT3V0IH0gZnJvbSAnLi4vYW5pbWF0aW9ucy9ncm93JztcbmltcG9ydCB7IGZhZGVJbiB9IGZyb20gJy4uL2FuaW1hdGlvbnMvbWFpbic7XG5pbXBvcnQgeyBIb3Jpem9udGFsQW5pbWF0aW9uVHlwZSwgSWd4Q2Fyb3VzZWxDb21wb25lbnRCYXNlIH0gZnJvbSAnLi4vY2Fyb3VzZWwvY2Fyb3VzZWwtYmFzZSc7XG5cbmltcG9ydCB7IFRvZ2dsZUFuaW1hdGlvblNldHRpbmdzIH0gZnJvbSAnLi4vZXhwYW5zaW9uLXBhbmVsL3RvZ2dsZS1hbmltYXRpb24tY29tcG9uZW50JztcbmltcG9ydCB7IElneEFuZ3VsYXJBbmltYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvYW5pbWF0aW9uL2FuZ3VsYXItYW5pbWF0aW9uLXNlcnZpY2UnO1xuaW1wb3J0IHsgQW5pbWF0aW9uU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2FuaW1hdGlvbi9hbmltYXRpb24nO1xuaW1wb3J0IHsgSWd4U3RlcENvbXBvbmVudCB9IGZyb20gJy4vc3RlcC9zdGVwLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIElneFN0ZXBwZXIsIElneFN0ZXBwZXJPcmllbnRhdGlvbiwgSWd4U3RlcHBlclRpdGxlUG9zaXRpb24sIElneFN0ZXBUeXBlLFxuICAgIElHWF9TVEVQUEVSX0NPTVBPTkVOVCwgSVN0ZXBDaGFuZ2VkRXZlbnRBcmdzLCBJU3RlcENoYW5naW5nRXZlbnRBcmdzLCBWZXJ0aWNhbEFuaW1hdGlvblR5cGVcbn0gZnJvbSAnLi9zdGVwcGVyLmNvbW1vbic7XG5pbXBvcnQge1xuICAgIElneFN0ZXBBY3RpdmVJbmRpY2F0b3JEaXJlY3RpdmUsXG4gICAgSWd4U3RlcENvbXBsZXRlZEluZGljYXRvckRpcmVjdGl2ZSxcbiAgICBJZ3hTdGVwSW52YWxpZEluZGljYXRvckRpcmVjdGl2ZVxufSBmcm9tICcuL3N0ZXBwZXIuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneFN0ZXBwZXJTZXJ2aWNlIH0gZnJvbSAnLi9zdGVwcGVyLnNlcnZpY2UnO1xuXG5cbi8vIFRPRE86IGNvbW1vbiBpbnRlcmZhY2UgYmV0d2VlbiBJZ3hDYXJvdXNlbENvbXBvbmVudEJhc2UgYW5kIFRvZ2dsZUFuaW1hdGlvblBsYXllcj9cblxuLyoqXG4gKiBJZ3hTdGVwcGVyIHByb3ZpZGVzIGEgd2l6YXJkLWxpa2Ugd29ya2Zsb3cgYnkgZGl2aWRpbmcgY29udGVudCBpbnRvIGxvZ2ljYWwgc3RlcHMuXG4gKlxuICogQGlneE1vZHVsZSBJZ3hTdGVwcGVyTW9kdWxlXG4gKlxuICogQGlneEtleXdvcmRzIHN0ZXBwZXJcbiAqXG4gKiBAaWd4R3JvdXAgTGF5b3V0c1xuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgSWduaXRlIFVJIGZvciBBbmd1bGFyIFN0ZXBwZXIgY29tcG9uZW50IGFsbG93cyB0aGUgdXNlciB0byBuYXZpZ2F0ZSBiZXR3ZWVuIG11bHRpcGxlIHN0ZXBzLlxuICogSXQgc3VwcG9ydHMgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgb3JpZW50YXRpb24gYXMgd2VsbCBhcyBrZXlib2FyZCBuYXZpZ2F0aW9uIGFuZCBwcm92aWRlcyBBUEkgbWV0aG9kcyB0byBjb250cm9sIHRoZSBhY3RpdmUgc3RlcC5cbiAqIFRoZSBjb21wb25lbnQgb2ZmZXJzIGtleWJvYXJkIG5hdmlnYXRpb24gYW5kIEFQSSB0byBjb250cm9sIHRoZSBhY3RpdmUgc3RlcC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC1zdGVwcGVyPlxuICogIDxpZ3gtc3RlcCBbYWN0aXZlXT1cInRydWVcIj5cbiAqICAgICAgPGlneC1pY29uIGlneFN0ZXBJbmRpY2F0b3I+aG9tZTwvaWd4LWljb24+XG4gKiAgICAgIDxwIGlneFN0ZXBUaXRsZT5Ib21lPC9wPlxuICogICAgICA8ZGl2IGlneFN0ZXBDb250ZW50PlxuICogICAgICAgICAuLi5cbiAqICAgICAgPC9kaXY+XG4gKiAgPC9pZ3gtc3RlcD5cbiAqICA8aWd4LXN0ZXAgW29wdGlvbmFsXT1cInRydWVcIj5cbiAqICAgICAgPGRpdiBpZ3hTdGVwQ29udGVudD5cbiAqICAgICAgICAgIC4uLlxuICogICAgICA8L2Rpdj5cbiAqICA8L2lneC1zdGVwPlxuICogIDxpZ3gtc3RlcD5cbiAqICAgICAgPGRpdiBpZ3hTdGVwQ29udGVudD5cbiAqICAgICAgICAgIC4uLlxuICogICAgICA8L2Rpdj5cbiAqICA8L2lneC1zdGVwPlxuICogPC9pZ3gtc3RlcHBlcj5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1zdGVwcGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3N0ZXBwZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBJZ3hTdGVwcGVyU2VydmljZSxcbiAgICAgICAgeyBwcm92aWRlOiBJR1hfU1RFUFBFUl9DT01QT05FTlQsIHVzZUV4aXN0aW5nOiBJZ3hTdGVwcGVyQ29tcG9uZW50IH0sXG4gICAgXSxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtOZ0lmLCBOZ1RlbXBsYXRlT3V0bGV0LCBOZ0Zvcl1cbn0pXG5leHBvcnQgY2xhc3MgSWd4U3RlcHBlckNvbXBvbmVudCBleHRlbmRzIElneENhcm91c2VsQ29tcG9uZW50QmFzZSBpbXBsZW1lbnRzIElneFN0ZXBwZXIsIE9uQ2hhbmdlcywgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqXG4gICAgICogR2V0L1NldCB0aGUgYW5pbWF0aW9uIHR5cGUgb2YgdGhlIHN0ZXBwZXIgd2hlbiB0aGUgb3JpZW50YXRpb24gZGlyZWN0aW9uIGlzIHZlcnRpY2FsLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBncm93YC4gT3RoZXIgcG9zc2libGUgdmFsdWVzIGFyZSBgZmFkZWAgYW5kIGBub25lYC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXN0ZXBwZXIgdmVydGljYWxBbmltYXRpb25UeXBlPVwibm9uZVwiPlxuICAgICAqIDxpZ3gtc3RlcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgdmVydGljYWxBbmltYXRpb25UeXBlKCk6IFZlcnRpY2FsQW5pbWF0aW9uVHlwZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJ0aWNhbEFuaW1hdGlvblR5cGU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCB2ZXJ0aWNhbEFuaW1hdGlvblR5cGUodmFsdWU6IFZlcnRpY2FsQW5pbWF0aW9uVHlwZSkge1xuICAgICAgICAvLyBUT0RPOiBhY3RpdmVDaGFuZ2UgZXZlbnQgaXMgbm90IGVtaXR0ZWQgZm9yIHRoZSBjb2xsYXBzaW5nIHN0ZXBzIChsb29wIHRocm91Z2ggY29sbGFwc2luZyBzdGVwcyBhbmQgZW1pdClcbiAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5jb2xsYXBzaW5nU3RlcHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fdmVydGljYWxBbmltYXRpb25UeXBlID0gdmFsdWU7XG5cbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnZ3Jvdyc6XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNhbEFuaW1hdGlvblNldHRpbmdzID0gdGhpcy51cGRhdGVWZXJ0aWNhbEFuaW1hdGlvblNldHRpbmdzKGdyb3dWZXJJbiwgZ3Jvd1Zlck91dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmYWRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2FsQW5pbWF0aW9uU2V0dGluZ3MgPSB0aGlzLnVwZGF0ZVZlcnRpY2FsQW5pbWF0aW9uU2V0dGluZ3MoZmFkZUluLCBudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICAgICAgICAgIHRoaXMudmVydGljYWxBbmltYXRpb25TZXR0aW5ncyA9IHRoaXMudXBkYXRlVmVydGljYWxBbmltYXRpb25TZXR0aW5ncyhudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldC9TZXQgdGhlIGFuaW1hdGlvbiB0eXBlIG9mIHRoZSBzdGVwcGVyIHdoZW4gdGhlIG9yaWVudGF0aW9uIGRpcmVjdGlvbiBpcyBob3Jpem9udGFsLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBncm93YC4gT3RoZXIgcG9zc2libGUgdmFsdWVzIGFyZSBgZmFkZWAgYW5kIGBub25lYC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXN0ZXBwZXIgYW5pbWF0aW9uVHlwZT1cIm5vbmVcIj5cbiAgICAgKiA8aWd4LXN0ZXBwZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGhvcml6b250YWxBbmltYXRpb25UeXBlKCk6IEhvcml6b250YWxBbmltYXRpb25UeXBlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uVHlwZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGhvcml6b250YWxBbmltYXRpb25UeXBlKHZhbHVlOiBIb3Jpem9udGFsQW5pbWF0aW9uVHlwZSkge1xuICAgICAgICAvLyBUT0RPOiBhY3RpdmVDaGFuZ2UgZXZlbnQgaXMgbm90IGVtaXR0ZWQgZm9yIHRoZSBjb2xsYXBzaW5nIHN0ZXBzIChsb29wIHRocm91Z2ggY29sbGFwc2luZyBzdGVwcyBhbmQgZW1pdClcbiAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5jb2xsYXBzaW5nU3RlcHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25UeXBlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0L1NldCB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXN0ZXBwZXIgW2FuaW1hdGlvbkR1cmF0aW9uXT1cIjUwMFwiPlxuICAgICAqIDxpZ3gtc3RlcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgYW5pbWF0aW9uRHVyYXRpb24oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEFuaW1hdGlvbkR1cmF0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgYW5pbWF0aW9uRHVyYXRpb24odmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBbmltYXRpb25EdXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVmYXVsdEFuaW1hdGlvbkR1cmF0aW9uID0gdGhpcy5fZGVmYXVsdEFuaW1hdGlvbkR1cmF0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldC9TZXQgd2hldGhlciB0aGUgc3RlcHBlciBpcyBsaW5lYXIuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZSBzdGVwcGVyIGlzIGluIGxpbmVhciBtb2RlIGFuZCBpZiB0aGUgYWN0aXZlIHN0ZXAgaXMgdmFsaWQgb25seSB0aGVuIHRoZSB1c2VyIGlzIGFibGUgdG8gbW92ZSBmb3J3YXJkLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3RlcHBlciBbbGluZWFyXT1cInRydWVcIj48L2lneC1zdGVwcGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBsaW5lYXIoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lYXI7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBsaW5lYXIodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fbGluZWFyID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9saW5lYXIgJiYgdGhpcy5zdGVwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBzdGVwcGVyIGlzIGluIGxpbmVhciBtb2RlIHdlIHNob3VsZCBjYWxjdWxhdGUgd2hpY2ggc3RlcHMgc2hvdWxkIGJlIGRpc2FibGVkXG4gICAgICAgICAgICAvLyBhbmQgd2hpY2ggYXJlIHZpc2l0ZWQgaS5lLiB0aGVpciB2YWxpZGl0eSBzaG91bGQgYmUgY29ycmVjdGx5IGRpc3BsYXllZC5cbiAgICAgICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuY2FsY3VsYXRlVmlzaXRlZFN0ZXBzKCk7XG4gICAgICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNhbGN1bGF0ZUxpbmVhckRpc2FibGVkU3RlcHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UubGluZWFyRGlzYWJsZWRTdGVwcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0L1NldCB0aGUgc3RlcHBlciBvcmllbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnN0ZXBwZXIub3JpZW50YXRpb24gPSBJZ3hTdGVwcGVyT3JpZW50YXRpb24uVmVydGljYWw7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtb3JpZW50YXRpb24nKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBvcmllbnRhdGlvbigpOiBJZ3hTdGVwcGVyT3JpZW50YXRpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZW50YXRpb247XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBvcmllbnRhdGlvbih2YWx1ZTogSWd4U3RlcHBlck9yaWVudGF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZUNoYW5nZSBldmVudCBpcyBub3QgZW1pdHRlZCBmb3IgdGhlIGNvbGxhcHNpbmcgc3RlcHNcbiAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5jb2xsYXBzaW5nU3RlcHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdFRpdGxlUG9zaXRpb24gPSB0aGlzLl9vcmllbnRhdGlvbiA9PT0gSWd4U3RlcHBlck9yaWVudGF0aW9uLkhvcml6b250YWwgP1xuICAgICAgICAgICAgSWd4U3RlcHBlclRpdGxlUG9zaXRpb24uQm90dG9tIDogSWd4U3RlcHBlclRpdGxlUG9zaXRpb24uRW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldC9TZXQgdGhlIHR5cGUgb2YgdGhlIHN0ZXBzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc3RlcHBlci5zdGVwVHlwZSA9IElneFN0ZXBUeXBlLkluZGljYXRvcjtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzdGVwVHlwZTogSWd4U3RlcFR5cGUgPSBJZ3hTdGVwVHlwZS5GdWxsO1xuXG4gICAgLyoqXG4gICAgICogR2V0L1NldCB3aGV0aGVyIHRoZSBjb250ZW50IGlzIGRpc3BsYXllZCBhYm92ZSB0aGUgc3RlcHMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYCBhbmQgdGhlIGNvbnRlbnQgaXMgYmVsb3cgdGhlIHN0ZXBzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc3RlcHBlci5jb250ZW50VG9wID0gdHJ1ZTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBjb250ZW50VG9wID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBHZXQvU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc3RlcHMgdGl0bGUuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gdGhlIHN0ZXBwZXIgaXMgaG9yaXpvbnRhbGx5IG9yaWVudGF0ZWQgaXMgYGJvdHRvbWAuXG4gICAgICogSW4gdmVydGljYWwgbGF5b3V0IHRoZSBkZWZhdWx0IHRpdGxlIHBvc2l0aW9uIGlzIGBlbmRgLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc3RlcHBlci50aXRsZVBvc2l0aW9uID0gSWd4U3RlcHBlclRpdGxlUG9zaXRpb24uVG9wO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRpdGxlUG9zaXRpb246IElneFN0ZXBwZXJUaXRsZVBvc2l0aW9uID0gbnVsbDtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1zdGVwcGVyJylcbiAgICBwdWJsaWMgY3NzQ2xhc3MgPSAnaWd4LXN0ZXBwZXInO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICoqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICBwdWJsaWMgcm9sZSA9ICd0YWJsaXN0JztcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1zdGVwcGVyLS1ob3Jpem9udGFsJylcbiAgICBwdWJsaWMgZ2V0IGRpcmVjdGlvbkNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gSWd4U3RlcHBlck9yaWVudGF0aW9uLkhvcml6b250YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBzdGVwcGVyJ3MgYWN0aXZlIHN0ZXAgaXMgY2hhbmdpbmcuXG4gICAgICpcbiAgICAgKmBgYGh0bWxcbiAgICAgKiA8aWd4LXN0ZXBwZXIgKGFjdGl2ZVN0ZXBDaGFuZ2luZyk9XCJoYW5kbGVBY3RpdmVTdGVwQ2hhbmdpbmcoJGV2ZW50KVwiPlxuICAgICAqIDwvaWd4LXN0ZXBwZXI+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgaGFuZGxlQWN0aXZlU3RlcENoYW5naW5nKGV2ZW50OiBJU3RlcENoYW5naW5nRXZlbnRBcmdzKSB7XG4gICAgICogIGlmIChldmVudC5uZXdJbmRleCA8IGV2ZW50Lm9sZEluZGV4KSB7XG4gICAgICogICAgICBldmVudC5jYW5jZWwgPSB0cnVlO1xuICAgICAqICB9XG4gICAgICogfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGFjdGl2ZVN0ZXBDaGFuZ2luZyA9IG5ldyBFdmVudEVtaXR0ZXI8SVN0ZXBDaGFuZ2luZ0V2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB0aGUgYWN0aXZlIHN0ZXAgaXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogPGlneC1zdGVwcGVyIChhY3RpdmVTdGVwQ2hhbmdlZCk9XCJoYW5kbGVBY3RpdmVTdGVwQ2hhbmdlZCgkZXZlbnQpXCI+PC9pZ3gtc3RlcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgYWN0aXZlU3RlcENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElTdGVwQ2hhbmdlZEV2ZW50QXJncz4oKTtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4U3RlcEludmFsaWRJbmRpY2F0b3JEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICBwdWJsaWMgaW52YWxpZEluZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJZ3hTdGVwSW52YWxpZEluZGljYXRvckRpcmVjdGl2ZT47XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBAQ29udGVudENoaWxkKElneFN0ZXBDb21wbGV0ZWRJbmRpY2F0b3JEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSlcbiAgICBwdWJsaWMgY29tcGxldGVkSW5kaWNhdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPElneFN0ZXBDb21wbGV0ZWRJbmRpY2F0b3JEaXJlY3RpdmU+O1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hTdGVwQWN0aXZlSW5kaWNhdG9yRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgcHVibGljIGFjdGl2ZUluZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxJZ3hTdGVwQWN0aXZlSW5kaWNhdG9yRGlyZWN0aXZlPjtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSWd4U3RlcENvbXBvbmVudCwgeyBkZXNjZW5kYW50czogZmFsc2UgfSlcbiAgICBwcml2YXRlIF9zdGVwczogUXVlcnlMaXN0PElneFN0ZXBDb21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBzdGVwcy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBzdGVwczogSWd4U3RlcENvbXBvbmVudFtdID0gdGhpcy5zdGVwcGVyLnN0ZXBzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc3RlcHMoKTogSWd4U3RlcENvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXBzPy50b0FycmF5KCkgfHwgW107XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCBuYXRpdmVFbGVtZW50KCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyB2ZXJ0aWNhbEFuaW1hdGlvblNldHRpbmdzOiBUb2dnbGVBbmltYXRpb25TZXR0aW5ncyA9IHtcbiAgICAgICAgb3BlbkFuaW1hdGlvbjogZ3Jvd1ZlckluLFxuICAgICAgICBjbG9zZUFuaW1hdGlvbjogZ3Jvd1Zlck91dCxcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBfZGVmYXVsdFRpdGxlUG9zaXRpb246IElneFN0ZXBwZXJUaXRsZVBvc2l0aW9uID0gSWd4U3RlcHBlclRpdGxlUG9zaXRpb24uQm90dG9tO1xuICAgIHByaXZhdGUgZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgIHByaXZhdGUgX29yaWVudGF0aW9uOiBJZ3hTdGVwcGVyT3JpZW50YXRpb24gPSBJZ3hTdGVwcGVyT3JpZW50YXRpb24uSG9yaXpvbnRhbDtcbiAgICBwcml2YXRlIF92ZXJ0aWNhbEFuaW1hdGlvblR5cGU6IFZlcnRpY2FsQW5pbWF0aW9uVHlwZSA9IFZlcnRpY2FsQW5pbWF0aW9uVHlwZS5Hcm93O1xuICAgIHByaXZhdGUgX2xpbmVhciA9IGZhbHNlO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2RlZmF1bHRBbmltYXRpb25EdXJhdGlvbiA9IDM1MDtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBASW5qZWN0KElneEFuZ3VsYXJBbmltYXRpb25TZXJ2aWNlKSBhbmltYXRpb25TZXJ2aWNlOiBBbmltYXRpb25TZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHN0ZXBwZXJTZXJ2aWNlOiBJZ3hTdGVwcGVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50Pikge1xuICAgICAgICBzdXBlcihhbmltYXRpb25TZXJ2aWNlLCBjZHIpO1xuICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLnN0ZXBwZXIgPSB0aGlzO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGlmIChjaGFuZ2VzWydhbmltYXRpb25EdXJhdGlvbiddKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2FsQW5pbWF0aW9uVHlwZSA9IHRoaXMuX3ZlcnRpY2FsQW5pbWF0aW9uVHlwZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lbnRlckFuaW1hdGlvbkRvbmUucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVN0ZXBDaGFuZ2VkLmVtaXQoeyBvd25lcjogdGhpcywgaW5kZXg6IHRoaXMuc3RlcHBlclNlcnZpY2UuYWN0aXZlU3RlcC5pbmRleCB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGVhdmVBbmltYXRpb25Eb25lLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RlcHBlclNlcnZpY2UuY29sbGFwc2luZ1N0ZXBzLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNvbGxhcHNlKHRoaXMuc3RlcHBlclNlcnZpY2UucHJldmlvdXNBY3RpdmVTdGVwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnN0ZXBwZXJTZXJ2aWNlLmNvbGxhcHNpbmdTdGVwcykuc2xpY2UoMCwgdGhpcy5zdGVwcGVyU2VydmljZS5jb2xsYXBzaW5nU3RlcHMuc2l6ZSAtIDEpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKHN0ZXAgPT4gdGhpcy5zdGVwcGVyU2VydmljZS5jb2xsYXBzZShzdGVwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG5cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgICAgICBsZXQgYWN0aXZlU3RlcDtcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKChzdGVwLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGVwQXJpYShzdGVwLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVN0ZXAgJiYgc3RlcC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTdGVwID0gc3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghYWN0aXZlU3RlcCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUZpcnN0U3RlcCh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxpbmVhcikge1xuICAgICAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS5jYWxjdWxhdGVMaW5lYXJEaXNhYmxlZFN0ZXBzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhhbmRsZVN0ZXBDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB0aGUgc3RlcCBhdCBhIGdpdmVuIGluZGV4LlxuICAgICAqXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5zdGVwcGVyLm5hdmlnYXRlVG8oMSk7XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgbmF2aWdhdGVUbyhpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLnN0ZXBzW2luZGV4XTtcbiAgICAgICAgaWYgKCFzdGVwIHx8IHRoaXMuc3RlcHBlclNlcnZpY2UuYWN0aXZlU3RlcCA9PT0gc3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZhdGVTdGVwKHN0ZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyB0aGUgbmV4dCBlbmFibGVkIHN0ZXAuXG4gICAgICpcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnN0ZXBwZXIubmV4dCgpO1xuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIG5leHQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW92ZVRvTmV4dFN0ZXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIHByZXZpb3VzIGVuYWJsZWQgc3RlcC5cbiAgICAgKlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuc3RlcHBlci5wcmV2KCk7XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgcHJldigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tb3ZlVG9OZXh0U3RlcChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBzdGVwcGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlIGkuZS4gYWN0aXZhdGVzIHRoZSBmaXJzdCBzdGVwLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgc3RlcHMnIGNvbnRlbnQgd2lsbCBub3QgYmUgYXV0b21hdGljYWxseSByZXNldC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnN0ZXBwZXIucmVzZXQoKTtcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGVwcGVyU2VydmljZS52aXNpdGVkU3RlcHMuY2xlYXIoKTtcbiAgICAgICAgY29uc3QgYWN0aXZlU3RlcCA9IHRoaXMuc3RlcHMuZmluZChzID0+ICFzLmRpc2FibGVkKTtcbiAgICAgICAgaWYgKGFjdGl2ZVN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVTdGVwKGFjdGl2ZVN0ZXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIHBsYXlIb3Jpem9udGFsQW5pbWF0aW9ucygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c0l0ZW0gPSB0aGlzLnN0ZXBwZXJTZXJ2aWNlLnByZXZpb3VzQWN0aXZlU3RlcDtcbiAgICAgICAgdGhpcy5jdXJyZW50SXRlbSA9IHRoaXMuc3RlcHBlclNlcnZpY2UuYWN0aXZlU3RlcDtcbiAgICAgICAgdGhpcy50cmlnZ2VyQW5pbWF0aW9ucygpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRQcmV2aW91c0VsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcGVyU2VydmljZS5wcmV2aW91c0FjdGl2ZVN0ZXA/LmNvbnRlbnRDb250YWluZXIubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0Q3VycmVudEVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcGVyU2VydmljZS5hY3RpdmVTdGVwLmNvbnRlbnRDb250YWluZXIubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVZlcnRpY2FsQW5pbWF0aW9uU2V0dGluZ3MoXG4gICAgICAgIG9wZW5BbmltYXRpb246IEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhLFxuICAgICAgICBjbG9zZUFuaW1hdGlvbjogQW5pbWF0aW9uUmVmZXJlbmNlTWV0YWRhdGEpOiBUb2dnbGVBbmltYXRpb25TZXR0aW5ncyB7XG4gICAgICAgIGNvbnN0IGN1c3RvbUNsb3NlQW5pbWF0aW9uID0gdXNlQW5pbWF0aW9uKGNsb3NlQW5pbWF0aW9uLCB7XG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5hbmltYXRpb25EdXJhdGlvbiArICdtcydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGN1c3RvbU9wZW5BbmltYXRpb24gPSB1c2VBbmltYXRpb24ob3BlbkFuaW1hdGlvbiwge1xuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuYW5pbWF0aW9uRHVyYXRpb24gKyAnbXMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcGVuQW5pbWF0aW9uOiBvcGVuQW5pbWF0aW9uID8gY3VzdG9tT3BlbkFuaW1hdGlvbiA6IG51bGwsXG4gICAgICAgICAgICBjbG9zZUFuaW1hdGlvbjogY2xvc2VBbmltYXRpb24gPyBjdXN0b21DbG9zZUFuaW1hdGlvbiA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVN0ZXBBcmlhKHN0ZXA6IElneFN0ZXBDb21wb25lbnQsIGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgc3RlcC5faW5kZXggPSBpbmRleDtcbiAgICAgICAgc3RlcC5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoc3RlcC5uYXRpdmVFbGVtZW50LCAnYXJpYS1zZXRzaXplJywgKHRoaXMuc3RlcHMubGVuZ3RoKS50b1N0cmluZygpKTtcbiAgICAgICAgc3RlcC5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoc3RlcC5uYXRpdmVFbGVtZW50LCAnYXJpYS1wb3NpbnNldCcsIChpbmRleCArIDEpLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlU3RlcENoYW5nZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N0ZXBzLmNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZShzdGVwcyA9PiB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzdGVwcy5mb3JFYWNoKChzdGVwLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0ZXBBcmlhKHN0ZXAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGFjdGl2ZSBzdGVwIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNBY3RpdmVTdGVwID0gdGhpcy5zdGVwcy5maW5kKHMgPT4gcyA9PT0gdGhpcy5zdGVwcGVyU2VydmljZS5hY3RpdmVTdGVwKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0FjdGl2ZVN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZUZpcnN0U3RlcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUTyBETzogbWFyayBzdGVwIGFkZGVkIGJlZm9yZSB0aGUgYWN0aXZlIGFzIHZpc2l0ZWQ/XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuY2FsY3VsYXRlTGluZWFyRGlzYWJsZWRTdGVwcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFjdGl2YXRlRmlyc3RTdGVwKGFjdGl2YXRlSW5pdGlhbGx5ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZmlyc3RFbmFibGVkU3RlcCA9IHRoaXMuc3RlcHMuZmluZChzID0+ICFzLmRpc2FibGVkKTtcbiAgICAgICAgaWYgKGZpcnN0RW5hYmxlZFN0ZXApIHtcbiAgICAgICAgICAgIGZpcnN0RW5hYmxlZFN0ZXAuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChhY3RpdmF0ZUluaXRpYWxseSkge1xuICAgICAgICAgICAgICAgIGZpcnN0RW5hYmxlZFN0ZXAuYWN0aXZlQ2hhbmdlLmVtaXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVTdGVwQ2hhbmdlZC5lbWl0KHsgb3duZXI6IHRoaXMsIGluZGV4OiBmaXJzdEVuYWJsZWRTdGVwLmluZGV4IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhY3RpdmF0ZVN0ZXAoc3RlcDogSWd4U3RlcENvbXBvbmVudCkge1xuICAgICAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gSWd4U3RlcHBlck9yaWVudGF0aW9uLkhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHN0ZXAuY2hhbmdlSG9yaXpvbnRhbEFjdGl2ZVN0ZXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcHBlclNlcnZpY2UuZXhwYW5kKHN0ZXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb3ZlVG9OZXh0U3RlcChuZXh0ID0gdHJ1ZSkge1xuICAgICAgICBsZXQgc3RlcHM6IElneFN0ZXBDb21wb25lbnRbXSA9IHRoaXMuc3RlcHM7XG4gICAgICAgIGxldCBhY3RpdmVTdGVwSW5kZXggPSB0aGlzLnN0ZXBwZXJTZXJ2aWNlLmFjdGl2ZVN0ZXAuaW5kZXg7XG4gICAgICAgIGlmICghbmV4dCkge1xuICAgICAgICAgICAgc3RlcHMgPSB0aGlzLnN0ZXBzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGFjdGl2ZVN0ZXBJbmRleCA9IHN0ZXBzLmZpbmRJbmRleChzID0+IHMgPT09IHRoaXMuc3RlcHBlclNlcnZpY2UuYWN0aXZlU3RlcCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXh0U3RlcCA9IHN0ZXBzLmZpbmQoKHMsIGkpID0+IGkgPiBhY3RpdmVTdGVwSW5kZXggJiYgcy5pc0FjY2Vzc2libGUpO1xuICAgICAgICBpZiAobmV4dFN0ZXApIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVTdGVwKG5leHRTdGVwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4iLCI8ZGl2ICpuZ0lmPVwiIWNvbnRlbnRUb3AgfHwgb3JpZW50YXRpb24gIT09ICdob3Jpem9udGFsJ1wiIGNsYXNzPVwiaWd4LXN0ZXBwZXJfX2hlYWRlclwiPlxuICAgIDxuZy10ZW1wbGF0ZSAqbmdUZW1wbGF0ZU91dGxldD1cInN0ZXBUZW1wbGF0ZVwiPjwvbmctdGVtcGxhdGU+XG48L2Rpdj5cblxuPGRpdiAqbmdJZj1cIm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCdcIiBjbGFzcz1cImlneC1zdGVwcGVyX19ib2R5XCI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgc3RlcCBvZiBzdGVwc1wiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwic3RlcC5jb250ZW50VGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvZGl2PlxuXG48ZGl2ICpuZ0lmPVwiY29udGVudFRvcCAmJiBvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnXCIgY2xhc3M9XCJpZ3gtc3RlcHBlcl9faGVhZGVyXCI+XG4gICAgPG5nLXRlbXBsYXRlICpuZ1RlbXBsYXRlT3V0bGV0PVwic3RlcFRlbXBsYXRlXCI+PC9uZy10ZW1wbGF0ZT5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgI3N0ZXBUZW1wbGF0ZT5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJpZ3gtc3RlcFwiPjwvbmctY29udGVudD5cbjwvbmctdGVtcGxhdGU+XG4iXX0=