import { NgClass, NgTemplateOutlet, NgIf } from '@angular/common';
import { Component, EventEmitter, HostBinding, Input, Output, ViewChild, ContentChild, Directive } from '@angular/core';
import { IgxProgressBarTextTemplateDirective, IgxProgressBarGradientDirective, } from './progressbar.common';
import { mkenum } from '../core/utils';
import * as i0 from "@angular/core";
import * as i1 from "../services/direction/directionality";
const ONE_PERCENT = 0.01;
const MIN_VALUE = 0;
export const IgxTextAlign = mkenum({
    START: 'start',
    CENTER: 'center',
    END: 'end'
});
export const IgxProgressType = mkenum({
    ERROR: 'error',
    INFO: 'info',
    WARNING: 'warning',
    SUCCESS: 'success'
});
/**
 * @hidden
 */
export class BaseProgressDirective {
    constructor() {
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *     alert("Progress made!");
         * }
         *  //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (progressChanged)="progressChange($event)"></igx-circular-bar>
         * <igx-linear-bar [value]="currentValue" (progressChanged)="progressChange($event)"></igx-linear-bar>
         * ```
         */
        this.progressChanged = new EventEmitter();
        /**
         * Sets/Gets progressbar in indeterminate. By default it is set to false.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * Sets/Gets progressbar animation duration. By default it is 2000ms.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * ```
         */
        this.animationDuration = 2000;
        this._initValue = 0;
        this._contentInit = false;
        this._max = 100;
        this._value = MIN_VALUE;
        this._newVal = MIN_VALUE;
        this._animate = true;
        this._internalState = {
            oldVal: 0,
            newVal: 0
        };
    }
    /**
     * Returns the value which update the progress indicator of the `progress bar`.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public stepValue(event) {
     *     let step = this.progressBar.step;
     *     alert(step);
     * }
     * ```
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0" [step]="1"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0" [step]="1"></igx-circular-bar>
     * ```
     */
    set step(val) {
        const step = Number(val);
        if (step > this.max) {
            return;
        }
        this._step = step;
    }
    /**
     * Animating the progress. By default it is set to true.
     * ```html
     * <igx-linear-bar [animate]="false" [max]="200" [value]="50"></igx-linear-bar>
     * <igx-circular-bar [animate]="false" [max]="200" [value]="50"></igx-circular-bar>
     * ```
     */
    set animate(animate) {
        this._animate = animate;
        if (animate) {
            this.animationDuration = 2000;
        }
        else {
            this.animationDuration = 0;
        }
    }
    /**
     * Returns whether the `progress bar` has animation true/false.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public animationStatus(event) {
     *     let animationStatus = this.progressBar.animate;
     *     alert(animationStatus);
     * }
     * ```
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
     * ```
     */
    set max(maxNum) {
        if (maxNum < MIN_VALUE || this._max === maxNum ||
            (this._animation && this._animation.playState !== 'finished')) {
            return;
        }
        this._internalState.newVal = Math.round(toValue(toPercent(this.value, maxNum), maxNum));
        this._value = this._internalState.oldVal = Math.round(toValue(this.valueInPercent, maxNum));
        this._max = maxNum;
        this.triggerProgressTransition(this._internalState.oldVal, this._internalState.newVal, true);
    }
    /**
     * Returns the the maximum progress value of the `progress bar`.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public maxValue(event) {
     *     let max = this.progressBar.max;
     *     alert(max);
     * }
     * ```
     */
    get max() {
        return this._max;
    }
    /**
     * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     * public valuePercent(event){
     *     let percentValue = this.progressBar.valueInPercent;
     *     alert(percentValue);
     * }
     * ```
     */
    get valueInPercent() {
        const val = toPercent(this._value, this._max);
        return val;
    }
    /**
     * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```typescript
     * @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public getValue(event) {
     *     let value = this.progressBar.value;
     *     alert(value);
     * }
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     */
    set value(val) {
        if (this._animation && this._animation.playState !== 'finished' || val < 0) {
            return;
        }
        const valInRange = valueInRange(val, this.max);
        if (isNaN(valInRange) || this._value === val || this.indeterminate) {
            return;
        }
        if (this._contentInit) {
            this.triggerProgressTransition(this._value, valInRange);
        }
        else {
            this._initValue = valInRange;
        }
    }
    triggerProgressTransition(oldVal, newVal, maxUpdate = false) {
        if (oldVal === newVal) {
            return;
        }
        const changedValues = {
            currentValue: newVal,
            previousValue: oldVal
        };
        const stepDirection = this.directionFlow(oldVal, newVal);
        if (this._animate) {
            const newToPercent = toPercent(newVal, this.max);
            const oldToPercent = toPercent(oldVal, this.max);
            const duration = this.animationDuration / Math.abs(newToPercent - oldToPercent) / (this._step ? this._step : 1);
            this.runAnimation(newVal);
            this._interval = setInterval(() => this.increase(newVal, stepDirection), duration);
        }
        else {
            this.updateProgress(newVal);
        }
        if (maxUpdate) {
            return;
        }
        this.progressChanged.emit(changedValues);
    }
    /**
     * @hidden
     */
    increase(newValue, step) {
        const targetValue = toPercent(newValue, this._max);
        this._value = valueInRange(this._value, this._max) + step;
        if ((step > 0 && this.valueInPercent >= targetValue) || (step < 0 && this.valueInPercent <= targetValue)) {
            if (this._value !== newValue) {
                this._value = newValue;
            }
            return clearInterval(this._interval);
        }
    }
    /**
     * @hidden
     */
    directionFlow(currentValue, prevValue) {
        return currentValue < prevValue ? this.step : -this.step;
    }
    /**
     * @hidden
     * @param step
     */
    updateProgress(val) {
        this._value = valueInRange(val, this._max);
        // this.valueInPercent = toPercent(val, this._max);
        this.runAnimation(val);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: BaseProgressDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: BaseProgressDirective, inputs: { indeterminate: "indeterminate", animationDuration: "animationDuration", step: "step", animate: "animate", max: "max", value: "value" }, outputs: { progressChanged: "progressChanged" }, host: { properties: { "attr.aria-valuemax": "this.max", "attr.aria-valuenow": "this.value" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: BaseProgressDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return []; }, propDecorators: { progressChanged: [{
                type: Output
            }], indeterminate: [{
                type: Input
            }], animationDuration: [{
                type: Input
            }], step: [{
                type: Input
            }], animate: [{
                type: Input
            }], max: [{
                type: HostBinding,
                args: ['attr.aria-valuemax']
            }, {
                type: Input
            }], value: [{
                type: HostBinding,
                args: ['attr.aria-valuenow']
            }, {
                type: Input
            }] } });
let NEXT_LINEAR_ID = 0;
let NEXT_CIRCULAR_ID = 0;
let NEXT_GRADIENT_ID = 0;
export class IgxLinearProgressBarComponent extends BaseProgressDirective {
    constructor() {
        super(...arguments);
        this.valueMin = 0;
        this.cssClass = 'igx-linear-bar';
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.striped = false;
        /**
         * An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         * <igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */
        this.role = 'progressbar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.id = `igx-linear-bar-${NEXT_LINEAR_ID++}`;
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *     this.positionCenter = IgxTextAlign.CENTER;
         * }
         *  //...
         * ```
         *  ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */
        this.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         *  <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         *  <igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
         * ```
         */
        this.textTop = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
         * ```
         */
        this.type = 'default';
        this.animationState = {
            width: '0%'
        };
    }
    /**
     * @hidden
     * ```
     */
    get isIndeterminate() {
        return this.indeterminate;
    }
    /**
     * @hidden
     */
    get error() {
        return this.type === IgxProgressType.ERROR;
    }
    /**
     * @hidden
     */
    get info() {
        return this.type === IgxProgressType.INFO;
    }
    /**
     * @hidden
     */
    get warning() {
        return this.type === IgxProgressType.WARNING;
    }
    /**
     * @hidden
     */
    get success() {
        return this.type === IgxProgressType.SUCCESS;
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
    runAnimation(value) {
        if (this._animation && this._animation.playState !== 'finished') {
            return;
        }
        const valueInPercent = this.max <= 0 ? 0 : toPercent(value, this.max);
        const FRAMES = [];
        FRAMES[0] = {
            ...this.animationState
        };
        this.animationState.width = valueInPercent + '%';
        FRAMES[1] = {
            ...this.animationState
        };
        this._animation = this._progressIndicator.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards',
            duration: this.animationDuration
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxLinearProgressBarComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxLinearProgressBarComponent, isStandalone: true, selector: "igx-linear-bar", inputs: { striped: "striped", role: "role", id: "id", textAlign: "textAlign", textVisibility: "textVisibility", textTop: "textTop", text: "text", type: "type" }, host: { properties: { "attr.aria-valuemin": "this.valueMin", "class.igx-linear-bar": "this.cssClass", "class.igx-linear-bar--striped": "this.striped", "class.igx-linear-bar--indeterminate": "this.isIndeterminate", "attr.role": "this.role", "attr.id": "this.id", "class.igx-linear-bar--danger": "this.error", "class.igx-linear-bar--info": "this.info", "class.igx-linear-bar--warning": "this.warning", "class.igx-linear-bar--success": "this.success" } }, viewQueries: [{ propertyName: "_progressIndicator", first: true, predicate: ["indicator"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: "<div class=\"igx-linear-bar__base\">\n    <div #indicator class=\"igx-linear-bar__indicator\" [style.width]=\"0\"></div>\n    <div class=\"igx-linear-bar__indicator-secondary\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n", dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxLinearProgressBarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-linear-bar', standalone: true, imports: [NgClass], template: "<div class=\"igx-linear-bar__base\">\n    <div #indicator class=\"igx-linear-bar__indicator\" [style.width]=\"0\"></div>\n    <div class=\"igx-linear-bar__indicator-secondary\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n" }]
        }], propDecorators: { valueMin: [{
                type: HostBinding,
                args: ['attr.aria-valuemin']
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-linear-bar']
            }], striped: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--striped']
            }, {
                type: Input
            }], isIndeterminate: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--indeterminate']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }, {
                type: Input
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], textAlign: [{
                type: Input
            }], textVisibility: [{
                type: Input
            }], textTop: [{
                type: Input
            }], text: [{
                type: Input
            }], type: [{
                type: Input
            }], _progressIndicator: [{
                type: ViewChild,
                args: ['indicator', { static: true }]
            }], error: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--danger']
            }], info: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--info']
            }], warning: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--warning']
            }], success: [{
                type: HostBinding,
                args: ['class.igx-linear-bar--success']
            }] } });
export class IgxCircularProgressBarComponent extends BaseProgressDirective {
    /**
     * @hidden
     */
    get isIndeterminate() {
        return this.indeterminate;
    }
    /**
     * @hidden
     */
    get context() {
        return {
            $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
        };
    }
    constructor(renderer, _directionality) {
        super();
        this.renderer = renderer;
        this._directionality = _directionality;
        /** @hidden */
        this.cssClass = 'igx-circular-bar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */
        this.id = `igx-circular-bar-${NEXT_CIRCULAR_ID++}`;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * @hidden
         */
        this.gradientId = `igx-circular-gradient-${NEXT_GRADIENT_ID++}`;
        this._circleRadius = 46;
        this._circumference = 2 * Math.PI * this._circleRadius;
        this.STROKE_OPACITY_DVIDER = 100;
        this.STROKE_OPACITY_ADDITION = .2;
        this.animationState = {
            strokeDashoffset: 289,
            strokeOpacity: 1
        };
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
    ngAfterViewInit() {
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke', `url(#${this.gradientId})`);
    }
    /**
     * @hidden
     */
    get textContent() {
        return this.text;
    }
    runAnimation(value) {
        if (this._animation && this._animation.playState !== 'finished') {
            return;
        }
        const valueInPercent = this.max <= 0 ? 0 : toPercent(value, this.max);
        const FRAMES = [];
        FRAMES[0] = { ...this.animationState };
        this.animationState.strokeDashoffset = this.getProgress(valueInPercent);
        this.animationState.strokeOpacity = toPercent(value, this.max) / this.STROKE_OPACITY_DVIDER + this.STROKE_OPACITY_ADDITION;
        FRAMES[1] = {
            ...this.animationState
        };
        this._animation = this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards',
            duration: this.animationDuration
        });
    }
    getProgress(percentage) {
        return this._directionality.rtl ?
            this._circumference + (percentage * this._circumference / 100) :
            this._circumference - (percentage * this._circumference / 100);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxCircularProgressBarComponent, deps: [{ token: i0.Renderer2 }, { token: i1.IgxDirectionality }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxCircularProgressBarComponent, isStandalone: true, selector: "igx-circular-bar", inputs: { id: "id", isIndeterminate: "isIndeterminate", textVisibility: "textVisibility", text: "text" }, host: { properties: { "class.igx-circular-bar": "this.cssClass", "attr.id": "this.id", "class.igx-circular-bar--indeterminate": "this.isIndeterminate" } }, queries: [{ propertyName: "textTemplate", first: true, predicate: IgxProgressBarTextTemplateDirective, descendants: true, read: IgxProgressBarTextTemplateDirective }, { propertyName: "gradientTemplate", first: true, predicate: IgxProgressBarGradientDirective, descendants: true, read: IgxProgressBarGradientDirective }], viewQueries: [{ propertyName: "_svgCircle", first: true, predicate: ["circle"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n<span class=\"igx-circular-bar__text\" *ngIf=\"textVisibility\">\n    <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n    </ng-container>\n</span>\n\n<ng-template #defaultTextTemplate>\n    {{textContent ? textContent: valueInPercent + '%'}}\n</ng-template>\n\n", dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxCircularProgressBarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-circular-bar', standalone: true, imports: [NgTemplateOutlet, NgIf], template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n<span class=\"igx-circular-bar__text\" *ngIf=\"textVisibility\">\n    <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n    </ng-container>\n</span>\n\n<ng-template #defaultTextTemplate>\n    {{textContent ? textContent: valueInPercent + '%'}}\n</ng-template>\n\n" }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i1.IgxDirectionality }]; }, propDecorators: { cssClass: [{
                type: HostBinding,
                args: ['class.igx-circular-bar']
            }], id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], isIndeterminate: [{
                type: HostBinding,
                args: ['class.igx-circular-bar--indeterminate']
            }, {
                type: Input
            }], textVisibility: [{
                type: Input
            }], text: [{
                type: Input
            }], textTemplate: [{
                type: ContentChild,
                args: [IgxProgressBarTextTemplateDirective, { read: IgxProgressBarTextTemplateDirective }]
            }], gradientTemplate: [{
                type: ContentChild,
                args: [IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective }]
            }], _svgCircle: [{
                type: ViewChild,
                args: ['circle', { static: true }]
            }] } });
export const valueInRange = (value, max, min = 0) => Math.max(Math.min(value, max), min);
export const toPercent = (value, max) => !max ? 0 : Math.floor(100 * value / max);
export const toValue = (value, max) => max * value / 100;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3NiYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3Byb2dyZXNzYmFyL3Byb2dyZXNzYmFyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9wcm9ncmVzc2Jhci90ZW1wbGF0ZXMvbGluZWFyLWJhci5jb21wb25lbnQuaHRtbCIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9wcm9ncmVzc2Jhci90ZW1wbGF0ZXMvY2lyY3VsYXItYmFyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbEUsT0FBTyxFQUNILFNBQVMsRUFFVCxZQUFZLEVBQ1osV0FBVyxFQUNYLEtBQUssRUFDTCxNQUFNLEVBRU4sU0FBUyxFQUNULFlBQVksRUFHWixTQUFTLEVBQ1osTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNILG1DQUFtQyxFQUNuQywrQkFBK0IsR0FDbEMsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQWtCLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQzs7O0FBRXZELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQztBQUN6QixNQUFNLFNBQVMsR0FBRyxDQUFDLENBQUM7QUFFcEIsTUFBTSxDQUFDLE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQztJQUMvQixLQUFLLEVBQUUsT0FBTztJQUNkLE1BQU0sRUFBRSxRQUFRO0lBQ2hCLEdBQUcsRUFBRSxLQUFLO0NBQ2IsQ0FBQyxDQUFDO0FBR0gsTUFBTSxDQUFDLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQztJQUNsQyxLQUFLLEVBQUUs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TUFBTSxDQUFDLE1BQU0sT0FBTyxHQUFHLENBQUMsS0FBYSxFQUFFLEdBQVcsRUFBRSxFQUFFLENBQUMsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ0NsYXNzLCBOZ1RlbXBsYXRlT3V0bGV0LCBOZ0lmIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIElucHV0LFxuICAgIE91dHB1dCxcbiAgICBSZW5kZXJlcjIsXG4gICAgVmlld0NoaWxkLFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgRGlyZWN0aXZlXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBJZ3hQcm9ncmVzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlLFxufSBmcm9tICcuL3Byb2dyZXNzYmFyLmNvbW1vbic7XG5pbXBvcnQgeyBJQmFzZUV2ZW50QXJncywgbWtlbnVtIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJZ3hEaXJlY3Rpb25hbGl0eSB9IGZyb20gJy4uL3NlcnZpY2VzL2RpcmVjdGlvbi9kaXJlY3Rpb25hbGl0eSc7XG5jb25zdCBPTkVfUEVSQ0VOVCA9IDAuMDE7XG5jb25zdCBNSU5fVkFMVUUgPSAwO1xuXG5leHBvcnQgY29uc3QgSWd4VGV4dEFsaWduID0gbWtlbnVtKHtcbiAgICBTVEFSVDogJ3N0YXJ0JyxcbiAgICBDRU5URVI6ICdjZW50ZXInLFxuICAgIEVORDogJ2VuZCdcbn0pO1xuZXhwb3J0IHR5cGUgSWd4VGV4dEFsaWduID0gKHR5cGVvZiBJZ3hUZXh0QWxpZ24pW2tleW9mIHR5cGVvZiBJZ3hUZXh0QWxpZ25dO1xuXG5leHBvcnQgY29uc3QgSWd4UHJvZ3Jlc3NUeXBlID0gbWtlbnVtKHtcbiAgICBFUlJPUjogJ2Vycm9yJyxcbiAgICBJTkZPOiAnaW5mbycsXG4gICAgV0FSTklORzogJ3dhcm5pbmcnLFxuICAgIFNVQ0NFU1M6ICdzdWNjZXNzJ1xufSk7XG5leHBvcnQgdHlwZSBJZ3hQcm9ncmVzc1R5cGUgPSAodHlwZW9mIElneFByb2dyZXNzVHlwZSlba2V5b2YgdHlwZW9mIElneFByb2dyZXNzVHlwZV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUNoYW5nZVByb2dyZXNzRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIHByZXZpb3VzVmFsdWU6IG51bWJlcjtcbiAgICBjdXJyZW50VmFsdWU6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBEaXJlY3RpdmUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VQcm9ncmVzc0RpcmVjdGl2ZSB7XG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQsIHdoaWNoIGlzIHRyaWdnZXJlZCBhZnRlciBhIHByb2dyZXNzIGlzIGNoYW5nZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBwcm9ncmVzc0NoYW5nZShldmVudCkge1xuICAgICAqICAgICBhbGVydChcIlByb2dyZXNzIG1hZGUhXCIpO1xuICAgICAqIH1cbiAgICAgKiAgLy8uLi5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgW3ZhbHVlXT1cImN1cnJlbnRWYWx1ZVwiIChwcm9ncmVzc0NoYW5nZWQpPVwicHJvZ3Jlc3NDaGFuZ2UoJGV2ZW50KVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW3ZhbHVlXT1cImN1cnJlbnRWYWx1ZVwiIChwcm9ncmVzc0NoYW5nZWQpPVwicHJvZ3Jlc3NDaGFuZ2UoJGV2ZW50KVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHByb2dyZXNzQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SUNoYW5nZVByb2dyZXNzRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9HZXRzIHByb2dyZXNzYmFyIGluIGluZGV0ZXJtaW5hdGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW2luZGV0ZXJtaW5hdGVdPVwidHJ1ZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgW2luZGV0ZXJtaW5hdGVdPVwidHJ1ZVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpbmRldGVybWluYXRlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL0dldHMgcHJvZ3Jlc3NiYXIgYW5pbWF0aW9uIGR1cmF0aW9uLiBCeSBkZWZhdWx0IGl0IGlzIDIwMDBtcy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtpbmRldGVybWluYXRlXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGFuaW1hdGlvbkR1cmF0aW9uID0gMjAwMDtcbiAgICBwdWJsaWMgX2ludGVydmFsO1xuXG4gICAgcHJvdGVjdGVkIF9pbml0VmFsdWUgPSAwO1xuICAgIHByb3RlY3RlZCBfY29udGVudEluaXQgPSBmYWxzZTtcbiAgICBwcm90ZWN0ZWQgX21heCA9IDEwMDtcbiAgICBwcm90ZWN0ZWQgX3ZhbHVlID0gTUlOX1ZBTFVFO1xuICAgIHByb3RlY3RlZCBfbmV3VmFsID0gTUlOX1ZBTFVFO1xuICAgIHByb3RlY3RlZCBfYW5pbWF0ZSA9IHRydWU7XG4gICAgcHJvdGVjdGVkIF9zdGVwO1xuICAgIHByb3RlY3RlZCBfYW5pbWF0aW9uO1xuICAgIHByb3RlY3RlZCBfdmFsdWVJblBlcmNlbnQ7XG4gICAgcHJvdGVjdGVkIF9pbnRlcm5hbFN0YXRlID0ge1xuICAgICAgICBvbGRWYWw6IDAsXG4gICAgICAgIG5ld1ZhbDogMFxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgd2hpY2ggdXBkYXRlIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3Igb2YgdGhlIGBwcm9ncmVzcyBiYXJgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqIHB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgfCBJZ3hDaXJjdWxhckJhckNvbXBvbmVudDtcbiAgICAgKiBwdWJsaWMgc3RlcFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgIGxldCBzdGVwID0gdGhpcy5wcm9ncmVzc0Jhci5zdGVwO1xuICAgICAqICAgICBhbGVydChzdGVwKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHN0ZXAoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGVwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXggKiBPTkVfUEVSQ0VOVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBieSB3aGljaCBwcm9ncmVzcyBpbmRpY2F0b3IgaXMgdXBkYXRlZC4gQnkgZGVmYXVsdCBpdCBpcyAxLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiMFwiIFtzdGVwXT1cIjFcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIiBbc3RlcF09XCIxXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgc3RlcCh2YWw6IG51bWJlcikge1xuICAgICAgICBjb25zdCBzdGVwID0gTnVtYmVyKHZhbCk7XG4gICAgICAgIGlmIChzdGVwID4gdGhpcy5tYXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGluZyB0aGUgcHJvZ3Jlc3MuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbYW5pbWF0ZV09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbYW5pbWF0ZV09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBhbmltYXRlKGFuaW1hdGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IGFuaW1hdGU7XG4gICAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uID0gMjAwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uRHVyYXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBgcHJvZ3Jlc3MgYmFyYCBoYXMgYW5pbWF0aW9uIHRydWUvZmFsc2UuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudCB8IElneENpcmN1bGFyQmFyQ29tcG9uZW50O1xuICAgICAqIHB1YmxpYyBhbmltYXRpb25TdGF0dXMoZXZlbnQpIHtcbiAgICAgKiAgICAgbGV0IGFuaW1hdGlvblN0YXR1cyA9IHRoaXMucHJvZ3Jlc3NCYXIuYW5pbWF0ZTtcbiAgICAgKiAgICAgYWxlcnQoYW5pbWF0aW9uU3RhdHVzKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBhbmltYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgbWF4aW11bSB2YWx1ZSB0aGF0IGNhbiBiZSBwYXNzZWQuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIDEwMC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVtYXgnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBtYXgobWF4TnVtOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKG1heE51bSA8IE1JTl9WQUxVRSB8fCB0aGlzLl9tYXggPT09IG1heE51bSB8fFxuICAgICAgICAgICAgKHRoaXMuX2FuaW1hdGlvbiAmJiB0aGlzLl9hbmltYXRpb24ucGxheVN0YXRlICE9PSAnZmluaXNoZWQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW50ZXJuYWxTdGF0ZS5uZXdWYWwgPSBNYXRoLnJvdW5kKHRvVmFsdWUodG9QZXJjZW50KHRoaXMudmFsdWUsIG1heE51bSksIG1heE51bSkpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2ludGVybmFsU3RhdGUub2xkVmFsID0gTWF0aC5yb3VuZCh0b1ZhbHVlKHRoaXMudmFsdWVJblBlcmNlbnQsIG1heE51bSkpO1xuICAgICAgICB0aGlzLl9tYXggPSBtYXhOdW07XG4gICAgICAgIHRoaXMudHJpZ2dlclByb2dyZXNzVHJhbnNpdGlvbih0aGlzLl9pbnRlcm5hbFN0YXRlLm9sZFZhbCwgdGhpcy5faW50ZXJuYWxTdGF0ZS5uZXdWYWwsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRoZSBtYXhpbXVtIHByb2dyZXNzIHZhbHVlIG9mIHRoZSBgcHJvZ3Jlc3MgYmFyYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKiBwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50IHwgSWd4Q2lyY3VsYXJCYXJDb21wb25lbnQ7XG4gICAgICogcHVibGljIG1heFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgIGxldCBtYXggPSB0aGlzLnByb2dyZXNzQmFyLm1heDtcbiAgICAgKiAgICAgYWxlcnQobWF4KTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC9gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgdmFsdWUgaW4gcGVyY2VudGFnZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKiBwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50OyAvLyBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50XG4gICAgICogcHVibGljIHZhbHVlUGVyY2VudChldmVudCl7XG4gICAgICogICAgIGxldCBwZXJjZW50VmFsdWUgPSB0aGlzLnByb2dyZXNzQmFyLnZhbHVlSW5QZXJjZW50O1xuICAgICAqICAgICBhbGVydChwZXJjZW50VmFsdWUpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHZhbHVlSW5QZXJjZW50KCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRvUGVyY2VudCh0aGlzLl92YWx1ZSwgdGhpcy5fbWF4KTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKiBwdWJsaWMgZ2V0VmFsdWUoZXZlbnQpIHtcbiAgICAgKiAgICAgbGV0IHZhbHVlID0gdGhpcy5wcm9ncmVzc0Jhci52YWx1ZTtcbiAgICAgKiAgICAgYWxlcnQodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW5vdycpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHZhbHVlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCBwb3NpdGlvbi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgdmFsdWUodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRpb24gJiYgdGhpcy5fYW5pbWF0aW9uLnBsYXlTdGF0ZSAhPT0gJ2ZpbmlzaGVkJyB8fCB2YWwgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWxJblJhbmdlID0gdmFsdWVJblJhbmdlKHZhbCwgdGhpcy5tYXgpO1xuXG4gICAgICAgIGlmIChpc05hTih2YWxJblJhbmdlKSB8fCB0aGlzLl92YWx1ZSA9PT0gdmFsIHx8IHRoaXMuaW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRJbml0KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJQcm9ncmVzc1RyYW5zaXRpb24odGhpcy5fdmFsdWUsIHZhbEluUmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5pdFZhbHVlID0gdmFsSW5SYW5nZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB0cmlnZ2VyUHJvZ3Jlc3NUcmFuc2l0aW9uKG9sZFZhbCwgbmV3VmFsLCBtYXhVcGRhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAob2xkVmFsID09PSBuZXdWYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoYW5nZWRWYWx1ZXMgPSB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWU6IG5ld1ZhbCxcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IG9sZFZhbFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHN0ZXBEaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbkZsb3cob2xkVmFsLCBuZXdWYWwpO1xuICAgICAgICBpZiAodGhpcy5fYW5pbWF0ZSkge1xuICAgICAgICAgICAgY29uc3QgbmV3VG9QZXJjZW50ID0gdG9QZXJjZW50KG5ld1ZhbCwgdGhpcy5tYXgpO1xuICAgICAgICAgICAgY29uc3Qgb2xkVG9QZXJjZW50ID0gdG9QZXJjZW50KG9sZFZhbCwgdGhpcy5tYXgpO1xuICAgICAgICAgICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uIC8gTWF0aC5hYnMobmV3VG9QZXJjZW50IC0gb2xkVG9QZXJjZW50KSAvICh0aGlzLl9zdGVwID8gdGhpcy5fc3RlcCA6IDEpO1xuICAgICAgICAgICAgdGhpcy5ydW5BbmltYXRpb24obmV3VmFsKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5pbmNyZWFzZShuZXdWYWwsIHN0ZXBEaXJlY3Rpb24pLCBkdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKG5ld1ZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4VXBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9ncmVzc0NoYW5nZWQuZW1pdChjaGFuZ2VkVmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGluY3JlYXNlKG5ld1ZhbHVlOiBudW1iZXIsIHN0ZXA6IG51bWJlcikge1xuICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRvUGVyY2VudChuZXdWYWx1ZSwgdGhpcy5fbWF4KTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZUluUmFuZ2UodGhpcy5fdmFsdWUsIHRoaXMuX21heCkgKyBzdGVwO1xuICAgICAgICBpZiAoKHN0ZXAgPiAwICYmIHRoaXMudmFsdWVJblBlcmNlbnQgPj0gdGFyZ2V0VmFsdWUpIHx8IChzdGVwIDwgMCAmJiB0aGlzLnZhbHVlSW5QZXJjZW50IDw9IHRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpcmVjdGlvbkZsb3coY3VycmVudFZhbHVlOiBudW1iZXIsIHByZXZWYWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA8IHByZXZWYWx1ZSA/IHRoaXMuc3RlcCA6IC10aGlzLnN0ZXA7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJ1bkFuaW1hdGlvbih2YWx1ZTogbnVtYmVyKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAcGFyYW0gc3RlcFxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlUHJvZ3Jlc3ModmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZUluUmFuZ2UodmFsLCB0aGlzLl9tYXgpO1xuICAgICAgICAvLyB0aGlzLnZhbHVlSW5QZXJjZW50ID0gdG9QZXJjZW50KHZhbCwgdGhpcy5fbWF4KTtcbiAgICAgICAgdGhpcy5ydW5BbmltYXRpb24odmFsKTtcbiAgICB9XG59XG5sZXQgTkVYVF9MSU5FQVJfSUQgPSAwO1xubGV0IE5FWFRfQ0lSQ1VMQVJfSUQgPSAwO1xubGV0IE5FWFRfR1JBRElFTlRfSUQgPSAwO1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtbGluZWFyLWJhcicsXG4gICAgdGVtcGxhdGVVcmw6ICd0ZW1wbGF0ZXMvbGluZWFyLWJhci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbTmdDbGFzc11cbn0pXG5leHBvcnQgY2xhc3MgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlUHJvZ3Jlc3NEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW1pbicpXG4gICAgcHVibGljIHZhbHVlTWluID0gMDtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtbGluZWFyLWJhcic7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCB0byBoYXZlIHN0cmlwZWQgc3R5bGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW3N0cmlwZWRdPVwidHJ1ZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1zdHJpcGVkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzdHJpcGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhci0taW5kZXRlcm1pbmF0ZScpXG4gICAgcHVibGljIGdldCBpc0luZGV0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV0ZXJtaW5hdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGByb2xlYCBhdHRyaWJ1dGUuIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGBwcm9ncmVzc2JhcmAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciByb2xlPVwicHJvZ3Jlc3NiYXJcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByb2xlID0gJ3Byb2dyZXNzYmFyJztcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIGBpZGAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtpZF09XCInaWd4LWxpbmVhci1iYXItNTUnXCIgW3N0cmlwZWRdPVwidHJ1ZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1saW5lYXItYmFyLSR7TkVYVF9MSU5FQVJfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwb3NpdGlvbiB0aGF0IGRlZmluZXMgd2hlcmUgdGhlIHRleHQgaXMgYWxpZ25lZC5cbiAgICAgKiBQb3NzaWJsZSBvcHRpb25zIC0gYElneFRleHRBbGlnbi5TVEFSVGAgKGRlZmF1bHQpLCBgSWd4VGV4dEFsaWduLkNFTlRFUmAsIGBJZ3hUZXh0QWxpZ24uRU5EYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIHBvc2l0aW9uQ2VudGVyOiBJZ3hUZXh0QWxpZ247XG4gICAgICogcHVibGljIG5nT25Jbml0KCkge1xuICAgICAqICAgICB0aGlzLnBvc2l0aW9uQ2VudGVyID0gSWd4VGV4dEFsaWduLkNFTlRFUjtcbiAgICAgKiB9XG4gICAgICogIC8vLi4uXG4gICAgICogYGBgXG4gICAgICogIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgdHlwZT1cIndhcm5pbmdcIiBbdGV4dF09XCInQ3VzdG9tIHRleHQnXCIgW3RleHRBbGlnbl09XCJwb3NpdGlvbkNlbnRlclwiIFtzdHJpcGVkXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHRBbGlnbjogSWd4VGV4dEFsaWduID0gSWd4VGV4dEFsaWduLlNUQVJUO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0ZXh0IHRvIGJlIHZpc2libGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqICA8aWd4LWxpbmVhci1iYXIgdHlwZT1cImRlZmF1bHRcIiBbdGV4dFZpc2liaWxpdHldPVwiZmFsc2VcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHRWaXNpYmlsaXR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zaXRpb24gdGhhdCBkZWZpbmVzIGlmIHRoZSB0ZXh0IHNob3VsZCBiZSBhbGlnbmVkIGFib3ZlIHRoZSBwcm9ncmVzcyBsaW5lLiBCeSBkZWZhdWx0IGlzIHNldCB0byBmYWxzZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogIDxpZ3gtbGluZWFyLWJhciB0eXBlPVwiZXJyb3JcIiBbdGV4dFRvcF09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0ZXh0VG9wID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBjdXN0b20gdGV4dCB0aGF0IGlzIGRpc3BsYXllZCBhY2NvcmRpbmcgdG8gdGhlIGRlZmluZWQgcG9zaXRpb24uXG4gICAgICogIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgdHlwZT1cIndhcm5pbmdcIiBbdGV4dF09XCInQ3VzdG9tIHRleHQnXCIgW3RleHRBbGlnbl09XCJwb3NpdGlvbkNlbnRlclwiIFtzdHJpcGVkXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldCB0eXBlIG9mIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLiBQb3NzaWJsZSBvcHRpb25zIC0gYGRlZmF1bHRgLCBgc3VjY2Vzc2AsIGBpbmZvYCwgYHdhcm5pbmdgLCBhbmQgYGVycm9yYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIxMDBcIiBbdmFsdWVdPVwiMFwiIHR5cGU9XCJlcnJvclwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdHlwZSA9ICdkZWZhdWx0JztcblxuICAgIEBWaWV3Q2hpbGQoJ2luZGljYXRvcicsIHtzdGF0aWM6IHRydWV9KVxuICAgIHByaXZhdGUgX3Byb2dyZXNzSW5kaWNhdG9yOiBFbGVtZW50UmVmO1xuXG4gICAgcHJpdmF0ZSBhbmltYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgd2lkdGg6ICcwJSdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXItLWRhbmdlcicpXG4gICAgcHVibGljIGdldCBlcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4UHJvZ3Jlc3NUeXBlLkVSUk9SO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1pbmZvJylcbiAgICBwdWJsaWMgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5JTkZPO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS13YXJuaW5nJylcbiAgICBwdWJsaWMgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5XQVJOSU5HO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1zdWNjZXNzJylcbiAgICBwdWJsaWMgZ2V0IHN1Y2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5TVUNDRVNTO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclByb2dyZXNzVHJhbnNpdGlvbihNSU5fVkFMVUUsIHRoaXMuX2luaXRWYWx1ZSk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRJbml0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcnVuQW5pbWF0aW9uKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbiAmJiB0aGlzLl9hbmltYXRpb24ucGxheVN0YXRlICE9PSAnZmluaXNoZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZUluUGVyY2VudCA9IHRoaXMubWF4IDw9IDAgPyAwIDogdG9QZXJjZW50KHZhbHVlLCB0aGlzLm1heCk7XG5cbiAgICAgICAgY29uc3QgRlJBTUVTID0gW107XG4gICAgICAgIEZSQU1FU1swXSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuYW5pbWF0aW9uU3RhdGVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLndpZHRoID0gdmFsdWVJblBlcmNlbnQgKyAnJSc7XG4gICAgICAgIEZSQU1FU1sxXSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuYW5pbWF0aW9uU3RhdGVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9hbmltYXRpb24gPSB0aGlzLl9wcm9ncmVzc0luZGljYXRvci5uYXRpdmVFbGVtZW50LmFuaW1hdGUoRlJBTUVTLCB7XG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlLW91dCcsXG4gICAgICAgICAgICBmaWxsOiAnZm9yd2FyZHMnLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuYW5pbWF0aW9uRHVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1jaXJjdWxhci1iYXInLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGVzL2NpcmN1bGFyLWJhci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbTmdUZW1wbGF0ZU91dGxldCwgTmdJZl1cbn0pXG5leHBvcnQgY2xhc3MgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCBleHRlbmRzIEJhc2VQcm9ncmVzc0RpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXQge1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jaXJjdWxhci1iYXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtY2lyY3VsYXItYmFyJztcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIGBpZGAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgW2lkXT1cIidpZ3gtY2lyY3VsYXItYmFyLTU1J1wiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1jaXJjdWxhci1iYXItJHtORVhUX0NJUkNVTEFSX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jaXJjdWxhci1iYXItLWluZGV0ZXJtaW5hdGUnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBpc0luZGV0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV0ZXJtaW5hdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGV4dCB2aXNpYmlsaXR5LiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0cnVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbdGV4dFZpc2liaWxpdHldPVwiZmFsc2VcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dFZpc2liaWxpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSB0ZXh0IHRvIGJlIGRpc3BsYXllZCBpbnNpZGUgdGhlIGBpZ3hDaXJjdWxhckJhcmAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIHRleHQ9XCJQcm9ncmVzc1wiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHRleHQgPSB0aGlzLmNpcmN1bGFyQmFyLnRleHQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dDogc3RyaW5nO1xuXG4gICAgQENvbnRlbnRDaGlsZChJZ3hQcm9ncmVzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hQcm9ncmVzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHB1YmxpYyB0ZXh0VGVtcGxhdGU6IElneFByb2dyZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgQENvbnRlbnRDaGlsZChJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlLCB7IHJlYWQ6IElneFByb2dyZXNzQmFyR3JhZGllbnREaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgZ3JhZGllbnRUZW1wbGF0ZTogSWd4UHJvZ3Jlc3NCYXJHcmFkaWVudERpcmVjdGl2ZTtcblxuICAgIEBWaWV3Q2hpbGQoJ2NpcmNsZScsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJpdmF0ZSBfc3ZnQ2lyY2xlOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBncmFkaWVudElkID0gYGlneC1jaXJjdWxhci1ncmFkaWVudC0ke05FWFRfR1JBRElFTlRfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29udGV4dCgpOiBhbnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGltcGxpY2l0OiB7IHZhbHVlOiB0aGlzLnZhbHVlLCB2YWx1ZUluUGVyY2VudDogdGhpcy52YWx1ZUluUGVyY2VudCwgbWF4OiB0aGlzLm1heCB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2lyY2xlUmFkaXVzID0gNDY7XG4gICAgcHJpdmF0ZSBfY2lyY3VtZmVyZW5jZSA9IDIgKiBNYXRoLlBJICogdGhpcy5fY2lyY2xlUmFkaXVzO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBTVFJPS0VfT1BBQ0lUWV9EVklERVIgPSAxMDA7XG4gICAgcHJpdmF0ZSByZWFkb25seSBTVFJPS0VfT1BBQ0lUWV9BRERJVElPTiA9IC4yO1xuXG4gICAgcHJpdmF0ZSBhbmltYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgc3Ryb2tlRGFzaG9mZnNldDogMjg5LFxuICAgICAgICBzdHJva2VPcGFjaXR5OiAxXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBfZGlyZWN0aW9uYWxpdHk6IElneERpcmVjdGlvbmFsaXR5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyUHJvZ3Jlc3NUcmFuc2l0aW9uKE1JTl9WQUxVRSwgdGhpcy5faW5pdFZhbHVlKTtcbiAgICAgICAgdGhpcy5fY29udGVudEluaXQgPSB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoXG4gICAgICAgICAgICB0aGlzLl9zdmdDaXJjbGUubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgICdzdHJva2UnLFxuICAgICAgICAgICAgYHVybCgjJHt0aGlzLmdyYWRpZW50SWR9KWBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCB0ZXh0Q29udGVudCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH1cblxuICAgIHB1YmxpYyBydW5BbmltYXRpb24odmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uICYmIHRoaXMuX2FuaW1hdGlvbi5wbGF5U3RhdGUgIT09ICdmaW5pc2hlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlSW5QZXJjZW50ID0gdGhpcy5tYXggPD0gMCA/IDAgOiB0b1BlcmNlbnQodmFsdWUsIHRoaXMubWF4KTtcblxuICAgICAgICBjb25zdCBGUkFNRVMgPSBbXTtcbiAgICAgICAgRlJBTUVTWzBdID0gey4uLnRoaXMuYW5pbWF0aW9uU3RhdGV9O1xuXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUuc3Ryb2tlRGFzaG9mZnNldCA9IHRoaXMuZ2V0UHJvZ3Jlc3ModmFsdWVJblBlcmNlbnQpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnN0cm9rZU9wYWNpdHkgPSB0b1BlcmNlbnQodmFsdWUsIHRoaXMubWF4KSAvIHRoaXMuU1RST0tFX09QQUNJVFlfRFZJREVSICsgdGhpcy5TVFJPS0VfT1BBQ0lUWV9BRERJVElPTjtcblxuICAgICAgICBGUkFNRVNbMV0gPSB7XG4gICAgICAgICAgICAuLi50aGlzLmFuaW1hdGlvblN0YXRlXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gdGhpcy5fc3ZnQ2lyY2xlLm5hdGl2ZUVsZW1lbnQuYW5pbWF0ZShGUkFNRVMsIHtcbiAgICAgICAgICAgIGVhc2luZzogJ2Vhc2Utb3V0JyxcbiAgICAgICAgICAgIGZpbGw6ICdmb3J3YXJkcycsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5hbmltYXRpb25EdXJhdGlvblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFByb2dyZXNzKHBlcmNlbnRhZ2U6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uYWxpdHkucnRsID9cbiAgICAgICAgICAgIHRoaXMuX2NpcmN1bWZlcmVuY2UgKyAocGVyY2VudGFnZSAqIHRoaXMuX2NpcmN1bWZlcmVuY2UgLyAxMDApIDpcbiAgICAgICAgICAgIHRoaXMuX2NpcmN1bWZlcmVuY2UgLSAocGVyY2VudGFnZSAqIHRoaXMuX2NpcmN1bWZlcmVuY2UgLyAxMDApO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IHZhbHVlSW5SYW5nZSA9ICh2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlciwgbWluID0gMCk6IG51bWJlciA9PiBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgbWF4KSwgbWluKTtcblxuZXhwb3J0IGNvbnN0IHRvUGVyY2VudCA9ICh2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlcikgPT4gICFtYXggPyAwIDogTWF0aC5mbG9vcigxMDAgKiB2YWx1ZSAvIG1heCk7XG5cbmV4cG9ydCBjb25zdCB0b1ZhbHVlID0gKHZhbHVlOiBudW1iZXIsIG1heDogbnVtYmVyKSA9PiBtYXggKiB2YWx1ZSAvIDEwMDtcblxuXG4iLCI8ZGl2IGNsYXNzPVwiaWd4LWxpbmVhci1iYXJfX2Jhc2VcIj5cbiAgICA8ZGl2ICNpbmRpY2F0b3IgY2xhc3M9XCJpZ3gtbGluZWFyLWJhcl9faW5kaWNhdG9yXCIgW3N0eWxlLndpZHRoXT1cIjBcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWxpbmVhci1iYXJfX2luZGljYXRvci1zZWNvbmRhcnlcIj48L2Rpdj5cbjwvZGl2PlxuXG48c3BhblxuICAgIGNsYXNzPVwiaWd4LWxpbmVhci1iYXJfX3ZhbHVlXCJcbiAgICBbbmdDbGFzc109XCJ7XG4gICAgICAgICdpZ3gtbGluZWFyLWJhcl9fdmFsdWUtLXN0YXJ0JzogdGV4dEFsaWduID09PSAnc3RhcnQnLFxuICAgICAgICAnaWd4LWxpbmVhci1iYXJfX3ZhbHVlLS1jZW50ZXInOiB0ZXh0QWxpZ24gPT09ICdjZW50ZXInLFxuICAgICAgICAnaWd4LWxpbmVhci1iYXJfX3ZhbHVlLS1lbmQnOiB0ZXh0QWxpZ24gPT09ICdlbmQnLFxuICAgICAgICAnaWd4LWxpbmVhci1iYXJfX3ZhbHVlLS10b3AnOiB0ZXh0VG9wLFxuICAgICAgICAnaWd4LWxpbmVhci1iYXJfX3ZhbHVlLS1oaWRkZW4nOiAhdGV4dFZpc2liaWxpdHlcbiAgICB9XCI+XG4gICAgICAgIHt7dGV4dCA/IHRleHQgOiB2YWx1ZUluUGVyY2VudCArICclJ319XG48L3NwYW4+XG4iLCI8c3ZnICNzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHZlcnNpb249XCIxLjFcIlxuICAgIHZpZXdCb3g9XCIwIDAgMTAwIDEwMFwiXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIlxuICAgIHJvbGU9XCJwcm9ncmVzc2JhclwiXG4gICAgYXJpYS12YWx1ZW1pbj1cIjBcIlxuICAgIFthdHRyLmFyaWEtdmFsdWVtYXhdPVwibWF4XCJcbiAgICBbYXR0ci5hcmlhLXZhbHVlbm93XT1cInZhbHVlXCI+XG4gICAgPHN2ZzpjaXJjbGUgY2xhc3M9XCJpZ3gtY2lyY3VsYXItYmFyX19pbm5lclwiIGN4PVwiNTBcIiBjeT1cIjUwXCIgcj1cIjQ2XCIgLz5cbiAgICA8c3ZnOmNpcmNsZSAjY2lyY2xlIGNsYXNzPVwiaWd4LWNpcmN1bGFyLWJhcl9fb3V0ZXJcIiBjeD1cIjUwXCIgY3k9XCI1MFwiIHI9XCI0NlwiIC8+XG5cbiAgICA8c3ZnOmRlZnM+XG4gICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiZ3JhZGllbnRUZW1wbGF0ZSA/IGdyYWRpZW50VGVtcGxhdGUudGVtcGxhdGUgOiBkZWZhdWx0R3JhZGllbnRUZW1wbGF0ZTtcbiAgICAgICAgICAgIGNvbnRleHQ6IHsgJGltcGxpY2l0OiBncmFkaWVudElkIH1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9zdmc6ZGVmcz5cblxuICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdEdyYWRpZW50VGVtcGxhdGU+XG4gICAgICAgIDxzdmc6bGluZWFyR3JhZGllbnQgW2lkXT1cImdyYWRpZW50SWRcIiBncmFkaWVudFRyYW5zZm9ybT1cInJvdGF0ZSg5MClcIj5cbiAgICAgICAgICA8c3RvcCBvZmZzZXQ9XCIwJVwiICAgY2xhc3M9XCJpZ3gtY2lyY3VsYXItYmFyX19ncmFkaWVudC1zdGFydFwiIC8+XG4gICAgICAgICAgPHN0b3Agb2Zmc2V0PVwiMTAwJVwiIGNsYXNzPVwiaWd4LWNpcmN1bGFyLWJhcl9fZ3JhZGllbnQtZW5kXCIgLz5cbiAgICAgICAgPC9zdmc6bGluZWFyR3JhZGllbnQ+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvc3ZnPlxuXG48c3BhbiBjbGFzcz1cImlneC1jaXJjdWxhci1iYXJfX3RleHRcIiAqbmdJZj1cInRleHRWaXNpYmlsaXR5XCI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRleHRUZW1wbGF0ZSA/IHRleHRUZW1wbGF0ZS50ZW1wbGF0ZSA6IGRlZmF1bHRUZXh0VGVtcGxhdGU7XG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XCI+XG4gICAgPC9uZy1jb250YWluZXI+XG48L3NwYW4+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdFRleHRUZW1wbGF0ZT5cbiAgICB7e3RleHRDb250ZW50ID8gdGV4dENvbnRlbnQ6IHZhbHVlSW5QZXJjZW50ICsgJyUnfX1cbjwvbmctdGVtcGxhdGU+XG5cbiJdfQ==