import { Directive, Input, Output, EventEmitter } from '@angular/core';
import { interval, Subject, animationFrameScheduler } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
var DragScrollDirection;
(function (DragScrollDirection) {
    DragScrollDirection[DragScrollDirection["NONE"] = 0] = "NONE";
    DragScrollDirection[DragScrollDirection["LEFT"] = 1] = "LEFT";
    DragScrollDirection[DragScrollDirection["TOP"] = 2] = "TOP";
    DragScrollDirection[DragScrollDirection["RIGHT"] = 3] = "RIGHT";
    DragScrollDirection[DragScrollDirection["BOTTOM"] = 4] = "BOTTOM";
    DragScrollDirection[DragScrollDirection["TOPLEFT"] = 5] = "TOPLEFT";
    DragScrollDirection[DragScrollDirection["TOPRIGHT"] = 6] = "TOPRIGHT";
    DragScrollDirection[DragScrollDirection["BOTTOMLEFT"] = 7] = "BOTTOMLEFT";
    DragScrollDirection[DragScrollDirection["BOTTOMRIGHT"] = 8] = "BOTTOMRIGHT";
})(DragScrollDirection || (DragScrollDirection = {}));
/**
 * An internal directive encapsulating the drag scroll behavior in the grid.
 *
 * @hidden @internal
 */
export class IgxGridDragSelectDirective {
    get activeDrag() {
        return this._activeDrag;
    }
    set activeDrag(val) {
        if (val !== this._activeDrag) {
            this.unsubscribe();
            this._activeDrag = val;
        }
    }
    get nativeElement() {
        return this.ref.nativeElement;
    }
    constructor(ref, zone) {
        this.ref = ref;
        this.zone = zone;
        this.dragStop = new EventEmitter();
        this.dragScroll = new EventEmitter();
        this.end$ = new Subject();
        this.lastDirection = DragScrollDirection.NONE;
        this.startDragSelection = (ev) => {
            if (!this.activeDrag) {
                return;
            }
            const x = ev.clientX;
            const y = ev.clientY;
            const { direction, delta } = this._measureDimensions(x, y);
            if (direction === this.lastDirection) {
                return;
            }
            this.unsubscribe();
            this._sub = this._interval$.subscribe(() => this.dragScroll.emit(delta));
            this.lastDirection = direction;
        };
        this.stopDragSelection = () => {
            if (!this.activeDrag) {
                return;
            }
            this.dragStop.emit(false);
            this.unsubscribe();
            this.lastDirection = DragScrollDirection.NONE;
        };
        this._interval$ = interval(0, animationFrameScheduler).pipe(takeUntil(this.end$), filter(() => this.activeDrag));
    }
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.addEventListener('pointerover', this.startDragSelection);
            this.nativeElement.addEventListener('pointerleave', this.stopDragSelection);
        });
    }
    ngOnDestroy() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.removeEventListener('pointerover', this.startDragSelection);
            this.nativeElement.removeEventListener('pointerleave', this.stopDragSelection);
        });
        this.unsubscribe();
        this.end$.complete();
    }
    _measureDimensions(x, y) {
        let direction;
        let delta = { left: 0, top: 0 };
        const { left, top, width, height } = this.nativeElement.getBoundingClientRect();
        const RATIO = 0.15;
        const offsetX = Math.trunc(x - left);
        const offsetY = Math.trunc(y - top);
        const leftDirection = offsetX <= width * RATIO;
        const rightDirection = offsetX >= width * (1 - RATIO);
        const topDirection = offsetY <= height * RATIO;
        const bottomDirection = offsetY >= height * (1 - RATIO);
        if (topDirection && leftDirection) {
            direction = DragScrollDirection.TOPLEFT;
            delta = { left: -1, top: -1 };
        }
        else if (topDirection && rightDirection) {
            direction = DragScrollDirection.TOPRIGHT;
            delta = { left: 1, top: -1 };
        }
        else if (bottomDirection && leftDirection) {
            direction = DragScrollDirection.BOTTOMLEFT;
            delta = { left: -1, top: 1 };
        }
        else if (bottomDirection && rightDirection) {
            direction = DragScrollDirection.BOTTOMRIGHT;
            delta = { top: 1, left: 1 };
        }
        else if (topDirection) {
            direction = DragScrollDirection.TOP;
            delta.top = -1;
        }
        else if (bottomDirection) {
            direction = DragScrollDirection.BOTTOM;
            delta.top = 1;
        }
        else if (leftDirection) {
            direction = DragScrollDirection.LEFT;
            delta.left = -1;
        }
        else if (rightDirection) {
            direction = DragScrollDirection.RIGHT;
            delta.left = 1;
        }
        else {
            direction = DragScrollDirection.NONE;
        }
        return { direction, delta };
    }
    unsubscribe() {
        if (this._sub) {
            this._sub.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxGridDragSelectDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: IgxGridDragSelectDirective, isStandalone: true, selector: "[igxGridDragSelect]", inputs: { activeDrag: ["igxGridDragSelect", "activeDrag"] }, outputs: { dragStop: "dragStop", dragScroll: "dragScroll" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxGridDragSelectDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxGridDragSelect]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { dragStop: [{
                type: Output
            }], dragScroll: [{
                type: Output
            }], activeDrag: [{
                type: Input,
                args: ['igxGridDragSelect']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZy1zZWxlY3QuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL3NlbGVjdGlvbi9kcmFnLXNlbGVjdC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBeUMsTUFBTSxlQUFlLENBQUM7QUFDOUcsT0FBTyxFQUFFLFFBQVEsRUFBNEIsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzVGLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7O0FBRW5ELElBQUssbUJBVUo7QUFWRCxXQUFLLG1CQUFtQjtJQUNwQiw2REFBSSxDQUFBO0lBQ0osNkRBQUksQ0FBQTtJQUNKLDJEQUFHLENBQUE7SUFDSCwrREFBSyxDQUFBO0lBQ0wsaUVBQU0sQ0FBQTtJQUNOLG1FQUFPLENBQUE7SUFDUCxxRUFBUSxDQUFBO0lBQ1IseUVBQVUsQ0FBQTtJQUNWLDJFQUFXLENBQUE7QUFDZixDQUFDLEVBVkksbUJBQW1CLEtBQW5CLG1CQUFtQixRQVV2QjtBQUVEOzs7O0dBSUc7QUFLSCxNQUFNLE9BQU8sMEJBQTBCO0lBUW5DLElBQ1csVUFBVTtRQUNqQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDNUIsQ0FBQztJQUVELElBQVcsVUFBVSxDQUFDLEdBQVk7UUFDOUIsSUFBSSxHQUFHLEtBQUssSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUMxQixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDbkIsSUFBSSxDQUFDLFdBQVcsR0FBRyxHQUFHLENBQUM7U0FDMUI7SUFDTCxDQUFDO0lBRUQsSUFBVyxhQUFhO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUM7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USxFQUFFLHFCQUFxQjtvQkFDL0IsVUFBVSxFQUFFLElBQUk7aUJBQ25CO3NIQUlVLFFBQVE7c0JBRGQsTUFBTTtnQkFJQSxVQUFVO3NCQURoQixNQUFNO2dCQUlJLFVBQVU7c0JBRHBCLEtBQUs7dUJBQUMsbUJBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIEVsZW1lbnRSZWYsIE9uRGVzdHJveSwgTmdab25lLCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGludGVydmFsLCBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24sIFN1YmplY3QsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZW51bSBEcmFnU2Nyb2xsRGlyZWN0aW9uIHtcbiAgICBOT05FLFxuICAgIExFRlQsXG4gICAgVE9QLFxuICAgIFJJR0hULFxuICAgIEJPVFRPTSxcbiAgICBUT1BMRUZULFxuICAgIFRPUFJJR0hULFxuICAgIEJPVFRPTUxFRlQsXG4gICAgQk9UVE9NUklHSFRcbn1cblxuLyoqXG4gKiBBbiBpbnRlcm5hbCBkaXJlY3RpdmUgZW5jYXBzdWxhdGluZyB0aGUgZHJhZyBzY3JvbGwgYmVoYXZpb3IgaW4gdGhlIGdyaWQuXG4gKlxuICogQGhpZGRlbiBAaW50ZXJuYWxcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4R3JpZERyYWdTZWxlY3RdJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWREcmFnU2VsZWN0RGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGRyYWdTdG9wID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGRyYWdTY3JvbGwgPSBuZXcgRXZlbnRFbWl0dGVyPHsgbGVmdDogbnVtYmVyOyB0b3A6IG51bWJlciB9PigpO1xuXG4gICAgQElucHV0KCdpZ3hHcmlkRHJhZ1NlbGVjdCcpXG4gICAgcHVibGljIGdldCBhY3RpdmVEcmFnKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlRHJhZztcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGFjdGl2ZURyYWcodmFsOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh2YWwgIT09IHRoaXMuX2FjdGl2ZURyYWcpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZURyYWcgPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IG5hdGl2ZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBlbmQkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICAgIHByb3RlY3RlZCBsYXN0RGlyZWN0aW9uID0gRHJhZ1Njcm9sbERpcmVjdGlvbi5OT05FO1xuICAgIHByb3RlY3RlZCBfaW50ZXJ2YWwkOiBPYnNlcnZhYmxlPGFueT47XG4gICAgcHJvdGVjdGVkIF9zdWI6IFN1YnNjcmlwdGlvbjtcblxuICAgIHByaXZhdGUgX2FjdGl2ZURyYWc6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sIHByaXZhdGUgem9uZTogTmdab25lKSB7XG4gICAgICAgIHRoaXMuX2ludGVydmFsJCA9IGludGVydmFsKDAsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKS5waXBlKFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuZW5kJCksXG4gICAgICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5hY3RpdmVEcmFnKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyb3ZlcicsIHRoaXMuc3RhcnREcmFnU2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybGVhdmUnLCB0aGlzLnN0b3BEcmFnU2VsZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJvdmVyJywgdGhpcy5zdGFydERyYWdTZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIHRoaXMuc3RvcERyYWdTZWxlY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmVuZCQuY29tcGxldGUoKTtcbiAgICB9XG5cblxuICAgIHByb3RlY3RlZCBzdGFydERyYWdTZWxlY3Rpb24gPSAoZXY6IFBvaW50ZXJFdmVudCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRHJhZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeCA9IGV2LmNsaWVudFg7XG4gICAgICAgIGNvbnN0IHkgPSBldi5jbGllbnRZO1xuICAgICAgICBjb25zdCB7IGRpcmVjdGlvbiwgZGVsdGEgfSA9IHRoaXMuX21lYXN1cmVEaW1lbnNpb25zKHgsIHkpO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IHRoaXMubGFzdERpcmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLl9zdWIgPSB0aGlzLl9pbnRlcnZhbCQuc3Vic2NyaWJlKCgpID0+IHRoaXMuZHJhZ1Njcm9sbC5lbWl0KGRlbHRhKSk7XG4gICAgICAgIHRoaXMubGFzdERpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIHN0b3BEcmFnU2VsZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlRHJhZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kcmFnU3RvcC5lbWl0KGZhbHNlKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmxhc3REaXJlY3Rpb24gPSBEcmFnU2Nyb2xsRGlyZWN0aW9uLk5PTkU7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfbWVhc3VyZURpbWVuc2lvbnMoeDogbnVtYmVyLCB5OiBudW1iZXIpOiB7IGRpcmVjdGlvbjogRHJhZ1Njcm9sbERpcmVjdGlvbjsgZGVsdGE6IHsgbGVmdDogbnVtYmVyOyB0b3A6IG51bWJlciB9IH0ge1xuICAgICAgICBsZXQgZGlyZWN0aW9uOiBEcmFnU2Nyb2xsRGlyZWN0aW9uO1xuICAgICAgICBsZXQgZGVsdGEgPSB7IGxlZnQ6IDAsIHRvcDogMCB9O1xuICAgICAgICBjb25zdCB7IGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBSQVRJTyA9IDAuMTU7XG5cbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgudHJ1bmMoeCAtIGxlZnQpO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gTWF0aC50cnVuYyh5IC0gdG9wKTtcblxuICAgICAgICBjb25zdCBsZWZ0RGlyZWN0aW9uID0gb2Zmc2V0WCA8PSB3aWR0aCAqIFJBVElPO1xuICAgICAgICBjb25zdCByaWdodERpcmVjdGlvbiA9IG9mZnNldFggPj0gd2lkdGggKiAoMSAtIFJBVElPKTtcbiAgICAgICAgY29uc3QgdG9wRGlyZWN0aW9uID0gb2Zmc2V0WSA8PSBoZWlnaHQgKiBSQVRJTztcbiAgICAgICAgY29uc3QgYm90dG9tRGlyZWN0aW9uID0gb2Zmc2V0WSA+PSBoZWlnaHQgKiAoMSAtIFJBVElPKTtcblxuICAgICAgICBpZiAodG9wRGlyZWN0aW9uICYmIGxlZnREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IERyYWdTY3JvbGxEaXJlY3Rpb24uVE9QTEVGVDtcbiAgICAgICAgICAgIGRlbHRhID0geyBsZWZ0OiAtMSwgdG9wOiAtMSB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRvcERpcmVjdGlvbiAmJiByaWdodERpcmVjdGlvbikge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gRHJhZ1Njcm9sbERpcmVjdGlvbi5UT1BSSUdIVDtcbiAgICAgICAgICAgIGRlbHRhID0geyBsZWZ0OiAxLCB0b3A6IC0xIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYm90dG9tRGlyZWN0aW9uICYmIGxlZnREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IERyYWdTY3JvbGxEaXJlY3Rpb24uQk9UVE9NTEVGVDtcbiAgICAgICAgICAgIGRlbHRhID0geyBsZWZ0OiAtMSwgdG9wOiAxIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYm90dG9tRGlyZWN0aW9uICYmIHJpZ2h0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBEcmFnU2Nyb2xsRGlyZWN0aW9uLkJPVFRPTVJJR0hUO1xuICAgICAgICAgICAgZGVsdGEgPSB7IHRvcDogMSwgbGVmdDogMSB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRvcERpcmVjdGlvbikge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gRHJhZ1Njcm9sbERpcmVjdGlvbi5UT1A7XG4gICAgICAgICAgICBkZWx0YS50b3AgPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChib3R0b21EaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IERyYWdTY3JvbGxEaXJlY3Rpb24uQk9UVE9NO1xuICAgICAgICAgICAgZGVsdGEudG9wID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChsZWZ0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBEcmFnU2Nyb2xsRGlyZWN0aW9uLkxFRlQ7XG4gICAgICAgICAgICBkZWx0YS5sZWZ0ID0gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAocmlnaHREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IERyYWdTY3JvbGxEaXJlY3Rpb24uUklHSFQ7XG4gICAgICAgICAgICBkZWx0YS5sZWZ0ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IERyYWdTY3JvbGxEaXJlY3Rpb24uTk9ORTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGRpcmVjdGlvbiwgZGVsdGEgfTtcblxuICAgIH1cblxuICAgIHByb3RlY3RlZCB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N1Yikge1xuICAgICAgICAgICAgdGhpcy5fc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=