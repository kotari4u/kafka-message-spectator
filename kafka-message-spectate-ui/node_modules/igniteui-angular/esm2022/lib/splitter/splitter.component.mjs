import { DOCUMENT, NgFor, NgIf } from '@angular/common';
import { Component, ContentChildren, EventEmitter, HostBinding, HostListener, Inject, Input, Output, forwardRef } from '@angular/core';
import { DragDirection, IgxDragDirective, IgxDragIgnoreDirective } from '../directives/drag-drop/drag-drop.directive';
import { IgxSplitterPaneComponent } from './splitter-pane/splitter-pane.component';
import * as i0 from "@angular/core";
/**
 * An enumeration that defines the `SplitterComponent` panes orientation.
 */
export var SplitterType;
(function (SplitterType) {
    SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
    SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
})(SplitterType || (SplitterType = {}));
/**
 * Provides a framework for a simple layout, splitting the view horizontally or vertically
 * into multiple smaller resizable and collapsible areas.
 *
 * @igxModule IgxSplitterModule
 *
 * @igxParent Layouts
 *
 * @igxTheme igx-splitter-theme
 *
 * @igxKeywords splitter panes layout
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <igx-splitter>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 * </igx-splitter>
 * ```
 */
export class IgxSplitterComponent {
    /**
     * @hidden
     * @internal
     */
    get orientation() {
        return this.type === SplitterType.Horizontal ? 'horizontal' : 'vertical';
    }
    constructor(document, elementRef) {
        this.document = document;
        this.elementRef = elementRef;
        /**
        * @hidden
        * @internal
        */
        this.cssClass = 'igx-splitter';
        /**
         * @hidden @internal
         * Gets/Sets the `overflow` property of the current splitter.
         */
        this.overflow = 'hidden';
        /**
         * @hidden @internal
         * Sets/Gets the `display` property of the current splitter.
         */
        this.display = 'flex';
        /**
         * Event fired when resizing of panes starts.
         *
         * @example
         * ```html
         * <igx-splitter (resizeStart)='resizeStart($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizeStart = new EventEmitter();
        /**
         * Event fired when resizing of panes is in progress.
         *
         * @example
         * ```html
         * <igx-splitter (resizing)='resizing($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizing = new EventEmitter();
        /**
         * Event fired when resizing of panes ends.
         *
         * @example
         * ```html
         * <igx-splitter (resizeEnd)='resizeEnd($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizeEnd = new EventEmitter();
        this._type = SplitterType.Horizontal;
    }
    /**
     * Gets/Sets the splitter orientation.
     *
     * @example
     * ```html
     * <igx-splitter [type]="type">...</igx-splitter>
     * ```
     */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
        this.resetPaneSizes();
        this.panes?.notifyOnChanges();
    }
    /**
     * @hidden @internal
     * Gets the `flex-direction` property of the current `SplitterComponent`.
     */
    get direction() {
        return this.type === SplitterType.Horizontal ? 'row' : 'column';
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this.initPanes();
        this.panes.changes.subscribe(() => {
            this.initPanes();
        });
    }
    /**
     * @hidden @internal
     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
     * @param pane - the main pane associated with the currently dragged bar.
     */
    onMoveStart(pane) {
        const panes = this.panes.toArray();
        this.pane = pane;
        this.sibling = panes[panes.indexOf(this.pane) + 1];
        const paneRect = this.pane.element.getBoundingClientRect();
        this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        const siblingRect = this.sibling.element.getBoundingClientRect();
        this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizeStart.emit(args);
    }
    /**
     * @hidden @internal
     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
     */
    onMoving(delta) {
        const [paneSize, siblingSize] = this.calcNewSizes(delta);
        this.pane.dragSize = paneSize + 'px';
        this.sibling.dragSize = siblingSize + 'px';
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizing.emit(args);
    }
    onMoveEnd(delta) {
        const [paneSize, siblingSize] = this.calcNewSizes(delta);
        if (this.pane.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentPaneSize = (paneSize / totalSize) * 100;
            this.pane.size = percentPaneSize + '%';
        }
        else {
            // px resize
            this.pane.size = paneSize + 'px';
        }
        if (this.sibling.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentSiblingPaneSize = (siblingSize / totalSize) * 100;
            this.sibling.size = percentSiblingPaneSize + '%';
        }
        else {
            // px resize
            this.sibling.size = siblingSize + 'px';
        }
        this.pane.dragSize = null;
        this.sibling.dragSize = null;
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizeEnd.emit(args);
    }
    /** @hidden @internal */
    getPaneSiblingsByOrder(order, barIndex) {
        const panes = this.panes.toArray();
        const prevPane = panes[order - barIndex - 1];
        const nextPane = panes[order - barIndex];
        const siblings = [prevPane, nextPane];
        return siblings;
    }
    getTotalSize() {
        const computed = this.document.defaultView.getComputedStyle(this.elementRef.nativeElement);
        const totalSize = this.type === SplitterType.Horizontal ? computed.getPropertyValue('width') : computed.getPropertyValue('height');
        return parseFloat(totalSize);
    }
    /**
     * @hidden @internal
     * This method inits panes with properties.
     */
    initPanes() {
        this.panes.forEach(pane => {
            pane.owner = this;
            if (this.type === SplitterType.Horizontal) {
                pane.minWidth = pane.minSize ?? '0';
                pane.maxWidth = pane.maxSize ?? '100%';
            }
            else {
                pane.minHeight = pane.minSize ?? '0';
                pane.maxHeight = pane.maxSize ?? '100%';
            }
        });
        this.assignFlexOrder();
        if (this.panes.filter(x => x.collapsed).length > 0) {
            // if any panes are collapsed, reset sizes.
            this.resetPaneSizes();
        }
    }
    /**
     * @hidden @internal
     * This method reset pane sizes.
     */
    resetPaneSizes() {
        if (this.panes) {
            // if type is changed runtime, should reset sizes.
            this.panes.forEach(x => {
                x.size = 'auto';
                x.minWidth = '0';
                x.maxWidth = '100%';
                x.minHeight = '0';
                x.maxHeight = '100%';
            });
        }
    }
    /**
     * @hidden @internal
     * This method assigns the order of each pane.
     */
    assignFlexOrder() {
        let k = 0;
        this.panes.forEach((pane) => {
            pane.order = k;
            k += 2;
        });
    }
    /**
     * @hidden @internal
     * Calculates new sizes for the panes based on move delta and initial sizes
     */
    calcNewSizes(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize - minSibling;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize - min;
        if (delta < 0) {
            const maxPossibleDelta = Math.min(max - this.initialPaneSize, this.initialSiblingSize - minSibling);
            delta = Math.min(maxPossibleDelta, Math.abs(delta)) * -1;
        }
        else {
            const maxPossibleDelta = Math.min(this.initialPaneSize - min, maxSibling - this.initialSiblingSize);
            delta = Math.min(maxPossibleDelta, Math.abs(delta));
        }
        return [this.initialPaneSize - delta, this.initialSiblingSize + delta];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxSplitterComponent, deps: [{ token: DOCUMENT }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxSplitterComponent, isStandalone: true, selector: "igx-splitter", inputs: { type: "type" }, outputs: { resizeStart: "resizeStart", resizing: "resizing", resizeEnd: "resizeEnd" }, host: { properties: { "class.igx-splitter": "this.cssClass", "style.overflow": "this.overflow", "style.display": "this.display", "attr.aria-orientation": "this.orientation", "style.flex-direction": "this.direction" } }, queries: [{ propertyName: "panes", predicate: IgxSplitterPaneComponent, read: IgxSplitterPaneComponent }], ngImport: i0, template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\"\n                    (movingEnd)='onMoveEnd($event)'>\n    </igx-splitter-bar>\n</ng-container>\n", dependencies: [{ kind: "directive", type: i0.forwardRef(function () { return NgFor; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i0.forwardRef(function () { return NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i0.forwardRef(function () { return IgxSplitBarComponent; }), selector: "igx-splitter-bar", inputs: ["type", "order", "pane", "siblings"], outputs: ["moveStart", "moving", "movingEnd"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxSplitterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-splitter', standalone: true, imports: [NgFor, NgIf, forwardRef(() => IgxSplitBarComponent)], template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\"\n                    (movingEnd)='onMoveEnd($event)'>\n    </igx-splitter-bar>\n</ng-container>\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.ElementRef }]; }, propDecorators: { panes: [{
                type: ContentChildren,
                args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent }]
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-splitter']
            }], overflow: [{
                type: HostBinding,
                args: ['style.overflow']
            }], display: [{
                type: HostBinding,
                args: ['style.display']
            }], orientation: [{
                type: HostBinding,
                args: ['attr.aria-orientation']
            }], resizeStart: [{
                type: Output
            }], resizing: [{
                type: Output
            }], resizeEnd: [{
                type: Output
            }], type: [{
                type: Input
            }], direction: [{
                type: HostBinding,
                args: ['style.flex-direction']
            }] } });
export const SPLITTER_INTERACTION_KEYS = new Set('right down left up arrowright arrowdown arrowleft arrowup'.split(' '));
/**
 * @hidden @internal
 * Represents the draggable bar that visually separates panes and allows for changing their sizes.
 */
export class IgxSplitBarComponent {
    constructor() {
        /**
         * Set css class to the host element.
         */
        this.cssClass = 'igx-splitter-bar-host';
        /**
         * Gets/Sets the orientation.
         */
        this.type = SplitterType.Horizontal;
        /**
         * An event that is emitted whenever we start dragging the current `SplitBarComponent`.
         */
        this.moveStart = new EventEmitter();
        /**
         * An event that is emitted while we are dragging the current `SplitBarComponent`.
         */
        this.moving = new EventEmitter();
        this.movingEnd = new EventEmitter();
    }
    /**
     * @hidden
     * @internal
     */
    get tabindex() {
        return this.resizeDisallowed ? null : 0;
    }
    /**
     * @hidden
     * @internal
     */
    get orientation() {
        return this.type === SplitterType.Horizontal ? 'horizontal' : 'vertical';
    }
    /**
     * @hidden
     * @internal
     */
    get cursor() {
        if (this.resizeDisallowed) {
            return '';
        }
        return this.type === SplitterType.Horizontal ? 'col-resize' : 'row-resize';
    }
    /**
     * @hidden @internal
     */
    get prevButtonHidden() {
        return this.siblings[0].collapsed && !this.siblings[1].collapsed;
    }
    /**
     * @hidden @internal
     */
    keyEvent(event) {
        const key = event.key.toLowerCase();
        const ctrl = event.ctrlKey;
        event.stopPropagation();
        if (SPLITTER_INTERACTION_KEYS.has(key)) {
            event.preventDefault();
        }
        switch (key) {
            case 'arrowup':
            case 'up':
                if (this.type === SplitterType.Vertical) {
                    if (ctrl) {
                        this.onCollapsing(false);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(10);
                    }
                }
                break;
            case 'arrowdown':
            case 'down':
                if (this.type === SplitterType.Vertical) {
                    if (ctrl) {
                        this.onCollapsing(true);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(-10);
                    }
                }
                break;
            case 'arrowleft':
            case 'left':
                if (this.type === SplitterType.Horizontal) {
                    if (ctrl) {
                        this.onCollapsing(false);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(10);
                    }
                }
                break;
            case 'arrowright':
            case 'right':
                if (this.type === SplitterType.Horizontal) {
                    if (ctrl) {
                        this.onCollapsing(true);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(-10);
                    }
                }
                break;
            default:
                break;
        }
    }
    /**
     * @hidden @internal
     */
    get dragDir() {
        return this.type === SplitterType.Horizontal ? DragDirection.VERTICAL : DragDirection.HORIZONTAL;
    }
    /**
     * @hidden @internal
     */
    get nextButtonHidden() {
        return this.siblings[1].collapsed && !this.siblings[0].collapsed;
    }
    /**
     * @hidden @internal
     */
    onDragStart(event) {
        if (this.resizeDisallowed) {
            event.cancel = true;
            return;
        }
        this.startPoint = this.type === SplitterType.Horizontal ? event.startX : event.startY;
        this.moveStart.emit(this.pane);
    }
    /**
     * @hidden @internal
     */
    onDragMove(event) {
        const isHorizontal = this.type === SplitterType.Horizontal;
        const curr = isHorizontal ? event.pageX : event.pageY;
        const delta = this.startPoint - curr;
        if (delta !== 0) {
            this.moving.emit(delta);
            event.cancel = true;
            event.owner.element.nativeElement.style.transform = '';
        }
    }
    onDragEnd(event) {
        const isHorizontal = this.type === SplitterType.Horizontal;
        const curr = isHorizontal ? event.pageX : event.pageY;
        const delta = this.startPoint - curr;
        if (delta !== 0) {
            this.movingEnd.emit(delta);
        }
    }
    get resizeDisallowed() {
        const relatedTabs = this.siblings;
        return !!relatedTabs.find(x => x.resizable === false || x.collapsed === true);
    }
    /**
     * @hidden @internal
     */
    onCollapsing(next) {
        const prevSibling = this.siblings[0];
        const nextSibling = this.siblings[1];
        let target;
        if (next) {
            // if next is clicked when prev pane is hidden, show prev pane, else hide next pane.
            target = prevSibling.collapsed ? prevSibling : nextSibling;
        }
        else {
            // if prev is clicked when next pane is hidden, show next pane, else hide prev pane.
            target = nextSibling.collapsed ? nextSibling : prevSibling;
        }
        target.toggle();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxSplitBarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxSplitBarComponent, isStandalone: true, selector: "igx-splitter-bar", inputs: { type: "type", order: "order", pane: "pane", siblings: "siblings" }, outputs: { moveStart: "moveStart", moving: "moving", movingEnd: "movingEnd" }, host: { listeners: { "keydown": "keyEvent($event)" }, properties: { "class.igx-splitter-bar-host": "this.cssClass", "style.order": "this.order", "attr.tabindex": "this.tabindex", "attr.aria-orientation": "this.orientation" } }, ngImport: i0, template: "<div class=\"igx-splitter-bar\"\n    [class.igx-splitter-bar--vertical]='type === 0'\n    [style.cursor]='cursor'\n    igxDrag\n    [ghost]=\"false\"\n    [dragDirection]='dragDir'\n    (dragStart)='onDragStart($event)'\n    (dragMove)=\"onDragMove($event)\"\n    (dragEnd)=\"onDragEnd($event)\"\n>\n    <div class=\"igx-splitter-bar__expander--start\" igxDragIgnore (click)='onCollapsing(false)' [hidden]='prevButtonHidden'></div>\n    <div class=\"igx-splitter-bar__handle\" ></div>\n    <div class=\"igx-splitter-bar__expander--end\" igxDragIgnore (click)='onCollapsing(true)' [hidden]='nextButtonHidden'></div>\n</div>\n", dependencies: [{ kind: "directive", type: IgxDragDirective, selector: "[igxDrag]", inputs: ["igxDrag", "dragTolerance", "dragDirection", "dragChannel", "ghost", "ghostClass", "ghostTemplate", "ghostHost", "scrollContainer", "ghostOffsetX", "ghostOffsetY"], outputs: ["dragStart", "dragMove", "dragEnd", "dragClick", "ghostCreate", "ghostDestroy", "transitioned"], exportAs: ["drag"] }, { kind: "directive", type: IgxDragIgnoreDirective, selector: "[igxDragIgnore]" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxSplitBarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-splitter-bar', standalone: true, imports: [IgxDragDirective, IgxDragIgnoreDirective], template: "<div class=\"igx-splitter-bar\"\n    [class.igx-splitter-bar--vertical]='type === 0'\n    [style.cursor]='cursor'\n    igxDrag\n    [ghost]=\"false\"\n    [dragDirection]='dragDir'\n    (dragStart)='onDragStart($event)'\n    (dragMove)=\"onDragMove($event)\"\n    (dragEnd)=\"onDragEnd($event)\"\n>\n    <div class=\"igx-splitter-bar__expander--start\" igxDragIgnore (click)='onCollapsing(false)' [hidden]='prevButtonHidden'></div>\n    <div class=\"igx-splitter-bar__handle\" ></div>\n    <div class=\"igx-splitter-bar__expander--end\" igxDragIgnore (click)='onCollapsing(true)' [hidden]='nextButtonHidden'></div>\n</div>\n" }]
        }], propDecorators: { cssClass: [{
                type: HostBinding,
                args: ['class.igx-splitter-bar-host']
            }], type: [{
                type: Input
            }], order: [{
                type: HostBinding,
                args: ['style.order']
            }, {
                type: Input
            }], tabindex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], orientation: [{
                type: HostBinding,
                args: ['attr.aria-orientation']
            }], pane: [{
                type: Input
            }], siblings: [{
                type: Input
            }], moveStart: [{
                type: Output
            }], moving: [{
                type: Output
            }], movingEnd: [{
                type: Output
            }], keyEvent: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3NwbGl0dGVyL3NwbGl0dGVyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zcGxpdHRlci9zcGxpdHRlci5jb21wb25lbnQuaHRtbCIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zcGxpdHRlci9zcGxpdHRlci1iYXIuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDeEQsT0FBTyxFQUFvQixTQUFTLEVBQUUsZUFBZSxFQUFjLFlBQVksRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFhLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoTCxPQUFPLEVBQUUsYUFBYSxFQUEyQyxnQkFBZ0IsRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBQy9KLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHlDQUF5QyxDQUFDOztBQUVuRjs7R0FFRztBQUNILE1BQU0sQ0FBTixJQUFZLFlBR1g7QUFIRCxXQUFZLFlBQVk7SUFDcEIsMkRBQVUsQ0FBQTtJQUNWLHVEQUFRLENBQUE7QUFDWixDQUFDLEVBSFcsWUFBWSxLQUFaLFlBQVksUUFHdkI7QUFPRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlCRztBQU9ILE1BQU0sT0FBTyxvQkFBb0I7SUFpQzdCOzs7T0FHRztJQUNILElBQ1csV0FBVztRQUNsQixPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssWUFBWSxDQUFDLFVBQVUs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WyJpbXBvcnQgeyBET0NVTUVOVCwgTmdGb3IsIE5nSWYgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbnB1dCwgT3V0cHV0LCBRdWVyeUxpc3QsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERyYWdEaXJlY3Rpb24sIElEcmFnTW92ZUV2ZW50QXJncywgSURyYWdTdGFydEV2ZW50QXJncywgSWd4RHJhZ0RpcmVjdGl2ZSwgSWd4RHJhZ0lnbm9yZURpcmVjdGl2ZSB9IGZyb20gJy4uL2RpcmVjdGl2ZXMvZHJhZy1kcm9wL2RyYWctZHJvcC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50IH0gZnJvbSAnLi9zcGxpdHRlci1wYW5lL3NwbGl0dGVyLXBhbmUuY29tcG9uZW50JztcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiB0aGF0IGRlZmluZXMgdGhlIGBTcGxpdHRlckNvbXBvbmVudGAgcGFuZXMgb3JpZW50YXRpb24uXG4gKi9cbmV4cG9ydCBlbnVtIFNwbGl0dGVyVHlwZSB7XG4gICAgSG9yaXpvbnRhbCxcbiAgICBWZXJ0aWNhbFxufVxuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgSVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzIHtcbiAgICBwYW5lOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ7XG4gICAgc2libGluZzogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGEgZnJhbWV3b3JrIGZvciBhIHNpbXBsZSBsYXlvdXQsIHNwbGl0dGluZyB0aGUgdmlldyBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxuICogaW50byBtdWx0aXBsZSBzbWFsbGVyIHJlc2l6YWJsZSBhbmQgY29sbGFwc2libGUgYXJlYXMuXG4gKlxuICogQGlneE1vZHVsZSBJZ3hTcGxpdHRlck1vZHVsZVxuICpcbiAqIEBpZ3hQYXJlbnQgTGF5b3V0c1xuICpcbiAqIEBpZ3hUaGVtZSBpZ3gtc3BsaXR0ZXItdGhlbWVcbiAqXG4gKiBAaWd4S2V5d29yZHMgc3BsaXR0ZXIgcGFuZXMgbGF5b3V0XG4gKlxuICogQGlneEdyb3VwIHByZXNlbnRhdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiA8aWd4LXNwbGl0dGVyPlxuICogIDxpZ3gtc3BsaXR0ZXItcGFuZT5cbiAqICAgICAgLi4uXG4gKiAgPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAqICA8aWd4LXNwbGl0dGVyLXBhbmU+XG4gKiAgICAgIC4uLlxuICogIDwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gKiA8L2lneC1zcGxpdHRlcj5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1zcGxpdHRlcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NwbGl0dGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtOZ0ZvciwgTmdJZiwgZm9yd2FyZFJlZigoKSA9PiBJZ3hTcGxpdEJhckNvbXBvbmVudCldXG59KVxuZXhwb3J0IGNsYXNzIElneFNwbGl0dGVyQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGlzdCBvZiBzcGxpdHRlciBwYW5lcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHBhbmVzID0gdGhpcy5zcGxpdHRlci5wYW5lcztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCwgeyByZWFkOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQgfSlcbiAgICBwdWJsaWMgcGFuZXMhOiBRdWVyeUxpc3Q8SWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICogQGludGVybmFsXG4gICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1zcGxpdHRlcicpXG4gICAgcHVibGljIGNzc0NsYXNzID0gJ2lneC1zcGxpdHRlcic7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMvU2V0cyB0aGUgYG92ZXJmbG93YCBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBzcGxpdHRlci5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLm92ZXJmbG93JylcbiAgICBwdWJsaWMgb3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogU2V0cy9HZXRzIHRoZSBgZGlzcGxheWAgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgc3BsaXR0ZXIuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5kaXNwbGF5JylcbiAgICBwdWJsaWMgZGlzcGxheSA9ICdmbGV4JztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1vcmllbnRhdGlvbicpXG4gICAgcHVibGljIGdldCBvcmllbnRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyAnaG9yaXpvbnRhbCcgOiAndmVydGljYWwnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gcmVzaXppbmcgb2YgcGFuZXMgc3RhcnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlciAocmVzaXplU3RhcnQpPSdyZXNpemVTdGFydCgkZXZlbnQpJz5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlc2l6ZVN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcjxJU3BsaXR0ZXJCYXJSZXNpemVFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHJlc2l6aW5nIG9mIHBhbmVzIGlzIGluIHByb2dyZXNzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlciAocmVzaXppbmcpPSdyZXNpemluZygkZXZlbnQpJz5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlc2l6aW5nID0gbmV3IEV2ZW50RW1pdHRlcjxJU3BsaXR0ZXJCYXJSZXNpemVFdmVudEFyZ3M+KCk7XG5cblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gcmVzaXppbmcgb2YgcGFuZXMgZW5kcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXIgKHJlc2l6ZUVuZCk9J3Jlc2l6ZUVuZCgkZXZlbnQpJz5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHJlc2l6ZUVuZCA9IG5ldyBFdmVudEVtaXR0ZXI8SVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzPigpO1xuXG4gICAgcHJpdmF0ZSBfdHlwZTogU3BsaXR0ZXJUeXBlID0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWw7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEEgZmllbGQgdGhhdCBob2xkcyB0aGUgaW5pdGlhbCBzaXplIG9mIHRoZSBtYWluIGBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnRgIGluIGVhY2ggcGFpciBvZiBwYW5lcyBkaXZpZGVkIGJ5IGEgc3BsaXR0ZXIgYmFyLlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdGlhbFBhbmVTaXplITogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBBIGZpZWxkIHRoYXQgaG9sZHMgdGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgc2libGluZyBwYW5lIGluIGVhY2ggcGFpciBvZiBwYW5lcyBkaXZpZGVkIGJ5IGEgZ3JpcHBlci5cbiAgICAgKiBAbWVtYmVyb2YgU3BsaXR0ZXJDb21wb25lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRpYWxTaWJsaW5nU2l6ZSE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhlIG1haW4gcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIGdyaXBwZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBwYW5lITogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNpYmxpbmcgcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIHNwbGl0dGVyIGJhci5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNpYmxpbmchOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ7XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KERPQ1VNRU5UKSBwdWJsaWMgZG9jdW1lbnQsIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBzcGxpdHRlciBvcmllbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXIgW3R5cGVdPVwidHlwZVwiPi4uLjwvaWd4LXNwbGl0dGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG4gICAgcHVibGljIHNldCB0eXBlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5yZXNldFBhbmVTaXplcygpO1xuICAgICAgICB0aGlzLnBhbmVzPy5ub3RpZnlPbkNoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMgdGhlIGBmbGV4LWRpcmVjdGlvbmAgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgYFNwbGl0dGVyQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmZsZXgtZGlyZWN0aW9uJylcbiAgICBwdWJsaWMgZ2V0IGRpcmVjdGlvbigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/ICdyb3cnIDogJ2NvbHVtbic7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pbml0UGFuZXMoKTtcbiAgICAgICAgdGhpcy5wYW5lcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmluaXRQYW5lcygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zICBpbml0aWFsaXphdGlvbiBsb2dpYyB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgc3BsaXR0ZXIgYmFyIGJldHdlZW4gZWFjaCBwYWlyIG9mIHBhbmVzLlxuICAgICAqIEBwYXJhbSBwYW5lIC0gdGhlIG1haW4gcGFuZSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnRseSBkcmFnZ2VkIGJhci5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25Nb3ZlU3RhcnQocGFuZTogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IHBhbmVzID0gdGhpcy5wYW5lcy50b0FycmF5KCk7XG4gICAgICAgIHRoaXMucGFuZSA9IHBhbmU7XG4gICAgICAgIHRoaXMuc2libGluZyA9IHBhbmVzW3BhbmVzLmluZGV4T2YodGhpcy5wYW5lKSArIDFdO1xuXG4gICAgICAgIGNvbnN0IHBhbmVSZWN0ID0gdGhpcy5wYW5lLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFBhbmVTaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IHBhbmVSZWN0LndpZHRoIDogcGFuZVJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IHNpYmxpbmdSZWN0ID0gdGhpcy5zaWJsaW5nLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IHNpYmxpbmdSZWN0LndpZHRoIDogc2libGluZ1JlY3QuaGVpZ2h0O1xuICAgICAgICBjb25zdCBhcmdzOiBJU3BsaXR0ZXJCYXJSZXNpemVFdmVudEFyZ3MgPSB7IHBhbmU6IHRoaXMucGFuZSwgc2libGluZzogdGhpcy5zaWJsaW5nIH07XG4gICAgICAgIHRoaXMucmVzaXplU3RhcnQuZW1pdChhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIGNhbGN1bGF0aW9ucyBjb25jZXJuaW5nIHRoZSBzaXplcyBvZiBlYWNoIHBhaXIgb2YgcGFuZXMgd2hlbiB0aGUgYmFyIGJldHdlZW4gdGhlbSBpcyBkcmFnZ2VkLlxuICAgICAqIEBwYXJhbSBkZWx0YSAtIFRoZSBkaWZmZXJlbmNlIGFsb25nIHRoZSBYIChvciBZKSBheGlzIGJldHdlZW4gdGhlIGluaXRpYWwgYW5kIHRoZSBjdXJyZW50IHBvaW50IHdoZW4gZHJhZ2dpbmcgdGhlIGJhci5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25Nb3ZpbmcoZGVsdGE6IG51bWJlcikge1xuICAgICAgICBjb25zdCBbIHBhbmVTaXplLCBzaWJsaW5nU2l6ZSBdID0gdGhpcy5jYWxjTmV3U2l6ZXMoZGVsdGEpO1xuXG4gICAgICAgIHRoaXMucGFuZS5kcmFnU2l6ZSA9IHBhbmVTaXplICsgJ3B4JztcbiAgICAgICAgdGhpcy5zaWJsaW5nLmRyYWdTaXplID0gc2libGluZ1NpemUgKyAncHgnO1xuXG4gICAgICAgIGNvbnN0IGFyZ3M6IElTcGxpdHRlckJhclJlc2l6ZUV2ZW50QXJncyA9IHsgcGFuZTogdGhpcy5wYW5lLCBzaWJsaW5nOiB0aGlzLnNpYmxpbmcgfTtcbiAgICAgICAgdGhpcy5yZXNpemluZy5lbWl0KGFyZ3MpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvbk1vdmVFbmQoZGVsdGE6IG51bWJlcikge1xuICAgICAgICBjb25zdCBbIHBhbmVTaXplLCBzaWJsaW5nU2l6ZSBdID0gdGhpcy5jYWxjTmV3U2l6ZXMoZGVsdGEpO1xuXG4gICAgICAgIGlmICh0aGlzLnBhbmUuaXNQZXJjZW50YWdlU2l6ZSkge1xuICAgICAgICAgICAgLy8gaGFuZGxlICUgcmVzaXplc1xuICAgICAgICAgICAgY29uc3QgdG90YWxTaXplID0gdGhpcy5nZXRUb3RhbFNpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRQYW5lU2l6ZSA9IChwYW5lU2l6ZSAvIHRvdGFsU2l6ZSkgKiAxMDA7XG4gICAgICAgICAgICB0aGlzLnBhbmUuc2l6ZSA9IHBlcmNlbnRQYW5lU2l6ZSArICclJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHB4IHJlc2l6ZVxuICAgICAgICAgICAgdGhpcy5wYW5lLnNpemUgPSBwYW5lU2l6ZSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zaWJsaW5nLmlzUGVyY2VudGFnZVNpemUpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSAlIHJlc2l6ZXNcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHRoaXMuZ2V0VG90YWxTaXplKCk7XG4gICAgICAgICAgICBjb25zdCBwZXJjZW50U2libGluZ1BhbmVTaXplID0gKHNpYmxpbmdTaXplIC8gdG90YWxTaXplKSAqIDEwMDtcbiAgICAgICAgICAgIHRoaXMuc2libGluZy5zaXplID0gcGVyY2VudFNpYmxpbmdQYW5lU2l6ZSArICclJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHB4IHJlc2l6ZVxuICAgICAgICAgICAgdGhpcy5zaWJsaW5nLnNpemUgPSBzaWJsaW5nU2l6ZSArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYW5lLmRyYWdTaXplID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaWJsaW5nLmRyYWdTaXplID0gbnVsbDtcblxuICAgICAgICBjb25zdCBhcmdzOiBJU3BsaXR0ZXJCYXJSZXNpemVFdmVudEFyZ3MgPSB7IHBhbmU6IHRoaXMucGFuZSwgc2libGluZzogdGhpcy5zaWJsaW5nIH07XG4gICAgICAgIHRoaXMucmVzaXplRW5kLmVtaXQoYXJncyk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldFBhbmVTaWJsaW5nc0J5T3JkZXIob3JkZXI6IG51bWJlciwgYmFySW5kZXg6IG51bWJlcik6IEFycmF5PElneFNwbGl0dGVyUGFuZUNvbXBvbmVudD4ge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMucGFuZXMudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBwcmV2UGFuZSA9IHBhbmVzW29yZGVyIC0gYmFySW5kZXggLSAxXTtcbiAgICAgICAgY29uc3QgbmV4dFBhbmUgPSBwYW5lc1tvcmRlciAtIGJhckluZGV4XTtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBbcHJldlBhbmUsIG5leHRQYW5lXTtcbiAgICAgICAgcmV0dXJuIHNpYmxpbmdzO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VG90YWxTaXplKCkge1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IHRoaXMuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpIDogY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0Jyk7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRvdGFsU2l6ZSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoaXMgbWV0aG9kIGluaXRzIHBhbmVzIHdpdGggcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRQYW5lcygpIHtcbiAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKHBhbmUgPT4ge1xuICAgICAgICAgICAgcGFuZS5vd25lciA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHBhbmUubWluV2lkdGggPSBwYW5lLm1pblNpemUgPz8gJzAnO1xuICAgICAgICAgICAgICAgIHBhbmUubWF4V2lkdGggPSBwYW5lLm1heFNpemUgPz8gJzEwMCUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYW5lLm1pbkhlaWdodCA9IHBhbmUubWluU2l6ZSA/PyAnMCc7XG4gICAgICAgICAgICAgICAgcGFuZS5tYXhIZWlnaHQgPSBwYW5lLm1heFNpemUgPz8gJzEwMCUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hc3NpZ25GbGV4T3JkZXIoKTtcbiAgICAgICAgaWYgKHRoaXMucGFuZXMuZmlsdGVyKHggPT4geC5jb2xsYXBzZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGlmIGFueSBwYW5lcyBhcmUgY29sbGFwc2VkLCByZXNldCBzaXplcy5cbiAgICAgICAgICAgIHRoaXMucmVzZXRQYW5lU2l6ZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhpcyBtZXRob2QgcmVzZXQgcGFuZSBzaXplcy5cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlc2V0UGFuZVNpemVzKCkge1xuICAgICAgICBpZiAodGhpcy5wYW5lcykge1xuICAgICAgICAgICAgLy8gaWYgdHlwZSBpcyBjaGFuZ2VkIHJ1bnRpbWUsIHNob3VsZCByZXNldCBzaXplcy5cbiAgICAgICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaCh4ID0+IHtcbiAgICAgICAgICAgICAgICB4LnNpemUgPSAnYXV0bydcbiAgICAgICAgICAgICAgICB4Lm1pbldpZHRoID0gJzAnO1xuICAgICAgICAgICAgICAgIHgubWF4V2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgeC5taW5IZWlnaHQgPSAnMCc7XG4gICAgICAgICAgICAgICAgeC5tYXhIZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhpcyBtZXRob2QgYXNzaWducyB0aGUgb3JkZXIgb2YgZWFjaCBwYW5lLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXNzaWduRmxleE9yZGVyKCkge1xuICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgIHRoaXMucGFuZXMuZm9yRWFjaCgocGFuZTogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICBwYW5lLm9yZGVyID0gaztcbiAgICAgICAgICAgIGsgKz0gMjtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBDYWxjdWxhdGVzIG5ldyBzaXplcyBmb3IgdGhlIHBhbmVzIGJhc2VkIG9uIG1vdmUgZGVsdGEgYW5kIGluaXRpYWwgc2l6ZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbGNOZXdTaXplcyhkZWx0YTogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IHBhcnNlSW50KHRoaXMucGFuZS5taW5TaXplLCAxMCkgfHwgMDtcbiAgICAgICAgY29uc3QgbWluU2libGluZyA9IHBhcnNlSW50KHRoaXMuc2libGluZy5taW5TaXplLCAxMCkgfHwgMDtcbiAgICAgICAgY29uc3QgbWF4ID0gcGFyc2VJbnQodGhpcy5wYW5lLm1heFNpemUsIDEwKSB8fCB0aGlzLmluaXRpYWxQYW5lU2l6ZSArIHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplIC0gbWluU2libGluZztcbiAgICAgICAgY29uc3QgbWF4U2libGluZyA9IHBhcnNlSW50KHRoaXMuc2libGluZy5tYXhTaXplLCAxMCkgfHwgdGhpcy5pbml0aWFsUGFuZVNpemUgKyB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZSAtIG1pbjtcblxuICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICBjb25zdCBtYXhQb3NzaWJsZURlbHRhID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgbWF4IC0gdGhpcy5pbml0aWFsUGFuZVNpemUsXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsU2libGluZ1NpemUgLSBtaW5TaWJsaW5nLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgZGVsdGEgPSBNYXRoLm1pbihtYXhQb3NzaWJsZURlbHRhLCBNYXRoLmFicyhkZWx0YSkpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXhQb3NzaWJsZURlbHRhID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsUGFuZVNpemUgLSBtaW4sXG4gICAgICAgICAgICAgICAgbWF4U2libGluZyAtIHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBkZWx0YSA9IE1hdGgubWluKG1heFBvc3NpYmxlRGVsdGEsIE1hdGguYWJzKGRlbHRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0aGlzLmluaXRpYWxQYW5lU2l6ZSAtIGRlbHRhLCB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZSArIGRlbHRhXTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBTUExJVFRFUl9JTlRFUkFDVElPTl9LRVlTID0gbmV3IFNldCgncmlnaHQgZG93biBsZWZ0IHVwIGFycm93cmlnaHQgYXJyb3dkb3duIGFycm93bGVmdCBhcnJvd3VwJy5zcGxpdCgnICcpKTtcblxuLyoqXG4gKiBAaGlkZGVuIEBpbnRlcm5hbFxuICogUmVwcmVzZW50cyB0aGUgZHJhZ2dhYmxlIGJhciB0aGF0IHZpc3VhbGx5IHNlcGFyYXRlcyBwYW5lcyBhbmQgYWxsb3dzIGZvciBjaGFuZ2luZyB0aGVpciBzaXplcy5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtc3BsaXR0ZXItYmFyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc3BsaXR0ZXItYmFyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtJZ3hEcmFnRGlyZWN0aXZlLCBJZ3hEcmFnSWdub3JlRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hTcGxpdEJhckNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogU2V0IGNzcyBjbGFzcyB0byB0aGUgaG9zdCBlbGVtZW50LlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXNwbGl0dGVyLWJhci1ob3N0JylcbiAgICBwdWJsaWMgY3NzQ2xhc3MgPSAnaWd4LXNwbGl0dGVyLWJhci1ob3N0JztcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgb3JpZW50YXRpb24uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdHlwZTogU3BsaXR0ZXJUeXBlID0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWw7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGVsZW1lbnQgb3JkZXIuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vcmRlcicpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgb3JkZXIhOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JylcbiAgICBwdWJsaWMgZ2V0IHRhYmluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemVEaXNhbGxvd2VkID8gbnVsbCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLW9yaWVudGF0aW9uJylcbiAgICBwdWJsaWMgZ2V0IG9yaWVudGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY3Vyc29yKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVEaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyAnY29sLXJlc2l6ZScgOiAncm93LXJlc2l6ZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgU3BsaXRQYW5lQ29tcG9uZW50YCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgYFNwbGl0QmFyQ29tcG9uZW50YC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBTcGxpdEJhckNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHBhbmUhOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL0dldHMgdGhlIGBTcGxpdFBhbmVDb21wb25lbnRgIHNpYmxpbmcgY29tcG9uZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgYFNwbGl0QmFyQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzaWJsaW5ncyE6IEFycmF5PElneFNwbGl0dGVyUGFuZUNvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbmV2ZXIgd2Ugc3RhcnQgZHJhZ2dpbmcgdGhlIGN1cnJlbnQgYFNwbGl0QmFyQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgbW92ZVN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcjxJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hpbGUgd2UgYXJlIGRyYWdnaW5nIHRoZSBjdXJyZW50IGBTcGxpdEJhckNvbXBvbmVudGAuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG1vdmluZyA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG1vdmluZ0VuZCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gICAgLyoqXG4gICAgICogQSB0ZW1wb3JhcnkgaG9sZGVyIGZvciB0aGUgcG9pbnRlciBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXJ0UG9pbnQhOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcHJldkJ1dHRvbkhpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2libGluZ3NbMF0uY29sbGFwc2VkICYmICF0aGlzLnNpYmxpbmdzWzFdLmNvbGxhcHNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICAgIHB1YmxpYyBrZXlFdmVudChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBjb25zdCBrZXkgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgY3RybCA9IGV2ZW50LmN0cmxLZXk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAoU1BMSVRURVJfSU5URVJBQ1RJT05fS0VZUy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnYXJyb3d1cCc6XG4gICAgICAgICAgICBjYXNlICd1cCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLlZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29sbGFwc2luZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVzaXplRGlzYWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0LmVtaXQodGhpcy5wYW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92aW5nLmVtaXQoMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXJyb3dkb3duJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5WZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3RybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbGxhcHNpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVzaXplRGlzYWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0LmVtaXQodGhpcy5wYW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92aW5nLmVtaXQoLTEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Fycm93bGVmdCc6XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3RybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbGxhcHNpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZURpc2FsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVTdGFydC5lbWl0KHRoaXMucGFuZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmluZy5lbWl0KDEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Fycm93cmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29sbGFwc2luZyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXNpemVEaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU3RhcnQuZW1pdCh0aGlzLnBhbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZpbmcuZW1pdCgtMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBkcmFnRGlyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IERyYWdEaXJlY3Rpb24uVkVSVElDQUwgOiBEcmFnRGlyZWN0aW9uLkhPUklaT05UQUw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG5leHRCdXR0b25IaWRkZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpYmxpbmdzWzFdLmNvbGxhcHNlZCAmJiAhdGhpcy5zaWJsaW5nc1swXS5jb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25EcmFnU3RhcnQoZXZlbnQ6IElEcmFnU3RhcnRFdmVudEFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplRGlzYWxsb3dlZCkge1xuICAgICAgICAgICAgZXZlbnQuY2FuY2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0UG9pbnQgPSB0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsID8gZXZlbnQuc3RhcnRYIDogZXZlbnQuc3RhcnRZO1xuICAgICAgICB0aGlzLm1vdmVTdGFydC5lbWl0KHRoaXMucGFuZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25EcmFnTW92ZShldmVudDogSURyYWdNb3ZlRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWw7XG4gICAgICAgIGNvbnN0IGN1cnIgPSBpc0hvcml6b250YWwgPyBldmVudC5wYWdlWCA6IGV2ZW50LnBhZ2VZO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuc3RhcnRQb2ludCAtIGN1cnI7XG4gICAgICAgIGlmIChkZWx0YSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZpbmcuZW1pdChkZWx0YSk7XG4gICAgICAgICAgICBldmVudC5jYW5jZWwgPSB0cnVlO1xuICAgICAgICAgICAgZXZlbnQub3duZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG9uRHJhZ0VuZChldmVudDogYW55KSB7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWw7XG4gICAgICAgIGNvbnN0IGN1cnIgPSBpc0hvcml6b250YWwgPyBldmVudC5wYWdlWCA6IGV2ZW50LnBhZ2VZO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuc3RhcnRQb2ludCAtIGN1cnI7XG4gICAgICAgIGlmIChkZWx0YSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZpbmdFbmQuZW1pdChkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IHJlc2l6ZURpc2FsbG93ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYWJzID0gdGhpcy5zaWJsaW5ncztcbiAgICAgICAgcmV0dXJuICEhcmVsYXRlZFRhYnMuZmluZCh4ID0+IHgucmVzaXphYmxlID09PSBmYWxzZSB8fCB4LmNvbGxhcHNlZCA9PT0gdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Db2xsYXBzaW5nKG5leHQ6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgcHJldlNpYmxpbmcgPSB0aGlzLnNpYmxpbmdzWzBdO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IHRoaXMuc2libGluZ3NbMV07XG4gICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAvLyBpZiBuZXh0IGlzIGNsaWNrZWQgd2hlbiBwcmV2IHBhbmUgaXMgaGlkZGVuLCBzaG93IHByZXYgcGFuZSwgZWxzZSBoaWRlIG5leHQgcGFuZS5cbiAgICAgICAgICAgIHRhcmdldCA9IHByZXZTaWJsaW5nLmNvbGxhcHNlZCA/IHByZXZTaWJsaW5nIDogbmV4dFNpYmxpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBwcmV2IGlzIGNsaWNrZWQgd2hlbiBuZXh0IHBhbmUgaXMgaGlkZGVuLCBzaG93IG5leHQgcGFuZSwgZWxzZSBoaWRlIHByZXYgcGFuZS5cbiAgICAgICAgICAgIHRhcmdldCA9IG5leHRTaWJsaW5nLmNvbGxhcHNlZCA/IG5leHRTaWJsaW5nIDogcHJldlNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnRvZ2dsZSgpO1xuICAgIH1cbn1cbiIsIjxuZy1jb250ZW50IHNlbGVjdD1cImlneC1zcGxpdHRlci1wYW5lXCI+PC9uZy1jb250ZW50PlxuPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgcGFuZSBvZiBwYW5lczsgbGV0IGxhc3QgPSBsYXN0OyBsZXQgaW5kZXg9IGluZGV4O1wiPlxuICAgIDxpZ3gtc3BsaXR0ZXItYmFyICpuZ0lmPVwiIWxhc3RcIiBbb3JkZXJdPSdwYW5lLm9yZGVyICsgMScgcm9sZT0nc2VwYXJhdG9yJ1xuICAgICAgICAgICAgICAgICAgICBbdHlwZV09XCJ0eXBlXCJcbiAgICAgICAgICAgICAgICAgICAgW3BhbmVdPVwicGFuZVwiXG4gICAgICAgICAgICAgICAgICAgIFtzaWJsaW5nc109J2dldFBhbmVTaWJsaW5nc0J5T3JkZXIocGFuZS5vcmRlciArIDEsIGluZGV4KSdcbiAgICAgICAgICAgICAgICAgICAgKG1vdmVTdGFydCk9XCJvbk1vdmVTdGFydCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgKG1vdmluZyk9XCJvbk1vdmluZygkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgKG1vdmluZ0VuZCk9J29uTW92ZUVuZCgkZXZlbnQpJz5cbiAgICA8L2lneC1zcGxpdHRlci1iYXI+XG48L25nLWNvbnRhaW5lcj5cbiIsIjxkaXYgY2xhc3M9XCJpZ3gtc3BsaXR0ZXItYmFyXCJcbiAgICBbY2xhc3MuaWd4LXNwbGl0dGVyLWJhci0tdmVydGljYWxdPSd0eXBlID09PSAwJ1xuICAgIFtzdHlsZS5jdXJzb3JdPSdjdXJzb3InXG4gICAgaWd4RHJhZ1xuICAgIFtnaG9zdF09XCJmYWxzZVwiXG4gICAgW2RyYWdEaXJlY3Rpb25dPSdkcmFnRGlyJ1xuICAgIChkcmFnU3RhcnQpPSdvbkRyYWdTdGFydCgkZXZlbnQpJ1xuICAgIChkcmFnTW92ZSk9XCJvbkRyYWdNb3ZlKCRldmVudClcIlxuICAgIChkcmFnRW5kKT1cIm9uRHJhZ0VuZCgkZXZlbnQpXCJcbj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LXNwbGl0dGVyLWJhcl9fZXhwYW5kZXItLXN0YXJ0XCIgaWd4RHJhZ0lnbm9yZSAoY2xpY2spPSdvbkNvbGxhcHNpbmcoZmFsc2UpJyBbaGlkZGVuXT0ncHJldkJ1dHRvbkhpZGRlbic+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImlneC1zcGxpdHRlci1iYXJfX2hhbmRsZVwiID48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LXNwbGl0dGVyLWJhcl9fZXhwYW5kZXItLWVuZFwiIGlneERyYWdJZ25vcmUgKGNsaWNrKT0nb25Db2xsYXBzaW5nKHRydWUpJyBbaGlkZGVuXT0nbmV4dEJ1dHRvbkhpZGRlbic+PC9kaXY+XG48L2Rpdj5cbiJdfQ==