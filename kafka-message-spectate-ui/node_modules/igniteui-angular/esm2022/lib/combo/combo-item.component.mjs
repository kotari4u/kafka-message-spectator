import { Component, HostBinding, Inject, Input } from '@angular/core';
import { IgxDropDownItemComponent } from '../drop-down/drop-down-item.component';
import { IGX_DROPDOWN_BASE, Navigate } from '../drop-down/drop-down.common';
import { IgxSelectionAPIService } from '../core/selection';
import { rem } from '../core/utils';
import { IgxCheckboxComponent } from '../checkbox/checkbox.component';
import { NgIf } from '@angular/common';
import * as i0 from "@angular/core";
import * as i1 from "./combo.api";
import * as i2 from "../core/selection";
/** @hidden */
export class IgxComboItemComponent extends IgxDropDownItemComponent {
    /** @hidden @internal */
    get _itemHeightToRem() {
        return rem(this.itemHeight);
    }
    get ariaLabel() {
        const valueKey = this.comboAPI.valueKey;
        return (valueKey !== null && this.value != null) ? this.value[valueKey] : this.value;
    }
    /**
     * @hidden
     */
    get itemID() {
        const valueKey = this.comboAPI.valueKey;
        return valueKey !== null ? this.value[valueKey] : this.value;
    }
    /**
     * @hidden
     */
    get comboID() {
        return this.comboAPI.comboID;
    }
    /**
     * @hidden
     * @internal
     */
    get disableTransitions() {
        return this.comboAPI.disableTransitions;
    }
    constructor(comboAPI, dropDown, elementRef, selection) {
        super(dropDown, elementRef, null, selection);
        this.comboAPI = comboAPI;
        /**
         * Gets the height of a list item
         *
         * @hidden
         */
        this.itemHeight = '';
    }
    /**
     * @hidden
     */
    get selected() {
        return this.comboAPI.is_item_selected(this.itemID);
    }
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
    }
    /**
     * @hidden
     */
    isVisible(direction) {
        const rect = this.element.nativeElement.getBoundingClientRect();
        const parentDiv = this.element.nativeElement.parentElement.parentElement.getBoundingClientRect();
        if (direction === Navigate.Down) {
            return rect.y + rect.height <= parentDiv.y + parentDiv.height;
        }
        return rect.y >= parentDiv.y;
    }
    clicked(event) {
        this.comboAPI.disableTransitions = false;
        if (!this.isSelectable) {
            return;
        }
        this.dropDown.navigateItem(this.index);
        this.comboAPI.set_selected_item(this.itemID, event);
    }
    /**
     * @hidden
     * @internal
     * The event that is prevented is the click on the checkbox label element.
     * That is the only visible element that a user can interact with.
     * The click propagates to the host and the preventDefault is to stop it from
     * switching focus to the input it's base on.
     * The toggle happens in an internal handler in the drop-down on the next task queue cycle.
     */
    disableCheck(event) {
        event.preventDefault();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxComboItemComponent, deps: [{ token: i1.IgxComboAPIService }, { token: IGX_DROPDOWN_BASE }, { token: i0.ElementRef }, { token: IgxSelectionAPIService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxComboItemComponent, isStandalone: true, selector: "igx-combo-item", inputs: { itemHeight: "itemHeight", ariaLabel: "ariaLabel", singleMode: "singleMode" }, host: { properties: { "style.height.rem": "this._itemHeightToRem", "attr.aria-label": "this.ariaLabel" } }, usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"!isHeader && !singleMode\">\n    <!-- checkbox should not allow changing its state from UI click (that's why it should be readonly=true), becasue when cancelling the selectionChange event in the combo, then checkbox will still change state.-->\n    <igx-checkbox [checked]=\"selected\" [readonly]=\"true\" [disableRipple]=\"true\" [disableTransitions]=\"disableTransitions\" [tabindex]=\"-1\" (click)=\"disableCheck($event)\" class=\"igx-combo__checkbox\"></igx-checkbox>\n</ng-container>\n<span class=\"igx-drop-down__inner\"><ng-content></ng-content></span>\n", dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IgxCheckboxComponent, selector: "igx-checkbox", inputs: ["id", "labelId", "value", "name", "tabindex", "labelPosition", "disableRipple", "required", "aria-labelledby", "aria-label", "indeterminate", "checked", "disabled", "invalid", "readonly", "disableTransitions"], outputs: ["change"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxComboItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-combo-item', standalone: true, imports: [NgIf, IgxCheckboxComponent], template: "<ng-container *ngIf=\"!isHeader && !singleMode\">\n    <!-- checkbox should not allow changing its state from UI click (that's why it should be readonly=true), becasue when cancelling the selectionChange event in the combo, then checkbox will still change state.-->\n    <igx-checkbox [checked]=\"selected\" [readonly]=\"true\" [disableRipple]=\"true\" [disableTransitions]=\"disableTransitions\" [tabindex]=\"-1\" (click)=\"disableCheck($event)\" class=\"igx-combo__checkbox\"></igx-checkbox>\n</ng-container>\n<span class=\"igx-drop-down__inner\"><ng-content></ng-content></span>\n" }]
        }], ctorParameters: function () { return [{ type: i1.IgxComboAPIService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_DROPDOWN_BASE]
                }] }, { type: i0.ElementRef }, { type: i2.IgxSelectionAPIService, decorators: [{
                    type: Inject,
                    args: [IgxSelectionAPIService]
                }] }]; }, propDecorators: { itemHeight: [{
                type: Input
            }], _itemHeightToRem: [{
                type: HostBinding,
                args: ['style.height.rem']
            }], ariaLabel: [{
                type: HostBinding,
                args: ['attr.aria-label']
            }, {
                type: Input
            }], singleMode: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tYm8taXRlbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvY29tYm8vY29tYm8taXRlbS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvY29tYm8vY29tYm8taXRlbS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0gsU0FBUyxFQUVULFdBQVcsRUFDWCxNQUFNLEVBQ04sS0FBSyxFQUNSLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBQ2pGLE9BQU8sRUFBRSxpQkFBaUIsRUFBaUIsUUFBUSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFM0YsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDM0QsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNwQyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUN0RSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7Ozs7QUFFdkMsY0FBYztBQU9kLE1BQU0sT0FBTyxxQkFBc0IsU0FBUSx3QkFBd0I7SUFVL0Qsd0JBQXdCO0lBQ3hCLElBQ1csZ0JBQWdCO1FBQ3ZCLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQsSUFFb0IsU0FBUztRQUN6QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUN4QyxPQUFPLENBQUMsUUFBUSxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMs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Q0E5QzNCLFVBQVU7c0JBRGhCLEtBQUs7Z0JBS0ssZ0JBQWdCO3NCQUQxQixXQUFXO3VCQUFDLGtCQUFrQjtnQkFPWCxTQUFTO3NCQUY1QixXQUFXO3VCQUFDLGlCQUFpQjs7c0JBQzdCLEtBQUs7Z0JBUUMsVUFBVTtzQkFEaEIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5qZWN0LFxuICAgIElucHV0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4RHJvcERvd25JdGVtQ29tcG9uZW50IH0gZnJvbSAnLi4vZHJvcC1kb3duL2Ryb3AtZG93bi1pdGVtLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJR1hfRFJPUERPV05fQkFTRSwgSURyb3BEb3duQmFzZSwgTmF2aWdhdGUgfSBmcm9tICcuLi9kcm9wLWRvd24vZHJvcC1kb3duLmNvbW1vbic7XG5pbXBvcnQgeyBJZ3hDb21ib0FQSVNlcnZpY2UgfSBmcm9tICcuL2NvbWJvLmFwaSc7XG5pbXBvcnQgeyBJZ3hTZWxlY3Rpb25BUElTZXJ2aWNlIH0gZnJvbSAnLi4vY29yZS9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgcmVtIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJZ3hDaGVja2JveENvbXBvbmVudCB9IGZyb20gJy4uL2NoZWNrYm94L2NoZWNrYm94LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOZ0lmIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqIEBoaWRkZW4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LWNvbWJvLWl0ZW0nLFxuICAgIHRlbXBsYXRlVXJsOiAnY29tYm8taXRlbS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbTmdJZiwgSWd4Q2hlY2tib3hDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIElneENvbWJvSXRlbUNvbXBvbmVudCBleHRlbmRzIElneERyb3BEb3duSXRlbUNvbXBvbmVudCB7XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoZWlnaHQgb2YgYSBsaXN0IGl0ZW1cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpdGVtSGVpZ2h0OiBzdHJpbmcgfCBudW1iZXIgPSAnJztcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuaGVpZ2h0LnJlbScpXG4gICAgcHVibGljIGdldCBfaXRlbUhlaWdodFRvUmVtKCkge1xuICAgICAgICByZXR1cm4gcmVtKHRoaXMuaXRlbUhlaWdodCk7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtbGFiZWwnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIG92ZXJyaWRlIGdldCBhcmlhTGFiZWwoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgdmFsdWVLZXkgPSB0aGlzLmNvbWJvQVBJLnZhbHVlS2V5O1xuICAgICAgICByZXR1cm4gKHZhbHVlS2V5ICE9PSBudWxsICYmIHRoaXMudmFsdWUgIT0gbnVsbCkgPyB0aGlzLnZhbHVlW3ZhbHVlS2V5XSA6IHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2luZ2xlTW9kZTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZ2V0IGl0ZW1JRCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVLZXkgPSB0aGlzLmNvbWJvQVBJLnZhbHVlS2V5O1xuICAgICAgICByZXR1cm4gdmFsdWVLZXkgIT09IG51bGwgPyB0aGlzLnZhbHVlW3ZhbHVlS2V5XSA6IHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29tYm9JRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tYm9BUEkuY29tYm9JRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBkaXNhYmxlVHJhbnNpdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbWJvQVBJLmRpc2FibGVUcmFuc2l0aW9ucztcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJvdGVjdGVkIGNvbWJvQVBJOiBJZ3hDb21ib0FQSVNlcnZpY2UsXG4gICAgICAgIEBJbmplY3QoSUdYX0RST1BET1dOX0JBU0UpIGRyb3BEb3duOiBJRHJvcERvd25CYXNlLFxuICAgICAgICBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBASW5qZWN0KElneFNlbGVjdGlvbkFQSVNlcnZpY2UpIHNlbGVjdGlvbjogSWd4U2VsZWN0aW9uQVBJU2VydmljZVxuICAgICkge1xuICAgICAgICBzdXBlcihkcm9wRG93biwgZWxlbWVudFJlZiwgbnVsbCwgc2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIGdldCBzZWxlY3RlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tYm9BUEkuaXNfaXRlbV9zZWxlY3RlZCh0aGlzLml0ZW1JRCk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIHNldCBzZWxlY3RlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5pc0hlYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBpc1Zpc2libGUoZGlyZWN0aW9uOiBOYXZpZ2F0ZSk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHBhcmVudERpdiA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gTmF2aWdhdGUuRG93bikge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QueSArIHJlY3QuaGVpZ2h0IDw9IHBhcmVudERpdi55ICsgcGFyZW50RGl2LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjdC55ID49IHBhcmVudERpdi55O1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBjbGlja2VkKGV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29tYm9BUEkuZGlzYWJsZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5pc1NlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyb3BEb3duLm5hdmlnYXRlSXRlbSh0aGlzLmluZGV4KTtcbiAgICAgICAgdGhpcy5jb21ib0FQSS5zZXRfc2VsZWN0ZWRfaXRlbSh0aGlzLml0ZW1JRCwgZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBUaGUgZXZlbnQgdGhhdCBpcyBwcmV2ZW50ZWQgaXMgdGhlIGNsaWNrIG9uIHRoZSBjaGVja2JveCBsYWJlbCBlbGVtZW50LlxuICAgICAqIFRoYXQgaXMgdGhlIG9ubHkgdmlzaWJsZSBlbGVtZW50IHRoYXQgYSB1c2VyIGNhbiBpbnRlcmFjdCB3aXRoLlxuICAgICAqIFRoZSBjbGljayBwcm9wYWdhdGVzIHRvIHRoZSBob3N0IGFuZCB0aGUgcHJldmVudERlZmF1bHQgaXMgdG8gc3RvcCBpdCBmcm9tXG4gICAgICogc3dpdGNoaW5nIGZvY3VzIHRvIHRoZSBpbnB1dCBpdCdzIGJhc2Ugb24uXG4gICAgICogVGhlIHRvZ2dsZSBoYXBwZW5zIGluIGFuIGludGVybmFsIGhhbmRsZXIgaW4gdGhlIGRyb3AtZG93biBvbiB0aGUgbmV4dCB0YXNrIHF1ZXVlIGN5Y2xlLlxuICAgICAqL1xuICAgIHB1YmxpYyBkaXNhYmxlQ2hlY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59XG4iLCI8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzSGVhZGVyICYmICFzaW5nbGVNb2RlXCI+XG4gICAgPCEtLSBjaGVja2JveCBzaG91bGQgbm90IGFsbG93IGNoYW5naW5nIGl0cyBzdGF0ZSBmcm9tIFVJIGNsaWNrICh0aGF0J3Mgd2h5IGl0IHNob3VsZCBiZSByZWFkb25seT10cnVlKSwgYmVjYXN1ZSB3aGVuIGNhbmNlbGxpbmcgdGhlIHNlbGVjdGlvbkNoYW5nZSBldmVudCBpbiB0aGUgY29tYm8sIHRoZW4gY2hlY2tib3ggd2lsbCBzdGlsbCBjaGFuZ2Ugc3RhdGUuLS0+XG4gICAgPGlneC1jaGVja2JveCBbY2hlY2tlZF09XCJzZWxlY3RlZFwiIFtyZWFkb25seV09XCJ0cnVlXCIgW2Rpc2FibGVSaXBwbGVdPVwidHJ1ZVwiIFtkaXNhYmxlVHJhbnNpdGlvbnNdPVwiZGlzYWJsZVRyYW5zaXRpb25zXCIgW3RhYmluZGV4XT1cIi0xXCIgKGNsaWNrKT1cImRpc2FibGVDaGVjaygkZXZlbnQpXCIgY2xhc3M9XCJpZ3gtY29tYm9fX2NoZWNrYm94XCI+PC9pZ3gtY2hlY2tib3g+XG48L25nLWNvbnRhaW5lcj5cbjxzcGFuIGNsYXNzPVwiaWd4LWRyb3AtZG93bl9faW5uZXJcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPlxuIl19