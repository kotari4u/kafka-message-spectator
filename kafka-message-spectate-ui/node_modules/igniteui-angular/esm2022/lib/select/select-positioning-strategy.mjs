import { __decorate, __param } from "tslib";
import { VerticalAlignment, HorizontalAlignment, Util } from '../services/overlay/utilities';
import { fadeOut, fadeIn } from '../animations/main';
import { BaseFitPositionStrategy } from '../services/overlay/position/base-fit-position-strategy';
import { Optional } from '@angular/core';
/** @hidden @internal */
let SelectPositioningStrategy = class SelectPositioningStrategy extends BaseFitPositionStrategy {
    constructor(select, settings, platform) {
        super();
        this.select = select;
        this.platform = platform;
        this._selectDefaultSettings = {
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Top,
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        // Global variables required for cases of !initialCall (page scroll/overlay repositionAll)
        this.global_yOffset = 0;
        this.global_xOffset = 0;
        this.global_styles = {};
        this.settings = Object.assign({}, this._selectDefaultSettings, settings);
    }
    /**
     * Position the element based on the PositionStrategy implementing this interface.
     *
     * @param contentElement The HTML element to be positioned
     * @param size Size of the element
     * @param document reference to the Document object
     * @param initialCall should be true if this is the initial call to the method
     * @param target attaching target for the component to show
     * ```typescript
     * settings.positionStrategy.position(content, size, document, true);
     * ```
     */
    position(contentElement, size, document, initialCall, target) {
        const targetElement = target || this.settings.target;
        const rects = super.calculateElementRectangles(contentElement, targetElement);
        // selectFit obj, to be used for both cases of initialCall and !initialCall(page scroll/overlay repositionAll)
        const selectFit = {
            verticalOffset: this.global_yOffset,
            horizontalOffset: this.global_xOffset,
            targetRect: rects.targetRect,
            contentElementRect: rects.elementRect,
            styles: this.global_styles,
            scrollContainer: this.select.scrollContainer,
            scrollContainerRect: this.select.scrollContainer.getBoundingClientRect()
        };
        if (initialCall) {
            this.select.scrollContainer.scrollTop = 0;
            // Fill in the required selectFit object properties.
            selectFit.viewPortRect = Util.getViewportRect(document);
            selectFit.itemElement = this.getInteractionItemElement();
            selectFit.itemRect = selectFit.itemElement.getBoundingClientRect();
            // Calculate input and selected item elements style related variables
            selectFit.styles = this.calculateStyles(selectFit, targetElement);
            selectFit.scrollAmount = this.calculateScrollAmount(selectFit);
            // Calculate how much to offset the overlay container.
            this.calculateYoffset(selectFit);
            this.calculateXoffset(selectFit);
            super.updateViewPortFit(selectFit);
            // container does not fit in viewPort and is out on Top or Bottom
            if (selectFit.fitVertical.back < 0 || selectFit.fitVertical.forward < 0) {
                this.fitInViewport(contentElement, selectFit);
            }
            // Calculate scrollTop independently of the dropdown, as we cover all `igsSelect` specific positioning and
            // scrolling to selected item scenarios here.
            this.select.scrollContainer.scrollTop = selectFit.scrollAmount;
        }
        this.setStyles(contentElement, selectFit);
    }
    /**
     * Obtain the selected item if there is such one or otherwise use the first one
     */
    getInteractionItemElement() {
        let itemElement;
        if (this.select.selectedItem) {
            itemElement = this.select.selectedItem.element.nativeElement;
        }
        else {
            itemElement = this.select.getFirstItemElement();
        }
        return itemElement;
    }
    /**
     * Position the items outer container so selected item text is positioned over input text and if header
     * And/OR footer - both header/footer are visible
     *
     * @param selectFit selectFit to use for computation.
     */
    fitInViewport(contentElement, selectFit) {
        const footer = selectFit.scrollContainerRect.bottom - selectFit.contentElementRect.bottom;
        const header = selectFit.scrollContainerRect.top - selectFit.contentElementRect.top;
        const lastItemFitSize = selectFit.targetRect.bottom + selectFit.styles.itemTextToInputTextDiff - footer;
        const firstItemFitSize = selectFit.targetRect.top - selectFit.styles.itemTextToInputTextDiff - header;
        // out of viewPort on Top
        if (selectFit.fitVertical.back < 0) {
            const possibleScrollAmount = selectFit.scrollContainer.scrollHeight -
                selectFit.scrollContainerRect.height - selectFit.scrollAmount;
            if (possibleScrollAmount + selectFit.fitVertical.back > 0 && firstItemFitSize > selectFit.viewPortRect.top) {
                selectFit.scrollAmount -= selectFit.fitVertical.back;
                selectFit.verticalOffset -= selectFit.fitVertical.back;
                this.global_yOffset = selectFit.verticalOffset;
            }
            else {
                selectFit.verticalOffset = 0;
                this.global_yOffset = 0;
            }
            // out of viewPort on Bottom
        }
        else if (selectFit.fitVertical.forward < 0) {
            if (selectFit.scrollAmount + selectFit.fitVertical.forward > 0 && lastItemFitSize < selectFit.viewPortRect.bottom) {
                selectFit.scrollAmount += selectFit.fitVertical.forward;
                selectFit.verticalOffset += selectFit.fitVertical.forward;
                this.global_yOffset = selectFit.verticalOffset;
            }
            else {
                selectFit.verticalOffset = -selectFit.contentElementRect.height + selectFit.targetRect.height;
                this.global_yOffset = selectFit.verticalOffset;
            }
        }
    }
    /**
     * Sets element's style which effectively positions the provided element
     *
     * @param element Element to position
     * @param selectFit selectFit to use for computation.
     * @param initialCall should be true if this is the initial call to the position method calling setStyles
     */
    setStyles(contentElement, selectFit) {
        super.setStyle(contentElement, selectFit.targetRect, selectFit.contentElementRect, selectFit);
        contentElement.style.width = `${selectFit.styles.contentElementNewWidth}px`; // manage container based on paddings?
        this.global_styles.contentElementNewWidth = selectFit.styles.contentElementNewWidth;
    }
    /**
     * Calculate selected item scroll position.
     */
    calculateScrollAmount(selectFit) {
        const itemElementRect = selectFit.itemRect;
        const scrollContainer = selectFit.scrollContainer;
        const scrollContainerRect = selectFit.scrollContainerRect;
        const scrollDelta = scrollContainerRect.top - itemElementRect.top;
        let scrollPosition = scrollContainer.scrollTop - scrollDelta;
        const dropDownHeight = scrollContainer.clientHeight;
        scrollPosition -= dropDownHeight / 2;
        scrollPosition += itemElementRect.height / 2;
        return Math.round(Math.min(Math.max(0, scrollPosition), scrollContainer.scrollHeight - scrollContainerRect.height));
    }
    /**
     * Calculate the necessary input and selected item styles to be used for positioning item text over input text.
     * Calculate & Set default items container width.
     *
     * @param selectFit selectFit to use for computation.
     */
    calculateStyles(selectFit, target) {
        const styles = {};
        const inputElementStyles = window.getComputedStyle(target);
        const itemElementStyles = window.getComputedStyle(selectFit.itemElement);
        const numericInputFontSize = parseFloat(inputElementStyles.fontSize);
        const numericInputPaddingTop = parseFloat(inputElementStyles.paddingTop);
        const numericInputPaddingBottom = parseFloat(inputElementStyles.paddingBottom);
        const numericItemFontSize = parseFloat(itemElementStyles.fontSize);
        const inputTextToInputTop = ((selectFit.targetRect.bottom - numericInputPaddingBottom)
            - (selectFit.targetRect.top + numericInputPaddingTop) - numericInputFontSize) / 2;
        const itemTextToItemTop = (selectFit.itemRect.height - numericItemFontSize) / 2;
        styles.itemTextToInputTextDiff = Math.round(itemTextToItemTop - inputTextToInputTop - numericInputPaddingTop);
        const numericLeftPadding = parseFloat(itemElementStyles.paddingLeft);
        const numericTextIndent = parseFloat(itemElementStyles.textIndent);
        styles.itemTextPadding = numericLeftPadding;
        styles.itemTextIndent = numericTextIndent;
        // 24 is the input's toggle ddl icon width
        styles.contentElementNewWidth = selectFit.targetRect.width + 24 + numericLeftPadding * 2;
        return styles;
    }
    /**
     * Calculate how much to offset the overlay container for Y-axis.
     */
    calculateYoffset(selectFit) {
        selectFit.verticalOffset = -(selectFit.itemRect.top - selectFit.contentElementRect.top +
            selectFit.styles.itemTextToInputTextDiff - selectFit.scrollAmount);
        this.global_yOffset = selectFit.verticalOffset;
    }
    /**
     * Calculate how much to offset the overlay container for X-axis.
     */
    calculateXoffset(selectFit) {
        selectFit.horizontalOffset = selectFit.styles.itemTextIndent - selectFit.styles.itemTextPadding;
        this.global_xOffset = selectFit.horizontalOffset;
    }
};
SelectPositioningStrategy = __decorate([
    __param(2, Optional())
], SelectPositioningStrategy);
export { SelectPositioningStrategy };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LXBvc2l0aW9uaW5nLXN0cmF0ZWd5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3NlbGVjdC9zZWxlY3QtcG9zaXRpb25pbmctc3RyYXRlZ3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxtQkFBbUIsRUFBMEIsSUFBSSxFQUF3QixNQUFNLCtCQUErQixDQUFDO0FBRTNJLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFckQsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0seURBQXlELENBQUM7QUFFbEcsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV6Qyx3QkFBd0I7QUFDakIsSUFBTSx5QkFBeUIsR0FBL0IsTUFBTSx5QkFBMEIsU0FBUSx1QkFBdUI7SUFlbEUsWUFBbUIsTUFBcUIsRUFBRSxRQUEyQixFQUF3QixRQUF1QjtRQUNoSCxLQUFLLEVBQUUsQ0FBQztRQURPLFdBQU0sR0FBTixNQUFNLENBQWU7UUFBcUQsYUFBUSxHQUFSLFFBQVEsQ0FBZTtRQWQ1RywyQkFBc0IsR0FBRztZQUM3QixtQkFBbUIsRUFBRSxtQkFBbUIsQ0FBQyxLQUFLO1lBQzlDLGlCQUFpQixFQUFFLGlCQUFpQixDQUFDLE1BQU07WUFDM0Msb0JBQW9CLEVBQUUsbUJBQW1CLENBQUMsSUFBSTtZQUM5QyxrQkFBa0IsRUFBRSxpQkFBaUIsQ0FBQyxHQUFHO1lBQ3pDLGFBQWEsRUFBRSxNQUFNO1lBQ3JCLGNBQWMsRUFBRSxPQUFPO1NBQzFCLENBQUM7UUFFRiwwRkFBMEY7UUFDbEYsbUJBQWMsR0FBRyxDQUFDLENBQUM7UUFDbkIsbUJBQWMsR0FBRyxDQUFDLENBQUM7UUFDbkIsa0JBQWEsR0FBaUIsRUFBRSxDQUFDO1FBSXJDLElBQUksQ0FBQyxRQUFR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QUFDO0lBRUQ7O09BRUc7SUFDSyxnQkFBZ0IsQ0FBQyxTQUFvQjtRQUN6QyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxjQUFjLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUM7UUFDaEcsSUFBSSxDQUFDLGNBQWMsR0FBRyxTQUFTLENBQUMsZ0JBQWdCLENBQUM7SUFDckQsQ0FBQztDQUNKLENBQUE7QUExTVkseUJBQXlCO0lBZXNDLFdBQUEsUUFBUSxFQUFFLENBQUE7R0FmekUseUJBQXlCLENBME1yQztTQTFNWSx5QkFBeUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZXJ0aWNhbEFsaWdubWVudCwgSG9yaXpvbnRhbEFsaWdubWVudCwgUG9zaXRpb25TZXR0aW5ncywgU2l6ZSwgVXRpbCwgQ29ubmVjdGVkRml0LCBQb2ludCAgfSBmcm9tICcuLi9zZXJ2aWNlcy9vdmVybGF5L3V0aWxpdGllcyc7XG5pbXBvcnQgeyBJUG9zaXRpb25TdHJhdGVneSB9IGZyb20gJy4uL3NlcnZpY2VzL292ZXJsYXkvcG9zaXRpb24nO1xuaW1wb3J0IHsgZmFkZU91dCwgZmFkZUluIH0gZnJvbSAnLi4vYW5pbWF0aW9ucy9tYWluJztcbmltcG9ydCB7IElneFNlbGVjdEJhc2UgfSBmcm9tICcuL3NlbGVjdC5jb21tb24nO1xuaW1wb3J0IHsgQmFzZUZpdFBvc2l0aW9uU3RyYXRlZ3kgfSBmcm9tICcuLi9zZXJ2aWNlcy9vdmVybGF5L3Bvc2l0aW9uL2Jhc2UtZml0LXBvc2l0aW9uLXN0cmF0ZWd5JztcbmltcG9ydCB7IFBsYXRmb3JtVXRpbCB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqIEBoaWRkZW4gQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgU2VsZWN0UG9zaXRpb25pbmdTdHJhdGVneSBleHRlbmRzIEJhc2VGaXRQb3NpdGlvblN0cmF0ZWd5IGltcGxlbWVudHMgSVBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIHByaXZhdGUgX3NlbGVjdERlZmF1bHRTZXR0aW5ncyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbERpcmVjdGlvbjogSG9yaXpvbnRhbEFsaWdubWVudC5SaWdodCxcbiAgICAgICAgdmVydGljYWxEaXJlY3Rpb246IFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbSxcbiAgICAgICAgaG9yaXpvbnRhbFN0YXJ0UG9pbnQ6IEhvcml6b250YWxBbGlnbm1lbnQuTGVmdCxcbiAgICAgICAgdmVydGljYWxTdGFydFBvaW50OiBWZXJ0aWNhbEFsaWdubWVudC5Ub3AsXG4gICAgICAgIG9wZW5BbmltYXRpb246IGZhZGVJbixcbiAgICAgICAgY2xvc2VBbmltYXRpb246IGZhZGVPdXRcbiAgICB9O1xuXG4gICAgLy8gR2xvYmFsIHZhcmlhYmxlcyByZXF1aXJlZCBmb3IgY2FzZXMgb2YgIWluaXRpYWxDYWxsIChwYWdlIHNjcm9sbC9vdmVybGF5IHJlcG9zaXRpb25BbGwpXG4gICAgcHJpdmF0ZSBnbG9iYWxfeU9mZnNldCA9IDA7XG4gICAgcHJpdmF0ZSBnbG9iYWxfeE9mZnNldCA9IDA7XG4gICAgcHJpdmF0ZSBnbG9iYWxfc3R5bGVzOiBTZWxlY3RTdHlsZXMgPSB7fTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBzZWxlY3Q6IElneFNlbGVjdEJhc2UsIHNldHRpbmdzPzogUG9zaXRpb25TZXR0aW5ncywgQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHBsYXRmb3JtPzogUGxhdGZvcm1VdGlsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9zZWxlY3REZWZhdWx0U2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB0aGUgZWxlbWVudCBiYXNlZCBvbiB0aGUgUG9zaXRpb25TdHJhdGVneSBpbXBsZW1lbnRpbmcgdGhpcyBpbnRlcmZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udGVudEVsZW1lbnQgVGhlIEhUTUwgZWxlbWVudCB0byBiZSBwb3NpdGlvbmVkXG4gICAgICogQHBhcmFtIHNpemUgU2l6ZSBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSBkb2N1bWVudCByZWZlcmVuY2UgdG8gdGhlIERvY3VtZW50IG9iamVjdFxuICAgICAqIEBwYXJhbSBpbml0aWFsQ2FsbCBzaG91bGQgYmUgdHJ1ZSBpZiB0aGlzIGlzIHRoZSBpbml0aWFsIGNhbGwgdG8gdGhlIG1ldGhvZFxuICAgICAqIEBwYXJhbSB0YXJnZXQgYXR0YWNoaW5nIHRhcmdldCBmb3IgdGhlIGNvbXBvbmVudCB0byBzaG93XG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHNldHRpbmdzLnBvc2l0aW9uU3RyYXRlZ3kucG9zaXRpb24oY29udGVudCwgc2l6ZSwgZG9jdW1lbnQsIHRydWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBwb3NpdGlvbihjb250ZW50RWxlbWVudDogSFRNTEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IFNpemUsXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50PzogRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxDYWxsPzogYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PzogUG9pbnQgfCBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gdGFyZ2V0IHx8IHRoaXMuc2V0dGluZ3MudGFyZ2V0O1xuICAgICAgICBjb25zdCByZWN0cyA9IHN1cGVyLmNhbGN1bGF0ZUVsZW1lbnRSZWN0YW5nbGVzKGNvbnRlbnRFbGVtZW50LCB0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgLy8gc2VsZWN0Rml0IG9iaiwgdG8gYmUgdXNlZCBmb3IgYm90aCBjYXNlcyBvZiBpbml0aWFsQ2FsbCBhbmQgIWluaXRpYWxDYWxsKHBhZ2Ugc2Nyb2xsL292ZXJsYXkgcmVwb3NpdGlvbkFsbClcbiAgICAgICAgY29uc3Qgc2VsZWN0Rml0OiBTZWxlY3RGaXQgPSB7XG4gICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldDogdGhpcy5nbG9iYWxfeU9mZnNldCxcbiAgICAgICAgICAgIGhvcml6b250YWxPZmZzZXQ6IHRoaXMuZ2xvYmFsX3hPZmZzZXQsXG4gICAgICAgICAgICB0YXJnZXRSZWN0OiByZWN0cy50YXJnZXRSZWN0LFxuICAgICAgICAgICAgY29udGVudEVsZW1lbnRSZWN0OiByZWN0cy5lbGVtZW50UmVjdCxcbiAgICAgICAgICAgIHN0eWxlczogdGhpcy5nbG9iYWxfc3R5bGVzLFxuICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyOiB0aGlzLnNlbGVjdC5zY3JvbGxDb250YWluZXIsXG4gICAgICAgICAgICBzY3JvbGxDb250YWluZXJSZWN0OiB0aGlzLnNlbGVjdC5zY3JvbGxDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaW5pdGlhbENhbGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0LnNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgLy8gRmlsbCBpbiB0aGUgcmVxdWlyZWQgc2VsZWN0Rml0IG9iamVjdCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgc2VsZWN0Rml0LnZpZXdQb3J0UmVjdCA9IFV0aWwuZ2V0Vmlld3BvcnRSZWN0KGRvY3VtZW50KTtcbiAgICAgICAgICAgIHNlbGVjdEZpdC5pdGVtRWxlbWVudCA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25JdGVtRWxlbWVudCgpO1xuICAgICAgICAgICAgc2VsZWN0Rml0Lml0ZW1SZWN0ID0gc2VsZWN0Rml0Lml0ZW1FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgaW5wdXQgYW5kIHNlbGVjdGVkIGl0ZW0gZWxlbWVudHMgc3R5bGUgcmVsYXRlZCB2YXJpYWJsZXNcbiAgICAgICAgICAgIHNlbGVjdEZpdC5zdHlsZXMgPSB0aGlzLmNhbGN1bGF0ZVN0eWxlcyhzZWxlY3RGaXQsIHRhcmdldEVsZW1lbnQpO1xuXG4gICAgICAgICAgICBzZWxlY3RGaXQuc2Nyb2xsQW1vdW50ID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxBbW91bnQoc2VsZWN0Rml0KTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBob3cgbXVjaCB0byBvZmZzZXQgdGhlIG92ZXJsYXkgY29udGFpbmVyLlxuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVZb2Zmc2V0KHNlbGVjdEZpdCk7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVhvZmZzZXQoc2VsZWN0Rml0KTtcblxuICAgICAgICAgICAgc3VwZXIudXBkYXRlVmlld1BvcnRGaXQoc2VsZWN0Rml0KTtcbiAgICAgICAgICAgIC8vIGNvbnRhaW5lciBkb2VzIG5vdCBmaXQgaW4gdmlld1BvcnQgYW5kIGlzIG91dCBvbiBUb3Agb3IgQm90dG9tXG4gICAgICAgICAgICBpZiAoc2VsZWN0Rml0LmZpdFZlcnRpY2FsLmJhY2sgPCAwIHx8IHNlbGVjdEZpdC5maXRWZXJ0aWNhbC5mb3J3YXJkIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZml0SW5WaWV3cG9ydChjb250ZW50RWxlbWVudCwgc2VsZWN0Rml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzY3JvbGxUb3AgaW5kZXBlbmRlbnRseSBvZiB0aGUgZHJvcGRvd24sIGFzIHdlIGNvdmVyIGFsbCBgaWdzU2VsZWN0YCBzcGVjaWZpYyBwb3NpdGlvbmluZyBhbmRcbiAgICAgICAgICAgIC8vIHNjcm9sbGluZyB0byBzZWxlY3RlZCBpdGVtIHNjZW5hcmlvcyBoZXJlLlxuICAgICAgICAgICAgdGhpcy5zZWxlY3Quc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCA9IHNlbGVjdEZpdC5zY3JvbGxBbW91bnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdHlsZXMoY29udGVudEVsZW1lbnQsIHNlbGVjdEZpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2J0YWluIHRoZSBzZWxlY3RlZCBpdGVtIGlmIHRoZXJlIGlzIHN1Y2ggb25lIG9yIG90aGVyd2lzZSB1c2UgdGhlIGZpcnN0IG9uZVxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRJbnRlcmFjdGlvbkl0ZW1FbGVtZW50KCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgbGV0IGl0ZW1FbGVtZW50O1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Quc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgICBpdGVtRWxlbWVudCA9IHRoaXMuc2VsZWN0LnNlbGVjdGVkSXRlbS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtRWxlbWVudCA9IHRoaXMuc2VsZWN0LmdldEZpcnN0SXRlbUVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gdGhlIGl0ZW1zIG91dGVyIGNvbnRhaW5lciBzbyBzZWxlY3RlZCBpdGVtIHRleHQgaXMgcG9zaXRpb25lZCBvdmVyIGlucHV0IHRleHQgYW5kIGlmIGhlYWRlclxuICAgICAqIEFuZC9PUiBmb290ZXIgLSBib3RoIGhlYWRlci9mb290ZXIgYXJlIHZpc2libGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3RGaXQgc2VsZWN0Rml0IHRvIHVzZSBmb3IgY29tcHV0YXRpb24uXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGZpdEluVmlld3BvcnQoY29udGVudEVsZW1lbnQ6IEhUTUxFbGVtZW50LCBzZWxlY3RGaXQ6IFNlbGVjdEZpdCkge1xuICAgICAgICBjb25zdCBmb290ZXIgPSBzZWxlY3RGaXQuc2Nyb2xsQ29udGFpbmVyUmVjdC5ib3R0b20gLSBzZWxlY3RGaXQuY29udGVudEVsZW1lbnRSZWN0LmJvdHRvbTtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gc2VsZWN0Rml0LnNjcm9sbENvbnRhaW5lclJlY3QudG9wIC0gc2VsZWN0Rml0LmNvbnRlbnRFbGVtZW50UmVjdC50b3A7XG4gICAgICAgIGNvbnN0IGxhc3RJdGVtRml0U2l6ZSA9IHNlbGVjdEZpdC50YXJnZXRSZWN0LmJvdHRvbSArIHNlbGVjdEZpdC5zdHlsZXMuaXRlbVRleHRUb0lucHV0VGV4dERpZmYgLSBmb290ZXI7XG4gICAgICAgIGNvbnN0IGZpcnN0SXRlbUZpdFNpemUgPSBzZWxlY3RGaXQudGFyZ2V0UmVjdC50b3AgLSBzZWxlY3RGaXQuc3R5bGVzLml0ZW1UZXh0VG9JbnB1dFRleHREaWZmIC0gaGVhZGVyO1xuICAgICAgICAvLyBvdXQgb2Ygdmlld1BvcnQgb24gVG9wXG4gICAgICAgIGlmIChzZWxlY3RGaXQuZml0VmVydGljYWwuYmFjayA8IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlU2Nyb2xsQW1vdW50ID0gc2VsZWN0Rml0LnNjcm9sbENvbnRhaW5lci5zY3JvbGxIZWlnaHQgLVxuICAgICAgICAgICAgICAgIHNlbGVjdEZpdC5zY3JvbGxDb250YWluZXJSZWN0LmhlaWdodCAtIHNlbGVjdEZpdC5zY3JvbGxBbW91bnQ7XG4gICAgICAgICAgICBpZiAocG9zc2libGVTY3JvbGxBbW91bnQgKyBzZWxlY3RGaXQuZml0VmVydGljYWwuYmFjayA+IDAgJiYgZmlyc3RJdGVtRml0U2l6ZSA+IHNlbGVjdEZpdC52aWV3UG9ydFJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0Rml0LnNjcm9sbEFtb3VudCAtPSBzZWxlY3RGaXQuZml0VmVydGljYWwuYmFjaztcbiAgICAgICAgICAgICAgICBzZWxlY3RGaXQudmVydGljYWxPZmZzZXQgLT0gc2VsZWN0Rml0LmZpdFZlcnRpY2FsLmJhY2s7XG4gICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxfeU9mZnNldCA9IHNlbGVjdEZpdC52ZXJ0aWNhbE9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0Rml0LnZlcnRpY2FsT2Zmc2V0ID0gMCA7XG4gICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxfeU9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIG91dCBvZiB2aWV3UG9ydCBvbiBCb3R0b21cbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RGaXQuZml0VmVydGljYWwuZm9yd2FyZCA8IDApIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RGaXQuc2Nyb2xsQW1vdW50ICsgc2VsZWN0Rml0LmZpdFZlcnRpY2FsLmZvcndhcmQgPiAwICYmIGxhc3RJdGVtRml0U2l6ZSA8IHNlbGVjdEZpdC52aWV3UG9ydFJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0Rml0LnNjcm9sbEFtb3VudCArPSBzZWxlY3RGaXQuZml0VmVydGljYWwuZm9yd2FyZDtcbiAgICAgICAgICAgICAgICBzZWxlY3RGaXQudmVydGljYWxPZmZzZXQgKz0gc2VsZWN0Rml0LmZpdFZlcnRpY2FsLmZvcndhcmQ7XG4gICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxfeU9mZnNldCA9IHNlbGVjdEZpdC52ZXJ0aWNhbE9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0Rml0LnZlcnRpY2FsT2Zmc2V0ID0gLXNlbGVjdEZpdC5jb250ZW50RWxlbWVudFJlY3QuaGVpZ2h0ICsgc2VsZWN0Rml0LnRhcmdldFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsX3lPZmZzZXQgPSBzZWxlY3RGaXQudmVydGljYWxPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGVsZW1lbnQncyBzdHlsZSB3aGljaCBlZmZlY3RpdmVseSBwb3NpdGlvbnMgdGhlIHByb3ZpZGVkIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IEVsZW1lbnQgdG8gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gc2VsZWN0Rml0IHNlbGVjdEZpdCB0byB1c2UgZm9yIGNvbXB1dGF0aW9uLlxuICAgICAqIEBwYXJhbSBpbml0aWFsQ2FsbCBzaG91bGQgYmUgdHJ1ZSBpZiB0aGlzIGlzIHRoZSBpbml0aWFsIGNhbGwgdG8gdGhlIHBvc2l0aW9uIG1ldGhvZCBjYWxsaW5nIHNldFN0eWxlc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBzZXRTdHlsZXMoY29udGVudEVsZW1lbnQ6IEhUTUxFbGVtZW50LCBzZWxlY3RGaXQ6IFNlbGVjdEZpdCkge1xuICAgICAgICBzdXBlci5zZXRTdHlsZShjb250ZW50RWxlbWVudCwgc2VsZWN0Rml0LnRhcmdldFJlY3QsIHNlbGVjdEZpdC5jb250ZW50RWxlbWVudFJlY3QsIHNlbGVjdEZpdCk7XG4gICAgICAgIGNvbnRlbnRFbGVtZW50LnN0eWxlLndpZHRoID0gYCR7c2VsZWN0Rml0LnN0eWxlcy5jb250ZW50RWxlbWVudE5ld1dpZHRofXB4YDsgLy8gbWFuYWdlIGNvbnRhaW5lciBiYXNlZCBvbiBwYWRkaW5ncz9cbiAgICAgICAgdGhpcy5nbG9iYWxfc3R5bGVzLmNvbnRlbnRFbGVtZW50TmV3V2lkdGggPSBzZWxlY3RGaXQuc3R5bGVzLmNvbnRlbnRFbGVtZW50TmV3V2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHNlbGVjdGVkIGl0ZW0gc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHByaXZhdGUgY2FsY3VsYXRlU2Nyb2xsQW1vdW50KHNlbGVjdEZpdDogU2VsZWN0Rml0KTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgaXRlbUVsZW1lbnRSZWN0ID0gc2VsZWN0Rml0Lml0ZW1SZWN0O1xuICAgICAgICBjb25zdCBzY3JvbGxDb250YWluZXIgPSBzZWxlY3RGaXQuc2Nyb2xsQ29udGFpbmVyO1xuICAgICAgICBjb25zdCBzY3JvbGxDb250YWluZXJSZWN0ID0gc2VsZWN0Rml0LnNjcm9sbENvbnRhaW5lclJlY3Q7XG4gICAgICAgIGNvbnN0IHNjcm9sbERlbHRhID0gc2Nyb2xsQ29udGFpbmVyUmVjdC50b3AgLSBpdGVtRWxlbWVudFJlY3QudG9wO1xuICAgICAgICBsZXQgc2Nyb2xsUG9zaXRpb24gPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wIC0gc2Nyb2xsRGVsdGE7XG5cbiAgICAgICAgY29uc3QgZHJvcERvd25IZWlnaHQgPSBzY3JvbGxDb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgICBzY3JvbGxQb3NpdGlvbiAtPSBkcm9wRG93bkhlaWdodCAvIDI7XG4gICAgICAgIHNjcm9sbFBvc2l0aW9uICs9IGl0ZW1FbGVtZW50UmVjdC5oZWlnaHQgLyAyO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgubWluKE1hdGgubWF4KDAsIHNjcm9sbFBvc2l0aW9uKSwgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEhlaWdodCAtIHNjcm9sbENvbnRhaW5lclJlY3QuaGVpZ2h0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBuZWNlc3NhcnkgaW5wdXQgYW5kIHNlbGVjdGVkIGl0ZW0gc3R5bGVzIHRvIGJlIHVzZWQgZm9yIHBvc2l0aW9uaW5nIGl0ZW0gdGV4dCBvdmVyIGlucHV0IHRleHQuXG4gICAgICogQ2FsY3VsYXRlICYgU2V0IGRlZmF1bHQgaXRlbXMgY29udGFpbmVyIHdpZHRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlbGVjdEZpdCBzZWxlY3RGaXQgdG8gdXNlIGZvciBjb21wdXRhdGlvbi5cbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbGN1bGF0ZVN0eWxlcyhzZWxlY3RGaXQ6IFNlbGVjdEZpdCwgdGFyZ2V0OiBQb2ludCB8IEhUTUxFbGVtZW50KTogU2VsZWN0U3R5bGVzICB7XG4gICAgICAgIGNvbnN0IHN0eWxlczogU2VsZWN0U3R5bGVzID0ge307XG4gICAgICAgIGNvbnN0IGlucHV0RWxlbWVudFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCBhcyBFbGVtZW50KTtcbiAgICAgICAgY29uc3QgaXRlbUVsZW1lbnRTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzZWxlY3RGaXQuaXRlbUVsZW1lbnQpO1xuICAgICAgICBjb25zdCBudW1lcmljSW5wdXRGb250U2l6ZSA9IHBhcnNlRmxvYXQoaW5wdXRFbGVtZW50U3R5bGVzLmZvbnRTaXplKTtcbiAgICAgICAgY29uc3QgbnVtZXJpY0lucHV0UGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoaW5wdXRFbGVtZW50U3R5bGVzLnBhZGRpbmdUb3ApO1xuICAgICAgICBjb25zdCBudW1lcmljSW5wdXRQYWRkaW5nQm90dG9tID0gcGFyc2VGbG9hdChpbnB1dEVsZW1lbnRTdHlsZXMucGFkZGluZ0JvdHRvbSk7XG4gICAgICAgIGNvbnN0IG51bWVyaWNJdGVtRm9udFNpemUgPSBwYXJzZUZsb2F0KGl0ZW1FbGVtZW50U3R5bGVzLmZvbnRTaXplKTtcbiAgICAgICAgY29uc3QgaW5wdXRUZXh0VG9JbnB1dFRvcCA9ICgoc2VsZWN0Rml0LnRhcmdldFJlY3QuYm90dG9tIC0gbnVtZXJpY0lucHV0UGFkZGluZ0JvdHRvbSlcbiAgICAgICAgICAgIC0gKHNlbGVjdEZpdC50YXJnZXRSZWN0LnRvcCArIG51bWVyaWNJbnB1dFBhZGRpbmdUb3ApIC0gbnVtZXJpY0lucHV0Rm9udFNpemUpIC8gMjtcbiAgICAgICAgY29uc3QgaXRlbVRleHRUb0l0ZW1Ub3AgPSAoc2VsZWN0Rml0Lml0ZW1SZWN0LmhlaWdodCAtIG51bWVyaWNJdGVtRm9udFNpemUpIC8gMjtcbiAgICAgICAgc3R5bGVzLml0ZW1UZXh0VG9JbnB1dFRleHREaWZmID0gTWF0aC5yb3VuZChpdGVtVGV4dFRvSXRlbVRvcCAtIGlucHV0VGV4dFRvSW5wdXRUb3AgLSBudW1lcmljSW5wdXRQYWRkaW5nVG9wKTtcblxuICAgICAgICBjb25zdCBudW1lcmljTGVmdFBhZGRpbmcgPSBwYXJzZUZsb2F0KGl0ZW1FbGVtZW50U3R5bGVzLnBhZGRpbmdMZWZ0KTtcbiAgICAgICAgY29uc3QgbnVtZXJpY1RleHRJbmRlbnQgPSBwYXJzZUZsb2F0KGl0ZW1FbGVtZW50U3R5bGVzLnRleHRJbmRlbnQpO1xuXG4gICAgICAgIHN0eWxlcy5pdGVtVGV4dFBhZGRpbmcgPSBudW1lcmljTGVmdFBhZGRpbmc7XG4gICAgICAgIHN0eWxlcy5pdGVtVGV4dEluZGVudCA9IG51bWVyaWNUZXh0SW5kZW50O1xuICAgICAgICAvLyAyNCBpcyB0aGUgaW5wdXQncyB0b2dnbGUgZGRsIGljb24gd2lkdGhcbiAgICAgICAgc3R5bGVzLmNvbnRlbnRFbGVtZW50TmV3V2lkdGggPSBzZWxlY3RGaXQudGFyZ2V0UmVjdC53aWR0aCArIDI0ICsgbnVtZXJpY0xlZnRQYWRkaW5nICogMjtcblxuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBob3cgbXVjaCB0byBvZmZzZXQgdGhlIG92ZXJsYXkgY29udGFpbmVyIGZvciBZLWF4aXMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVZb2Zmc2V0KHNlbGVjdEZpdDogU2VsZWN0Rml0KSB7XG4gICAgICAgIHNlbGVjdEZpdC52ZXJ0aWNhbE9mZnNldCA9IC0oc2VsZWN0Rml0Lml0ZW1SZWN0LnRvcCAtIHNlbGVjdEZpdC5jb250ZW50RWxlbWVudFJlY3QudG9wICtcbiAgICAgICAgICAgIHNlbGVjdEZpdC5zdHlsZXMuaXRlbVRleHRUb0lucHV0VGV4dERpZmYgLSBzZWxlY3RGaXQuc2Nyb2xsQW1vdW50KTtcbiAgICAgICAgdGhpcy5nbG9iYWxfeU9mZnNldCA9IHNlbGVjdEZpdC52ZXJ0aWNhbE9mZnNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgaG93IG11Y2ggdG8gb2Zmc2V0IHRoZSBvdmVybGF5IGNvbnRhaW5lciBmb3IgWC1heGlzLlxuICAgICAqL1xuICAgIHByaXZhdGUgY2FsY3VsYXRlWG9mZnNldChzZWxlY3RGaXQ6IFNlbGVjdEZpdCkge1xuICAgICAgICBzZWxlY3RGaXQuaG9yaXpvbnRhbE9mZnNldCA9IHNlbGVjdEZpdC5zdHlsZXMuaXRlbVRleHRJbmRlbnQgLSBzZWxlY3RGaXQuc3R5bGVzLml0ZW1UZXh0UGFkZGluZztcbiAgICAgICAgdGhpcy5nbG9iYWxfeE9mZnNldCA9IHNlbGVjdEZpdC5ob3Jpem9udGFsT2Zmc2V0O1xuICAgIH1cbn1cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0Rml0IGV4dGVuZHMgQ29ubmVjdGVkRml0IHtcbiAgICBpdGVtRWxlbWVudD86IEhUTUxFbGVtZW50O1xuICAgIHNjcm9sbENvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gICAgc2Nyb2xsQ29udGFpbmVyUmVjdDogQ2xpZW50UmVjdDtcbiAgICBpdGVtUmVjdD86IENsaWVudFJlY3Q7XG4gICAgc3R5bGVzPzogU2VsZWN0U3R5bGVzO1xuICAgIHNjcm9sbEFtb3VudD86IG51bWJlcjtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0U3R5bGVzIHtcbiAgICBpdGVtVGV4dFBhZGRpbmc/OiBudW1iZXI7XG4gICAgaXRlbVRleHRJbmRlbnQ/OiBudW1iZXI7XG4gICAgaXRlbVRleHRUb0lucHV0VGV4dERpZmY/OiBudW1iZXI7XG4gICAgY29udGVudEVsZW1lbnROZXdXaWR0aD86IG51bWJlcjtcbiAgICBudW1lcmljTGVmdFBhZGRpbmc/OiBudW1iZXI7XG59XG4iXX0=