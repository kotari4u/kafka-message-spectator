import { Component, HostBinding, Inject, Input, ViewChild } from '@angular/core';
import { getResizeObserver, mkenum } from '../../core/utils';
import { IgxAngularAnimationService } from '../../services/animation/angular-animation-service';
import { IgxTabsBase } from '../tabs.base';
import { IgxTabsDirective } from '../tabs.directive';
import { NgClass, NgFor, NgTemplateOutlet, NgIf } from '@angular/common';
import { IgxIconComponent } from '../../icon/icon.component';
import { IgxRippleDirective } from '../../directives/ripple/ripple.directive';
import * as i0 from "@angular/core";
import * as i1 from "../../services/direction/directionality";
export const IgxTabsAlignment = mkenum({
    start: 'start',
    end: 'end',
    center: 'center',
    justify: 'justify'
});
/** @hidden */
var TabScrollButtonStyle;
(function (TabScrollButtonStyle) {
    TabScrollButtonStyle["Enabled"] = "enabled";
    TabScrollButtonStyle["Disabled"] = "disabled";
    TabScrollButtonStyle["NotDisplayed"] = "not_displayed";
})(TabScrollButtonStyle || (TabScrollButtonStyle = {}));
/** @hidden */
let NEXT_TAB_ID = 0;
/**
 * Tabs component is used to organize or switch between similar data sets.
 *
 * @igxModule IgxTabsModule
 *
 * @igxTheme igx-tabs-theme
 *
 * @igxKeywords tabs
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI for Angular Tabs component places tabs at the top and allows for scrolling when there are multiple tab items on the screen.
 *
 * @example
 * ```html
 * <igx-tabs>
 *     <igx-tab-item>
 *         <igx-tab-header>
 *             <igx-icon igxTabHeaderIcon>folder</igx-icon>
 *             <span igxTabHeaderLabel>Tab 1</span>
 *         </igx-tab-header>
 *         <igx-tab-content>
 *             Content 1
 *         </igx-tab-content>
 *     </igx-tab-item>
 *     ...
 * </igx-tabs>
 * ```
 */
export class IgxTabsComponent extends IgxTabsDirective {
    /**
     * An @Input property which determines the tab alignment. Defaults to `start`.
     */
    get tabAlignment() {
        return this._tabAlignment;
    }
    set tabAlignment(value) {
        this._tabAlignment = value;
        requestAnimationFrame(() => {
            this.updateScrollButtons();
            this.realignSelectedIndicator();
        });
    }
    constructor(animationService, cdr, ngZone, dir) {
        super(animationService, cdr, dir);
        this.ngZone = ngZone;
        /** @hidden */
        this.defaultClass = true;
        /**  @hidden */
        this.offset = 0;
        /** @hidden */
        this.componentName = 'igx-tabs';
        this._tabAlignment = 'start';
    }
    /** @hidden @internal */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.ngZone.runOutsideAngular(() => {
            this._resizeObserver = new (getResizeObserver())(() => {
                this.updateScrollButtons();
                this.realignSelectedIndicator();
            });
            this._resizeObserver.observe(this.headerContainer.nativeElement);
            this._resizeObserver.observe(this.viewPort.nativeElement);
        });
    }
    /** @hidden @internal */
    ngOnDestroy() {
        super.ngOnDestroy();
        this.ngZone.runOutsideAngular(() => {
            this._resizeObserver?.disconnect();
        });
    }
    /** @hidden */
    scrollPrev() {
        this.scroll(false);
    }
    /** @hidden */
    scrollNext() {
        this.scroll(true);
    }
    /** @hidden */
    realignSelectedIndicator() {
        if (this.selectedIndex >= 0 && this.selectedIndex < this.items.length) {
            const header = this.items.get(this.selectedIndex).headerComponent.nativeElement;
            this.alignSelectedIndicator(header, 0);
        }
    }
    /** @hidden */
    resolveHeaderScrollClasses() {
        return {
            'igx-tabs__header-scroll--start': this.tabAlignment === 'start',
            'igx-tabs__header-scroll--end': this.tabAlignment === 'end',
            'igx-tabs__header-scroll--center': this.tabAlignment === 'center',
            'igx-tabs__header-scroll--justify': this.tabAlignment === 'justify',
        };
    }
    /** @hidden */
    scrollTabHeaderIntoView() {
        if (this.selectedIndex >= 0) {
            const tabItems = this.items.toArray();
            const tabHeaderNativeElement = tabItems[this.selectedIndex].headerComponent.nativeElement;
            // Scroll left if there is need
            if (this.getElementOffset(tabHeaderNativeElement) < this.offset) {
                this.scrollElement(tabHeaderNativeElement, false);
            }
            // Scroll right if there is need
            const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
            const delta = (this.getElementOffset(tabHeaderNativeElement) + tabHeaderNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
            // Fix for IE 11, a difference is accumulated from the widths calculations
            if (delta > 1) {
                this.scrollElement(tabHeaderNativeElement, true);
            }
            this.alignSelectedIndicator(tabHeaderNativeElement);
        }
        else {
            this.hideSelectedIndicator();
        }
    }
    /** @hidden */
    getNextTabId() {
        return NEXT_TAB_ID++;
    }
    /** @hidden */
    onItemChanges() {
        super.onItemChanges();
        Promise.resolve().then(() => {
            this.updateScrollButtons();
        });
    }
    alignSelectedIndicator(element, duration = 0.3) {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
            this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;
            this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;
        }
    }
    hideSelectedIndicator() {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    }
    scroll(scrollNext) {
        const tabsArray = this.items.toArray();
        for (let index = 0; index < tabsArray.length; index++) {
            const tab = tabsArray[index];
            const element = tab.headerComponent.nativeElement;
            if (scrollNext) {
                if (element.offsetWidth + this.getElementOffset(element) > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollNext);
                    break;
                }
            }
            else {
                if (this.getElementOffset(element) >= this.offset) {
                    this.scrollElement(tabsArray[index - 1].headerComponent.nativeElement, scrollNext);
                    break;
                }
            }
        }
    }
    scrollElement(element, scrollNext) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollNext) ? element.offsetWidth + this.getElementOffset(element) - viewPortWidth : this.getElementOffset(element);
        this.viewPort.nativeElement.scrollLeft = this.getOffset(this.offset);
        this.updateScrollButtons();
    }
    updateScrollButtons() {
        const itemsContainerWidth = this.getTabItemsContainerWidth();
        const scrollPrevButtonStyle = this.resolveLeftScrollButtonStyle(itemsContainerWidth);
        this.setScrollButtonStyle(this.scrollPrevButton.nativeElement, scrollPrevButtonStyle);
        const scrollNextButtonStyle = this.resolveRightScrollButtonStyle(itemsContainerWidth);
        this.setScrollButtonStyle(this.scrollNextButton.nativeElement, scrollNextButtonStyle);
    }
    setScrollButtonStyle(button, buttonStyle) {
        if (buttonStyle === TabScrollButtonStyle.Enabled) {
            button.disabled = false;
            button.style.display = '';
        }
        else if (buttonStyle === TabScrollButtonStyle.Disabled) {
            button.disabled = true;
            button.style.display = '';
        }
        else if (buttonStyle === TabScrollButtonStyle.NotDisplayed) {
            button.style.display = 'none';
        }
    }
    resolveLeftScrollButtonStyle(itemsContainerWidth) {
        const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;
        const offset = this.offset;
        if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
                return TabScrollButtonStyle.NotDisplayed;
            }
            return TabScrollButtonStyle.Disabled;
        }
        else {
            return TabScrollButtonStyle.Enabled;
        }
    }
    resolveRightScrollButtonStyle(itemsContainerWidth) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;
        const offset = this.offset;
        const total = offset + viewPortWidth;
        // Fix for IE 11, a difference is accumulated from the widths calculations.
        if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return TabScrollButtonStyle.NotDisplayed;
        }
        if (itemsContainerWidth > total) {
            return TabScrollButtonStyle.Enabled;
        }
        else {
            return TabScrollButtonStyle.Disabled;
        }
    }
    getTabItemsContainerWidth() {
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 1];
            itemsContainerWidth = this.getElementOffset(lastTab) + lastTab.offsetWidth;
        }
        return itemsContainerWidth;
    }
    getOffset(offset) {
        return this.dir.rtl ? -offset : offset;
    }
    getElementOffset(element) {
        return this.dir.rtl ? this.itemsWrapper.nativeElement.offsetWidth - element.offsetLeft - element.offsetWidth : element.offsetLeft;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxTabsComponent, deps: [{ token: IgxAngularAnimationService }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i1.IgxDirectionality }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxTabsComponent, isStandalone: true, selector: "igx-tabs", inputs: { tabAlignment: "tabAlignment" }, host: { properties: { "class.igx-tabs": "this.defaultClass" } }, providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }], viewQueries: [{ propertyName: "headerContainer", first: true, predicate: ["headerContainer"], descendants: true, static: true }, { propertyName: "viewPort", first: true, predicate: ["viewPort"], descendants: true, static: true }, { propertyName: "itemsWrapper", first: true, predicate: ["itemsWrapper"], descendants: true, static: true }, { propertyName: "itemsContainer", first: true, predicate: ["itemsContainer"], descendants: true, static: true }, { propertyName: "selectedIndicator", first: true, predicate: ["selectedIndicator"], descendants: true }, { propertyName: "scrollPrevButton", first: true, predicate: ["scrollPrevButton"], descendants: true }, { propertyName: "scrollNextButton", first: true, predicate: ["scrollNextButton"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<div #headerContainer class=\"igx-tabs__header\">\n    <button #scrollPrevButton igxButton=\"icon\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollPrev()\">\n        <igx-icon>navigate_before</igx-icon>\n    </button>\n    <div #viewPort class=\"igx-tabs__header-content\">\n        <div #itemsWrapper class=\"igx-tabs__header-wrapper\" role=\"tablist\">\n            <div #itemsContainer class=\"igx-tabs__header-scroll\" [ngClass]=\"resolveHeaderScrollClasses()\">\n                <ng-container *ngFor=\"let tab of items; let i = index\">\n                    <ng-container *ngTemplateOutlet=\"tab.headerTemplate\"></ng-container>\n                </ng-container>\n            </div>\n            <div #selectedIndicator *ngIf=\"items.length > 0\" class=\"igx-tabs__header-active-indicator\">\n            </div>\n        </div>\n    </div>\n    <button #scrollNextButton igxButton=\"icon\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollNext()\">\n        <igx-icon>navigate_next</igx-icon>\n    </button>\n</div>\n<div class=\"igx-tabs__panels\">\n    <ng-container *ngFor=\"let tab of items; let i = index\">\n        <ng-container *ngTemplateOutlet=\"tab.panelTemplate\"></ng-container>\n    </ng-container>\n</div>", dependencies: [{ kind: "directive", type: IgxRippleDirective, selector: "[igxRipple]", inputs: ["igxRippleTarget", "igxRipple", "igxRippleDuration", "igxRippleCentered", "igxRippleDisabled"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxTabsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tabs', providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }], standalone: true, imports: [IgxRippleDirective, IgxIconComponent, NgClass, NgFor, NgTemplateOutlet, NgIf], template: "<div #headerContainer class=\"igx-tabs__header\">\n    <button #scrollPrevButton igxButton=\"icon\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollPrev()\">\n        <igx-icon>navigate_before</igx-icon>\n    </button>\n    <div #viewPort class=\"igx-tabs__header-content\">\n        <div #itemsWrapper class=\"igx-tabs__header-wrapper\" role=\"tablist\">\n            <div #itemsContainer class=\"igx-tabs__header-scroll\" [ngClass]=\"resolveHeaderScrollClasses()\">\n                <ng-container *ngFor=\"let tab of items; let i = index\">\n                    <ng-container *ngTemplateOutlet=\"tab.headerTemplate\"></ng-container>\n                </ng-container>\n            </div>\n            <div #selectedIndicator *ngIf=\"items.length > 0\" class=\"igx-tabs__header-active-indicator\">\n            </div>\n        </div>\n    </div>\n    <button #scrollNextButton igxButton=\"icon\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollNext()\">\n        <igx-icon>navigate_next</igx-icon>\n    </button>\n</div>\n<div class=\"igx-tabs__panels\">\n    <ng-container *ngFor=\"let tab of items; let i = index\">\n        <ng-container *ngTemplateOutlet=\"tab.panelTemplate\"></ng-container>\n    </ng-container>\n</div>" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IgxAngularAnimationService]
                }] }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.IgxDirectionality }]; }, propDecorators: { tabAlignment: [{
                type: Input
            }], headerContainer: [{
                type: ViewChild,
                args: ['headerContainer', { static: true }]
            }], viewPort: [{
                type: ViewChild,
                args: ['viewPort', { static: true }]
            }], itemsWrapper: [{
                type: ViewChild,
                args: ['itemsWrapper', { static: true }]
            }], itemsContainer: [{
                type: ViewChild,
                args: ['itemsContainer', { static: true }]
            }], selectedIndicator: [{
                type: ViewChild,
                args: ['selectedIndicator']
            }], scrollPrevButton: [{
                type: ViewChild,
                args: ['scrollPrevButton']
            }], scrollNextButton: [{
                type: ViewChild,
                args: ['scrollNextButton']
            }], defaultClass: [{
                type: HostBinding,
                args: ['class.igx-tabs']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvdGFicy90YWJzL3RhYnMuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3RhYnMvdGFicy90YWJzLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBb0MsU0FBUyxFQUFjLFdBQVcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFxQixTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEosT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzdELE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLG9EQUFvRCxDQUFDO0FBR2hHLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDM0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDckQsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDN0QsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sMENBQTBDLENBQUM7OztBQUU5RSxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLENBQUM7SUFDbkMsS0FBSyxFQUFFLE9BQU87SUFDZCxHQUFHLEVBQUUsS0FBSztJQUNWLE1BQU0sRUFBRSxRQUFRO0lBQ2hCLE9BQU8sRUFBRSxTQUFTO0NBQ3JCLENBQUMsQ0FBQztBQUVILGNBQWM7QUFDZCxJQUFLLG9CQUlKO0FBSkQsV0FBSyxvQkFBb0I7SUFDckIsMkNBQW1CLENBQUE7SUFDbkIs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QyxrQkFBa0IsRUFBRSxnQkFBZ0IsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFLElBQUksQ0FBQzs7MEJBK0RsRixNQUFNOzJCQUFDLDBCQUEwQjtpSUF0RDNCLFlBQVk7c0JBRHRCLEtBQUs7Z0JBZUMsZUFBZTtzQkFEckIsU0FBUzt1QkFBQyxpQkFBaUIsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBS3ZDLFFBQVE7c0JBRGQsU0FBUzt1QkFBQyxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUtoQyxZQUFZO3NCQURsQixTQUFTO3VCQUFDLGNBQWMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBS3BDLGNBQWM7c0JBRHBCLFNBQVM7dUJBQUMsZ0JBQWdCLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUt0QyxpQkFBaUI7c0JBRHZCLFNBQVM7dUJBQUMsbUJBQW1CO2dCQUt2QixnQkFBZ0I7c0JBRHRCLFNBQVM7dUJBQUMsa0JBQWtCO2dCQUt0QixnQkFBZ0I7c0JBRHRCLFNBQVM7dUJBQUMsa0JBQWtCO2dCQUt0QixZQUFZO3NCQURsQixXQUFXO3VCQUFDLGdCQUFnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RCaW5kaW5nLCBJbmplY3QsIElucHV0LCBOZ1pvbmUsIE9uRGVzdHJveSwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBnZXRSZXNpemVPYnNlcnZlciwgbWtlbnVtIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJZ3hBbmd1bGFyQW5pbWF0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2FuaW1hdGlvbi9hbmd1bGFyLWFuaW1hdGlvbi1zZXJ2aWNlJztcbmltcG9ydCB7IEFuaW1hdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9hbmltYXRpb24vYW5pbWF0aW9uJztcbmltcG9ydCB7IElneERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZGlyZWN0aW9uL2RpcmVjdGlvbmFsaXR5JztcbmltcG9ydCB7IElneFRhYnNCYXNlIH0gZnJvbSAnLi4vdGFicy5iYXNlJztcbmltcG9ydCB7IElneFRhYnNEaXJlY3RpdmUgfSBmcm9tICcuLi90YWJzLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOZ0NsYXNzLCBOZ0ZvciwgTmdUZW1wbGF0ZU91dGxldCwgTmdJZiB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJZ3hJY29uQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hSaXBwbGVEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3JpcHBsZS9yaXBwbGUuZGlyZWN0aXZlJztcblxuZXhwb3J0IGNvbnN0IElneFRhYnNBbGlnbm1lbnQgPSBta2VudW0oe1xuICAgIHN0YXJ0OiAnc3RhcnQnLFxuICAgIGVuZDogJ2VuZCcsXG4gICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICBqdXN0aWZ5OiAnanVzdGlmeSdcbn0pO1xuXG4vKiogQGhpZGRlbiAqL1xuZW51bSBUYWJTY3JvbGxCdXR0b25TdHlsZSB7XG4gICAgRW5hYmxlZCA9ICdlbmFibGVkJyxcbiAgICBEaXNhYmxlZCA9ICdkaXNhYmxlZCcsXG4gICAgTm90RGlzcGxheWVkID0gJ25vdF9kaXNwbGF5ZWQnXG59XG5cbmV4cG9ydCB0eXBlIElneFRhYnNBbGlnbm1lbnQgPSAodHlwZW9mIElneFRhYnNBbGlnbm1lbnQpW2tleW9mIHR5cGVvZiBJZ3hUYWJzQWxpZ25tZW50XTtcblxuLyoqIEBoaWRkZW4gKi9cbmxldCBORVhUX1RBQl9JRCA9IDA7XG5cbi8qKlxuICogVGFicyBjb21wb25lbnQgaXMgdXNlZCB0byBvcmdhbml6ZSBvciBzd2l0Y2ggYmV0d2VlbiBzaW1pbGFyIGRhdGEgc2V0cy5cbiAqXG4gKiBAaWd4TW9kdWxlIElneFRhYnNNb2R1bGVcbiAqXG4gKiBAaWd4VGhlbWUgaWd4LXRhYnMtdGhlbWVcbiAqXG4gKiBAaWd4S2V5d29yZHMgdGFic1xuICpcbiAqIEBpZ3hHcm91cCBMYXlvdXRzXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgVGFicyBjb21wb25lbnQgcGxhY2VzIHRhYnMgYXQgdGhlIHRvcCBhbmQgYWxsb3dzIGZvciBzY3JvbGxpbmcgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgdGFiIGl0ZW1zIG9uIHRoZSBzY3JlZW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtdGFicz5cbiAqICAgICA8aWd4LXRhYi1pdGVtPlxuICogICAgICAgICA8aWd4LXRhYi1oZWFkZXI+XG4gKiAgICAgICAgICAgICA8aWd4LWljb24gaWd4VGFiSGVhZGVySWNvbj5mb2xkZXI8L2lneC1pY29uPlxuICogICAgICAgICAgICAgPHNwYW4gaWd4VGFiSGVhZGVyTGFiZWw+VGFiIDE8L3NwYW4+XG4gKiAgICAgICAgIDwvaWd4LXRhYi1oZWFkZXI+XG4gKiAgICAgICAgIDxpZ3gtdGFiLWNvbnRlbnQ+XG4gKiAgICAgICAgICAgICBDb250ZW50IDFcbiAqICAgICAgICAgPC9pZ3gtdGFiLWNvbnRlbnQ+XG4gKiAgICAgPC9pZ3gtdGFiLWl0ZW0+XG4gKiAgICAgLi4uXG4gKiA8L2lneC10YWJzPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXRhYnMnLFxuICAgIHRlbXBsYXRlVXJsOiAndGFicy5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBJZ3hUYWJzQmFzZSwgdXNlRXhpc3Rpbmc6IElneFRhYnNDb21wb25lbnQgfV0sXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbSWd4UmlwcGxlRGlyZWN0aXZlLCBJZ3hJY29uQ29tcG9uZW50LCBOZ0NsYXNzLCBOZ0ZvciwgTmdUZW1wbGF0ZU91dGxldCwgTmdJZl1cbn0pXG5cbmV4cG9ydCBjbGFzcyBJZ3hUYWJzQ29tcG9uZW50IGV4dGVuZHMgSWd4VGFic0RpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgdGFiIGFsaWdubWVudC4gRGVmYXVsdHMgdG8gYHN0YXJ0YC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgdGFiQWxpZ25tZW50KCk6IHN0cmluZyB8IElneFRhYnNBbGlnbm1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFiQWxpZ25tZW50O1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgdGFiQWxpZ25tZW50KHZhbHVlOiBzdHJpbmcgfCBJZ3hUYWJzQWxpZ25tZW50KSB7XG4gICAgICAgIHRoaXMuX3RhYkFsaWdubWVudCA9IHZhbHVlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxCdXR0b25zKCk7XG4gICAgICAgICAgICB0aGlzLnJlYWxpZ25TZWxlY3RlZEluZGljYXRvcigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ2hlYWRlckNvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGhlYWRlckNvbnRhaW5lcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ3ZpZXdQb3J0JywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgdmlld1BvcnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKCdpdGVtc1dyYXBwZXInLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyBpdGVtc1dyYXBwZXI6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKCdpdGVtc0NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGl0ZW1zQ29udGFpbmVyOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQFZpZXdDaGlsZCgnc2VsZWN0ZWRJbmRpY2F0b3InKVxuICAgIHB1YmxpYyBzZWxlY3RlZEluZGljYXRvcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ3Njcm9sbFByZXZCdXR0b24nKVxuICAgIHB1YmxpYyBzY3JvbGxQcmV2QnV0dG9uOiBFbGVtZW50UmVmPEhUTUxCdXR0b25FbGVtZW50PjtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQFZpZXdDaGlsZCgnc2Nyb2xsTmV4dEJ1dHRvbicpXG4gICAgcHVibGljIHNjcm9sbE5leHRCdXR0b246IEVsZW1lbnRSZWY8SFRNTEJ1dHRvbkVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10YWJzJylcbiAgICBwdWJsaWMgZGVmYXVsdENsYXNzID0gdHJ1ZTtcblxuICAgIC8qKiAgQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBvZmZzZXQgPSAwO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgY29tcG9uZW50TmFtZSA9ICdpZ3gtdGFicyc7XG5cbiAgICBwcml2YXRlIF90YWJBbGlnbm1lbnQ6IHN0cmluZyB8IElneFRhYnNBbGlnbm1lbnQgPSAnc3RhcnQnO1xuICAgIHByaXZhdGUgX3Jlc2l6ZU9ic2VydmVyOiBSZXNpemVPYnNlcnZlcjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KElneEFuZ3VsYXJBbmltYXRpb25TZXJ2aWNlKSBhbmltYXRpb25TZXJ2aWNlOiBBbmltYXRpb25TZXJ2aWNlLFxuICAgICAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcml2YXRlIG5nWm9uZTogTmdab25lLFxuICAgICAgICBkaXI6IElneERpcmVjdGlvbmFsaXR5KSB7XG4gICAgICAgIHN1cGVyKGFuaW1hdGlvblNlcnZpY2UsIGNkciwgZGlyKTtcbiAgICB9XG5cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm5nQWZ0ZXJWaWV3SW5pdCgpO1xuXG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IChnZXRSZXNpemVPYnNlcnZlcigpKSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxCdXR0b25zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsaWduU2VsZWN0ZWRJbmRpY2F0b3IoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmhlYWRlckNvbnRhaW5lci5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG92ZXJyaWRlIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuXG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIHNjcm9sbFByZXYoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBzY3JvbGxOZXh0KCkge1xuICAgICAgICB0aGlzLnNjcm9sbCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyByZWFsaWduU2VsZWN0ZWRJbmRpY2F0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPj0gMCAmJiB0aGlzLnNlbGVjdGVkSW5kZXggPCB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gdGhpcy5pdGVtcy5nZXQodGhpcy5zZWxlY3RlZEluZGV4KS5oZWFkZXJDb21wb25lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYWxpZ25TZWxlY3RlZEluZGljYXRvcihoZWFkZXIsIDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgcmVzb2x2ZUhlYWRlclNjcm9sbENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWd4LXRhYnNfX2hlYWRlci1zY3JvbGwtLXN0YXJ0JzogdGhpcy50YWJBbGlnbm1lbnQgPT09ICdzdGFydCcsXG4gICAgICAgICAgICAnaWd4LXRhYnNfX2hlYWRlci1zY3JvbGwtLWVuZCc6IHRoaXMudGFiQWxpZ25tZW50ID09PSAnZW5kJyxcbiAgICAgICAgICAgICdpZ3gtdGFic19faGVhZGVyLXNjcm9sbC0tY2VudGVyJzogdGhpcy50YWJBbGlnbm1lbnQgPT09ICdjZW50ZXInLFxuICAgICAgICAgICAgJ2lneC10YWJzX19oZWFkZXItc2Nyb2xsLS1qdXN0aWZ5JzogdGhpcy50YWJBbGlnbm1lbnQgPT09ICdqdXN0aWZ5JyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByb3RlY3RlZCBvdmVycmlkZSBzY3JvbGxUYWJIZWFkZXJJbnRvVmlldygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJJdGVtcyA9IHRoaXMuaXRlbXMudG9BcnJheSgpO1xuICAgICAgICAgICAgY29uc3QgdGFiSGVhZGVyTmF0aXZlRWxlbWVudCA9IHRhYkl0ZW1zW3RoaXMuc2VsZWN0ZWRJbmRleF0uaGVhZGVyQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIFNjcm9sbCBsZWZ0IGlmIHRoZXJlIGlzIG5lZWRcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEVsZW1lbnRPZmZzZXQodGFiSGVhZGVyTmF0aXZlRWxlbWVudCkgPCB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCh0YWJIZWFkZXJOYXRpdmVFbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNjcm9sbCByaWdodCBpZiB0aGVyZSBpcyBuZWVkXG4gICAgICAgICAgICBjb25zdCB2aWV3UG9ydE9mZnNldFdpZHRoID0gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSAodGhpcy5nZXRFbGVtZW50T2Zmc2V0KHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQpICsgdGFiSGVhZGVyTmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCkgLSAodmlld1BvcnRPZmZzZXRXaWR0aCArIHRoaXMub2Zmc2V0KTtcblxuICAgICAgICAgICAgLy8gRml4IGZvciBJRSAxMSwgYSBkaWZmZXJlbmNlIGlzIGFjY3VtdWxhdGVkIGZyb20gdGhlIHdpZHRocyBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQodGFiSGVhZGVyTmF0aXZlRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWxpZ25TZWxlY3RlZEluZGljYXRvcih0YWJIZWFkZXJOYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZVNlbGVjdGVkSW5kaWNhdG9yKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByb3RlY3RlZCBnZXROZXh0VGFiSWQoKSB7XG4gICAgICAgIHJldHVybiBORVhUX1RBQl9JRCsrO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIG9uSXRlbUNoYW5nZXMoKSB7XG4gICAgICAgIHN1cGVyLm9uSXRlbUNoYW5nZXMoKTtcblxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsQnV0dG9ucygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFsaWduU2VsZWN0ZWRJbmRpY2F0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQsIGR1cmF0aW9uID0gMC4zKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kaWNhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiA+IDAgPyBgJHtkdXJhdGlvbn1zYCA6ICdpbml0aWFsJztcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS53aWR0aCA9IGAke2VsZW1lbnQub2Zmc2V0V2lkdGh9cHhgO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtlbGVtZW50Lm9mZnNldExlZnR9cHgpYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaGlkZVNlbGVjdGVkSW5kaWNhdG9yKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGljYXRvcikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2Nyb2xsKHNjcm9sbE5leHQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGFic0FycmF5ID0gdGhpcy5pdGVtcy50b0FycmF5KCk7XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRhYnNBcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhYiA9IHRhYnNBcnJheVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGFiLmhlYWRlckNvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHNjcm9sbE5leHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRXaWR0aCArIHRoaXMuZ2V0RWxlbWVudE9mZnNldChlbGVtZW50KSA+IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCArIHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudChlbGVtZW50LCBzY3JvbGxOZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpID49IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCh0YWJzQXJyYXlbaW5kZXggLSAxXS5oZWFkZXJDb21wb25lbnQubmF0aXZlRWxlbWVudCwgc2Nyb2xsTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2Nyb2xsRWxlbWVudChlbGVtZW50OiBhbnksIHNjcm9sbE5leHQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgdmlld1BvcnRXaWR0aCA9IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICB0aGlzLm9mZnNldCA9IChzY3JvbGxOZXh0KSA/IGVsZW1lbnQub2Zmc2V0V2lkdGggKyB0aGlzLmdldEVsZW1lbnRPZmZzZXQoZWxlbWVudCkgLSB2aWV3UG9ydFdpZHRoIDogdGhpcy5nZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpO1xuICAgICAgICB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsTGVmdCA9IHRoaXMuZ2V0T2Zmc2V0KHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxCdXR0b25zKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVTY3JvbGxCdXR0b25zKCkge1xuICAgICAgICBjb25zdCBpdGVtc0NvbnRhaW5lcldpZHRoID0gdGhpcy5nZXRUYWJJdGVtc0NvbnRhaW5lcldpZHRoKCk7XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsUHJldkJ1dHRvblN0eWxlID0gdGhpcy5yZXNvbHZlTGVmdFNjcm9sbEJ1dHRvblN0eWxlKGl0ZW1zQ29udGFpbmVyV2lkdGgpO1xuICAgICAgICB0aGlzLnNldFNjcm9sbEJ1dHRvblN0eWxlKHRoaXMuc2Nyb2xsUHJldkJ1dHRvbi5uYXRpdmVFbGVtZW50LCBzY3JvbGxQcmV2QnV0dG9uU3R5bGUpO1xuXG4gICAgICAgIGNvbnN0IHNjcm9sbE5leHRCdXR0b25TdHlsZSA9IHRoaXMucmVzb2x2ZVJpZ2h0U2Nyb2xsQnV0dG9uU3R5bGUoaXRlbXNDb250YWluZXJXaWR0aCk7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsQnV0dG9uU3R5bGUodGhpcy5zY3JvbGxOZXh0QnV0dG9uLm5hdGl2ZUVsZW1lbnQsIHNjcm9sbE5leHRCdXR0b25TdHlsZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRTY3JvbGxCdXR0b25TdHlsZShidXR0b246IEhUTUxCdXR0b25FbGVtZW50LCBidXR0b25TdHlsZTogVGFiU2Nyb2xsQnV0dG9uU3R5bGUpIHtcbiAgICAgICAgaWYgKGJ1dHRvblN0eWxlID09PSBUYWJTY3JvbGxCdXR0b25TdHlsZS5FbmFibGVkKSB7XG4gICAgICAgICAgICBidXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoYnV0dG9uU3R5bGUgPT09IFRhYlNjcm9sbEJ1dHRvblN0eWxlLkRpc2FibGVkKSB7XG4gICAgICAgICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmIChidXR0b25TdHlsZSA9PT0gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuTm90RGlzcGxheWVkKSB7XG4gICAgICAgICAgICBidXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIHJlc29sdmVMZWZ0U2Nyb2xsQnV0dG9uU3R5bGUoaXRlbXNDb250YWluZXJXaWR0aDogbnVtYmVyKTogVGFiU2Nyb2xsQnV0dG9uU3R5bGUge1xuICAgICAgICBjb25zdCBoZWFkZXJDb250YWluZXJXaWR0aCA9IHRoaXMuaGVhZGVyQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuXG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEZpeCBmb3IgSUUgMTEsIGEgZGlmZmVyZW5jZSBpcyBhY2N1bXVsYXRlZCBmcm9tIHRoZSB3aWR0aHMgY2FsY3VsYXRpb25zLlxuICAgICAgICAgICAgaWYgKGl0ZW1zQ29udGFpbmVyV2lkdGggLSBoZWFkZXJDb250YWluZXJXaWR0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLk5vdERpc3BsYXllZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5EaXNhYmxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5FbmFibGVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXNvbHZlUmlnaHRTY3JvbGxCdXR0b25TdHlsZShpdGVtc0NvbnRhaW5lcldpZHRoOiBudW1iZXIpOiBUYWJTY3JvbGxCdXR0b25TdHlsZSB7XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0V2lkdGggPSB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIGNvbnN0IGhlYWRlckNvbnRhaW5lcldpZHRoID0gdGhpcy5oZWFkZXJDb250YWluZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gb2Zmc2V0ICsgdmlld1BvcnRXaWR0aDtcblxuICAgICAgICAvLyBGaXggZm9yIElFIDExLCBhIGRpZmZlcmVuY2UgaXMgYWNjdW11bGF0ZWQgZnJvbSB0aGUgd2lkdGhzIGNhbGN1bGF0aW9ucy5cbiAgICAgICAgaWYgKGl0ZW1zQ29udGFpbmVyV2lkdGggLSBoZWFkZXJDb250YWluZXJXaWR0aCA8PSAxICYmIG9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLk5vdERpc3BsYXllZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtc0NvbnRhaW5lcldpZHRoID4gdG90YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5FbmFibGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLkRpc2FibGVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUYWJJdGVtc0NvbnRhaW5lcldpZHRoKCkge1xuICAgICAgICAvLyBXZSB1c2UgdGhpcyBoYWNreSB3YXkgdG8gZ2V0IHRoZSB3aWR0aCBvZiB0aGUgaXRlbXNDb250YWluZXIsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgaW5jb25zaXN0ZW5jeSBpbiBJRSB3ZSBjYW5ub3QgdXNlIG9mZnNldFdpZHRoIG9yIHNjcm9sbE9mZnNldC5cbiAgICAgICAgY29uc3QgaXRlbXNDb250YWluZXJDaGlsZHJlbkNvdW50ID0gdGhpcy5pdGVtc0NvbnRhaW5lci5uYXRpdmVFbGVtZW50LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgbGV0IGl0ZW1zQ29udGFpbmVyV2lkdGggPSAwO1xuXG4gICAgICAgIGlmIChpdGVtc0NvbnRhaW5lckNoaWxkcmVuQ291bnQgPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0VGFiID0gdGhpcy5pdGVtc0NvbnRhaW5lci5uYXRpdmVFbGVtZW50LmNoaWxkcmVuW2l0ZW1zQ29udGFpbmVyQ2hpbGRyZW5Db3VudCAtIDFdIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgaXRlbXNDb250YWluZXJXaWR0aCA9IHRoaXMuZ2V0RWxlbWVudE9mZnNldChsYXN0VGFiKSArIGxhc3RUYWIub2Zmc2V0V2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXNDb250YWluZXJXaWR0aDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE9mZnNldChvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpci5ydGwgPyAtb2Zmc2V0IDogb2Zmc2V0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0RWxlbWVudE9mZnNldChlbGVtZW50OiBIVE1MRWxlbWVudCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpci5ydGwgPyB0aGlzLml0ZW1zV3JhcHBlci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC0gZWxlbWVudC5vZmZzZXRMZWZ0IC0gZWxlbWVudC5vZmZzZXRXaWR0aCA6IGVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICB9XG59XG5cbiIsIjxkaXYgI2hlYWRlckNvbnRhaW5lciBjbGFzcz1cImlneC10YWJzX19oZWFkZXJcIj5cbiAgICA8YnV0dG9uICNzY3JvbGxQcmV2QnV0dG9uIGlneEJ1dHRvbj1cImljb25cIiBpZ3hSaXBwbGUgY2xhc3M9XCJpZ3gtdGFic19faGVhZGVyLWJ1dHRvblwiIChjbGljayk9XCJzY3JvbGxQcmV2KClcIj5cbiAgICAgICAgPGlneC1pY29uPm5hdmlnYXRlX2JlZm9yZTwvaWd4LWljb24+XG4gICAgPC9idXR0b24+XG4gICAgPGRpdiAjdmlld1BvcnQgY2xhc3M9XCJpZ3gtdGFic19faGVhZGVyLWNvbnRlbnRcIj5cbiAgICAgICAgPGRpdiAjaXRlbXNXcmFwcGVyIGNsYXNzPVwiaWd4LXRhYnNfX2hlYWRlci13cmFwcGVyXCIgcm9sZT1cInRhYmxpc3RcIj5cbiAgICAgICAgICAgIDxkaXYgI2l0ZW1zQ29udGFpbmVyIGNsYXNzPVwiaWd4LXRhYnNfX2hlYWRlci1zY3JvbGxcIiBbbmdDbGFzc109XCJyZXNvbHZlSGVhZGVyU2Nyb2xsQ2xhc3NlcygpXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgdGFiIG9mIGl0ZW1zOyBsZXQgaSA9IGluZGV4XCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJ0YWIuaGVhZGVyVGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiAjc2VsZWN0ZWRJbmRpY2F0b3IgKm5nSWY9XCJpdGVtcy5sZW5ndGggPiAwXCIgY2xhc3M9XCJpZ3gtdGFic19faGVhZGVyLWFjdGl2ZS1pbmRpY2F0b3JcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8YnV0dG9uICNzY3JvbGxOZXh0QnV0dG9uIGlneEJ1dHRvbj1cImljb25cIiBpZ3hSaXBwbGUgY2xhc3M9XCJpZ3gtdGFic19faGVhZGVyLWJ1dHRvblwiIChjbGljayk9XCJzY3JvbGxOZXh0KClcIj5cbiAgICAgICAgPGlneC1pY29uPm5hdmlnYXRlX25leHQ8L2lneC1pY29uPlxuICAgIDwvYnV0dG9uPlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwiaWd4LXRhYnNfX3BhbmVsc1wiPlxuICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IHRhYiBvZiBpdGVtczsgbGV0IGkgPSBpbmRleFwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwidGFiLnBhbmVsVGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvZGl2PiJdfQ==