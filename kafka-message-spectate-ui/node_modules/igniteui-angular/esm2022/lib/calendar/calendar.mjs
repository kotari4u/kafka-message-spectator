import { DateRangeType } from '../core/dates';
import { mkenum } from '../core/utils';
/**
 * Sets the selection type - single, multi or range.
 */
export const CalendarSelection = mkenum({
    SINGLE: 'single',
    MULTI: 'multi',
    RANGE: 'range'
});
export var ScrollMonth;
(function (ScrollMonth) {
    ScrollMonth["PREV"] = "prev";
    ScrollMonth["NEXT"] = "next";
    ScrollMonth["NONE"] = "none";
})(ScrollMonth || (ScrollMonth = {}));
export const IgxCalendarView = mkenum({
    Month: 'month',
    Year: 'year',
    Decade: 'decade'
});
/**
 * @hidden
 */
var TimeDeltaInterval;
(function (TimeDeltaInterval) {
    TimeDeltaInterval["Month"] = "month";
    TimeDeltaInterval["Year"] = "year";
})(TimeDeltaInterval || (TimeDeltaInterval = {}));
const MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const FEBRUARY = 1;
export const range = (start = 0, stop, step = 1) => {
    const res = [];
    const cur = (stop === undefined) ? 0 : start;
    const max = (stop === undefined) ? start : stop;
    for (let i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
};
/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param year
 * @returns
 */
export const isLeap = (year) => (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
export const weekDay = (year, month, day) => new Date(year, month, day).getDay();
/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param year
 * @param month
 * @returns
 */
export const monthRange = (year, month) => {
    if ((month < 0) || (month > 11)) {
        throw new Error('Invalid month specified');
    }
    const day = weekDay(year, month, 1);
    let nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
};
export const isDateInRanges = (date, ranges) => {
    date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const dateInMs = date.getTime();
    if (!ranges) {
        return false;
    }
    for (const descriptor of ranges) {
        const dRanges = descriptor.dateRange ? descriptor.dateRange.map(r => new Date(r.getFullYear(), r.getMonth(), r.getDate())) : undefined;
        switch (descriptor.type) {
            case (DateRangeType.After):
                if (dateInMs > dRanges[0].getTime()) {
                    return true;
                }
                break;
            case (DateRangeType.Before):
                if (dateInMs < dRanges[0].getTime()) {
                    return true;
                }
                break;
            case (DateRangeType.Between):
                const dRange = dRanges.map(d => d.getTime());
                const min = Math.min(dRange[0], dRange[1]);
                const max = Math.max(dRange[0], dRange[1]);
                if (dateInMs >= min && dateInMs <= max) {
                    return true;
                }
                break;
            case (DateRangeType.Specific):
                const datesInMs = dRanges.map(d => d.getTime());
                for (const specificDateInMs of datesInMs) {
                    if (dateInMs === specificDateInMs) {
                        return true;
                    }
                }
                break;
            case (DateRangeType.Weekdays):
                const day = date.getDay();
                if (day % 6 !== 0) {
                    return true;
                }
                break;
            case (DateRangeType.Weekends):
                const weekday = date.getDay();
                if (weekday % 6 === 0) {
                    return true;
                }
                break;
            default:
                return false;
        }
    }
    return false;
};
export var WEEKDAYS;
(function (WEEKDAYS) {
    WEEKDAYS[WEEKDAYS["SUNDAY"] = 0] = "SUNDAY";
    WEEKDAYS[WEEKDAYS["MONDAY"] = 1] = "MONDAY";
    WEEKDAYS[WEEKDAYS["TUESDAY"] = 2] = "TUESDAY";
    WEEKDAYS[WEEKDAYS["WEDNESDAY"] = 3] = "WEDNESDAY";
    WEEKDAYS[WEEKDAYS["THURSDAY"] = 4] = "THURSDAY";
    WEEKDAYS[WEEKDAYS["FRIDAY"] = 5] = "FRIDAY";
    WEEKDAYS[WEEKDAYS["SATURDAY"] = 6] = "SATURDAY";
})(WEEKDAYS || (WEEKDAYS = {}));
export class Calendar {
    constructor(firstWeekDay = WEEKDAYS.SUNDAY) {
        this._firstWeekDay = firstWeekDay;
    }
    get firstWeekDay() {
        return this._firstWeekDay % 7;
    }
    set firstWeekDay(value) {
        this._firstWeekDay = value;
    }
    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * @returns
     *
     * @memberof Calendar
     */
    weekdays() {
        const res = [];
        for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {
            res.push(i % 7);
        }
        return res;
    }
    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * @param year
     * @param month
     * @param boolean
     * @returns
     *
     * @memberof Calendar
     */
    monthdates(year, month, extraWeek = false) {
        let date = new Date(year, month, 1);
        let days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, 'day', -days);
        const res = [];
        let value;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, 'day', 1);
            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    for (const _ of range(0, 7)) {
                        value = this.generateICalendarDate(date, year, month);
                        res.push(value);
                        date = this.timedelta(date, 'day', 1);
                    }
                }
                break;
            }
        }
        return res;
    }
    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * @param year
     * @param month
     * @returns
     *
     * @memberof Calendar
     */
    monthdatescalendar(year, month, extraWeek = false) {
        const dates = this.monthdates(year, month, extraWeek);
        const res = [];
        for (const i of range(0, dates.length, 7)) {
            res.push(dates.slice(i, i + 7));
        }
        return res;
    }
    timedelta(date, interval, units) {
        const ret = new Date(date);
        const checkRollover = () => {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };
        switch (interval.toLowerCase()) {
            case 'year':
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case 'quarter':
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case 'month':
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case 'week':
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case 'day':
                ret.setDate(ret.getDate() + units);
                break;
            case 'hour':
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case 'minute':
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case 'second':
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error('Invalid interval specifier');
        }
        return ret;
    }
    formatToParts(date, locale, options, parts) {
        const formatter = new Intl.DateTimeFormat(locale, options);
        const result = {
            date,
            full: formatter.format(date)
        };
        if (formatter.formatToParts) {
            const formattedParts = formatter.formatToParts(date);
            const toType = (partType) => {
                const index = formattedParts.findIndex(({ type }) => type === partType);
                const o = { value: '', literal: '', combined: '' };
                if (partType === 'era' && index > -1) {
                    o.value = formattedParts[index].value;
                    return o;
                }
                else if (partType === 'era' && index === -1) {
                    return o;
                }
                o.value = formattedParts[index].value;
                o.literal = formattedParts[index + 1] ? formattedParts[index + 1].value : '';
                o.combined = [o.value, o.literal].join('');
                return o;
            };
            for (const each of parts) {
                result[each] = toType(each);
            }
        }
        else {
            for (const each of parts) {
                result[each] = { value: '', literal: '', combined: '' };
            }
        }
        return result;
    }
    getFirstViewDate(date, interval, activeViewIdx) {
        return this.timedelta(date, interval, -activeViewIdx);
    }
    getDateByView(date, interval, activeViewIdx) {
        return this.timedelta(date, interval, activeViewIdx);
    }
    getNextMonth(date) {
        return this.timedelta(date, TimeDeltaInterval.Month, 1);
    }
    getPrevMonth(date) {
        return this.timedelta(date, TimeDeltaInterval.Month, -1);
    }
    getNextYear(date) {
        return this.timedelta(date, TimeDeltaInterval.Year, 1);
    }
    getPrevYear(date) {
        return this.timedelta(date, TimeDeltaInterval.Year, -1);
    }
    getWeekNumber(date, weekStart) {
        // current year
        const yearStart = new Date(date.getFullYear(), 0, 1);
        // first day number of the current year
        let firstDayOfTheYear = yearStart.getDay() - weekStart;
        firstDayOfTheYear = firstDayOfTheYear >= 0 ? firstDayOfTheYear : firstDayOfTheYear + 7;
        const dayInMilSeconds = 86400000;
        // day number in the year
        const dayNumber = Math.floor((date.getTime() - yearStart.getTime() -
            (date.getTimezoneOffset() - yearStart.getTimezoneOffset()) * 60000) / dayInMilSeconds) + 1;
        let weekNumber;
        // if 01 Jan is Monday to Thursday, is considered 1st week of the year 
        // if 01 Jan starts Friday to Sunday, is considered last week of previous year
        if (firstDayOfTheYear < 4) {
            // when calculating the week number we add 1 for the 1st week
            weekNumber = Math.floor((dayNumber + firstDayOfTheYear - 1) / 7) + 1;
        }
        else {
            // calculating the week number
            weekNumber = Math.floor((dayNumber + firstDayOfTheYear - 1) / 7);
        }
        // if the week number is greater than week 52
        if (weekNumber > 52) {
            // next year
            let nextYear = new Date(date.getFullYear() + 1, 0, 1);
            // first day of the next year
            let nextYearFirstDay = nextYear.getDay() - weekStart;
            nextYearFirstDay = nextYearFirstDay >= 0 ? nextYearFirstDay : nextYearFirstDay + 7;
            // if 01 Jan of the next year is Monday to Thursday, is considered 1st week of the next year 
            // if 01 Jan is Friday to Sunday, is considered 53rd week of the current year
            weekNumber = nextYearFirstDay < 4 ? 1 : 53;
        }
        return weekNumber;
    }
    generateICalendarDate(date, year, month) {
        return {
            date,
            isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
            isNextMonth: this.isNextMonth(date, year, month),
            isPrevMonth: this.isPreviousMonth(date, year, month)
        };
    }
    isPreviousMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    }
    isNextMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvY2FsZW5kYXIvY2FsZW5kYXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUF1QixhQUFhLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV2Qzs7R0FFRztBQUNILE1BQU0sQ0FBQyxNQUFNLGlCQUFpQixHQUFHLE1BQU0sQ0FBQztJQUNwQyxNQUFNLEVBQUUsUUFBUTtJQUNoQixLQUFLLEVBQUUsT0FBTztJQUNkLEtBQUssRUFBRSxPQUFPO0NBQ2pCLENBQUMsQ0FBQztBQUdILE1BQU0sQ0FBTixJQUFZLFdBSVg7QUFKRCxXQUFZLFdBQVc7SUFDbkIsNEJBQWEsQ0FBQTtJQUNiLDRCQUFhLENBQUE7SUFDYiw0QkFBYSxDQUFBO0FBQ2pCLENBQUMsRUFKVyxXQUFXLEtBQVgsV0FBVyxRQUl0QjtBQU9ELE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUM7SUFDbEMsS0FBSyxFQUFFLE9BQU87SUFDZCxJQUFJLEVBQUUsTUFBTTtJQUNaLE1BQU0sRUFBRSxRQUFRO0NBQ25CLENBQUMsQ0FBQztBQU9IOztHQUVHO0FBQ0gsSUFBSyxpQkFHSjtBQUhELFdBQUssaUJBQWlCO0lBQ2xCLG9DQUFlLENBQUE7SUFDZixrQ0FBYSxDQUFBO0FBQ2pCLENBQUMsRUFISSxpQkFBaUIsS0FBakIsaUJBQWlCLFFBR3JCO0FBRUQsTUFBTSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQy9ELE1BQU0sUUFBUSxH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NkY7WUFDN0YsNkVBQTZFO1lBQzdFLFVBQVUsR0FBRyxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1NBQzlDO1FBQ0QsT0FBTyxVQUFVLENBQUM7SUFDdEIsQ0FBQztJQUVPLHFCQUFxQixDQUFDLElBQVUsRUFBRSxJQUFZLEVBQUUsS0FBYTtRQUNqRSxPQUFPO1lBQ0gsSUFBSTtZQUNKLGNBQWMsRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLEtBQUssSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxLQUFLO1lBQ3hFLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDO1lBQ2hELFdBQVcsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDO1NBQ3ZELENBQUM7SUFDTixDQUFDO0lBRU8sZUFBZSxDQUFDLElBQVUsRUFBRSxJQUFZLEVBQUUsS0FBYTtRQUMzRCxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDN0IsT0FBTyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsS0FBSyxDQUFDO1NBQ2xDO1FBQ0QsT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFLEdBQUcsSUFBSSxDQUFDO0lBQ3JDLENBQUM7SUFFTyxXQUFXLENBQUMsSUFBVSxFQUFFLElBQVksRUFBRSxLQUFhO1FBQ3ZELElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLElBQUksRUFBRTtZQUM3QixPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxLQUFLLENBQUM7U0FDbEM7UUFFRCxPQUFPLElBQUksQ0FBQyxXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUM7SUFDckMsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0ZVJhbmdlRGVzY3JpcHRvciwgRGF0ZVJhbmdlVHlwZSB9IGZyb20gJy4uL2NvcmUvZGF0ZXMnO1xuaW1wb3J0IHsgbWtlbnVtIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5cbi8qKlxuICogU2V0cyB0aGUgc2VsZWN0aW9uIHR5cGUgLSBzaW5nbGUsIG11bHRpIG9yIHJhbmdlLlxuICovXG5leHBvcnQgY29uc3QgQ2FsZW5kYXJTZWxlY3Rpb24gPSBta2VudW0oe1xuICAgIFNJTkdMRTogJ3NpbmdsZScsXG4gICAgTVVMVEk6ICdtdWx0aScsXG4gICAgUkFOR0U6ICdyYW5nZSdcbn0pO1xuZXhwb3J0IHR5cGUgQ2FsZW5kYXJTZWxlY3Rpb24gPSAodHlwZW9mIENhbGVuZGFyU2VsZWN0aW9uKVtrZXlvZiB0eXBlb2YgQ2FsZW5kYXJTZWxlY3Rpb25dO1xuXG5leHBvcnQgZW51bSBTY3JvbGxNb250aCB7XG4gICAgUFJFViA9ICdwcmV2JyxcbiAgICBORVhUID0gJ25leHQnLFxuICAgIE5PTkUgPSAnbm9uZSdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVmlld0RhdGVDaGFuZ2VFdmVudEFyZ3Mge1xuICAgIHByZXZpb3VzVmFsdWU6IERhdGU7XG4gICAgY3VycmVudFZhbHVlOiBEYXRlO1xufVxuXG5leHBvcnQgY29uc3QgSWd4Q2FsZW5kYXJWaWV3ID0gbWtlbnVtKHtcbiAgICBNb250aDogJ21vbnRoJyxcbiAgICBZZWFyOiAneWVhcicsXG4gICAgRGVjYWRlOiAnZGVjYWRlJ1xufSk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgQ2FsZW5kYXIgYWN0aXZlIHZpZXcgLSBkYXlzLCBtb250aHMgb3IgeWVhcnMuXG4gKi9cbmV4cG9ydCB0eXBlIElneENhbGVuZGFyVmlldyA9ICh0eXBlb2YgSWd4Q2FsZW5kYXJWaWV3KVtrZXlvZiB0eXBlb2YgSWd4Q2FsZW5kYXJWaWV3XTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmVudW0gVGltZURlbHRhSW50ZXJ2YWwge1xuICAgIE1vbnRoID0gJ21vbnRoJyxcbiAgICBZZWFyID0gJ3llYXInXG59XG5cbmNvbnN0IE1EQVlTID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuY29uc3QgRkVCUlVBUlkgPSAxO1xuXG5leHBvcnQgY29uc3QgcmFuZ2UgPSAoc3RhcnQgPSAwLCBzdG9wLCBzdGVwID0gMSkgPT4ge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGN1ciA9IChzdG9wID09PSB1bmRlZmluZWQpID8gMCA6IHN0YXJ0O1xuICAgIGNvbnN0IG1heCA9IChzdG9wID09PSB1bmRlZmluZWQpID8gc3RhcnQgOiBzdG9wO1xuICAgIGZvciAobGV0IGkgPSBjdXI7IHN0ZXAgPCAwID8gaSA+IG1heCA6IGkgPCBtYXg7IGkgKz0gc3RlcCkge1xuICAgICAgICByZXMucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGZvciBsZWFwIHllYXJzLCBmYWxzZSBmb3Igbm9uLWxlYXAgeWVhcnMuXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIHllYXJcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBjb25zdCBpc0xlYXAgPSAoeWVhcjogbnVtYmVyKTogYm9vbGVhbiA9PiAoeWVhciAlIDQgPT09IDApICYmICgoeWVhciAlIDEwMCAhPT0gMCkgfHwgKHllYXIgJSA0MDAgPT09IDApKTtcblxuZXhwb3J0IGNvbnN0IHdlZWtEYXkgPSAoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlcik6IG51bWJlciA9PiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KS5nZXREYXkoKTtcblxuLyoqXG4gKiBSZXR1cm4gd2Vla2RheSBhbmQgbnVtYmVyIG9mIGRheXMgZm9yIHllYXIsIG1vbnRoLlxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB5ZWFyXG4gKiBAcGFyYW0gbW9udGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBjb25zdCBtb250aFJhbmdlID0gKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgICBpZiAoKG1vbnRoIDwgMCkgfHwgKG1vbnRoID4gMTEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtb250aCBzcGVjaWZpZWQnKTtcbiAgICB9XG4gICAgY29uc3QgZGF5ID0gd2Vla0RheSh5ZWFyLCBtb250aCwgMSk7XG4gICAgbGV0IG5EYXlzID0gTURBWVNbbW9udGhdO1xuICAgIGlmICgobW9udGggPT09IEZFQlJVQVJZKSAmJiAoaXNMZWFwKHllYXIpKSkge1xuICAgICAgICBuRGF5cysrO1xuICAgIH1cbiAgICByZXR1cm4gW2RheSwgbkRheXNdO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzRGF0ZUluUmFuZ2VzID0gKGRhdGU6IERhdGUsIHJhbmdlczogRGF0ZVJhbmdlRGVzY3JpcHRvcltdKTogYm9vbGVhbiA9PiB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgY29uc3QgZGF0ZUluTXMgPSBkYXRlLmdldFRpbWUoKTtcblxuICAgIGlmICghcmFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGRlc2NyaXB0b3Igb2YgcmFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGRSYW5nZXMgPSBkZXNjcmlwdG9yLmRhdGVSYW5nZSA/IGRlc2NyaXB0b3IuZGF0ZVJhbmdlLm1hcChcbiAgICAgICAgICAgIHIgPT4gbmV3IERhdGUoci5nZXRGdWxsWWVhcigpLCByLmdldE1vbnRoKCksIHIuZ2V0RGF0ZSgpKSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHN3aXRjaCAoZGVzY3JpcHRvci50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIChEYXRlUmFuZ2VUeXBlLkFmdGVyKTpcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZUluTXMgPiBkUmFuZ2VzWzBdLmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKERhdGVSYW5nZVR5cGUuQmVmb3JlKTpcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZUluTXMgPCBkUmFuZ2VzWzBdLmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKERhdGVSYW5nZVR5cGUuQmV0d2Vlbik6XG4gICAgICAgICAgICAgICAgY29uc3QgZFJhbmdlID0gZFJhbmdlcy5tYXAoZCA9PiBkLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oZFJhbmdlWzBdLCBkUmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGRSYW5nZVswXSwgZFJhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZUluTXMgPj0gbWluICYmIGRhdGVJbk1zIDw9IG1heCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKERhdGVSYW5nZVR5cGUuU3BlY2lmaWMpOlxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVzSW5NcyA9IGRSYW5nZXMubWFwKGQgPT4gZC5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3BlY2lmaWNEYXRlSW5NcyBvZiBkYXRlc0luTXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVJbk1zID09PSBzcGVjaWZpY0RhdGVJbk1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoRGF0ZVJhbmdlVHlwZS5XZWVrZGF5cyk6XG4gICAgICAgICAgICAgICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF5ICUgNiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKERhdGVSYW5nZVR5cGUuV2Vla2VuZHMpOlxuICAgICAgICAgICAgICAgIGNvbnN0IHdlZWtkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5ICUgNiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBJQ2FsZW5kYXJEYXRlIHtcbiAgICBkYXRlOiBEYXRlO1xuICAgIGlzQ3VycmVudE1vbnRoOiBib29sZWFuO1xuICAgIGlzUHJldk1vbnRoOiBib29sZWFuO1xuICAgIGlzTmV4dE1vbnRoOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElGb3JtYXR0ZWRQYXJ0cyB7XG4gICAgdmFsdWU6IHN0cmluZztcbiAgICBsaXRlcmFsPzogc3RyaW5nO1xuICAgIGNvbWJpbmVkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZvcm1hdHRpbmdPcHRpb25zIHtcbiAgICBkYXk/OiAnbnVtZXJpYycgfCAnMi1kaWdpdCc7XG4gICAgbW9udGg/OiAnbnVtZXJpYycgfCAnMi1kaWdpdCcgfCAnbG9uZycgfCAnc2hvcnQnIHwgJ25hcnJvdyc7XG4gICAgd2Vla2RheT86ICdsb25nJyB8ICdzaG9ydCcgfCAnbmFycm93JztcbiAgICB5ZWFyPzogJ251bWVyaWMnIHwgJzItZGlnaXQnO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZvcm1hdHRpbmdWaWV3cyB7XG4gICAgZGF5PzogYm9vbGVhbjtcbiAgICBtb250aD86IGJvb2xlYW47XG4gICAgeWVhcj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBlbnVtIFdFRUtEQVlTIHtcbiAgICBTVU5EQVkgPSAwLFxuICAgIE1PTkRBWSA9IDEsXG4gICAgVFVFU0RBWSA9IDIsXG4gICAgV0VETkVTREFZID0gMyxcbiAgICBUSFVSU0RBWSA9IDQsXG4gICAgRlJJREFZID0gNSxcbiAgICBTQVRVUkRBWSA9IDZcbn1cblxuZXhwb3J0IGNsYXNzIENhbGVuZGFyIHtcblxuICAgIHByaXZhdGUgX2ZpcnN0V2Vla0RheTogV0VFS0RBWVMgfCBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihmaXJzdFdlZWtEYXk6IFdFRUtEQVlTID0gV0VFS0RBWVMuU1VOREFZKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0V2Vla0RheSA9IGZpcnN0V2Vla0RheTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGZpcnN0V2Vla0RheSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3RXZWVrRGF5ICUgNztcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGZpcnN0V2Vla0RheSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0V2Vla0RheSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygd2Vla2RheXMgZm9yIG9uZSB3ZWVrIHN0YXJ0aW5nXG4gICAgICogd2l0aCB0aGUgY3VycmVudGx5IHNldCBgZmlyc3RXZWVrRGF5YFxuICAgICAqXG4gICAgICogdGhpcy5maXJzdFdlZWtEYXkgPSAwIChTdW5kYXkpIC0tPiBbMCwgMSwgMiwgMywgNCwgNSwgNl1cbiAgICAgKiB0aGlzLmZpcnN0V2Vla0RheSA9IDEgKE1vbmRheSkgLS0+IFsxLCAyLCAzLCA0LCA1LCA2LCAwXVxuICAgICAqXG4gICAgICogQHJldHVybnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDYWxlbmRhclxuICAgICAqL1xuICAgIHB1YmxpYyB3ZWVrZGF5cygpOiBudW1iZXJbXSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2UodGhpcy5maXJzdFdlZWtEYXksIHRoaXMuZmlyc3RXZWVrRGF5ICsgNykpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGkgJSA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGUgdmFsdWVzIGZvciBvbmUgbW9udGguIEl0IHdpbGwgYWx3YXlzIGl0ZXJhdGUgdGhyb3VnaHRcbiAgICAgKiBjb21wbGV0ZSB3ZWVrcywgc28gaXQgd2lsbCBjb250YWluIGRhdGVzIG91dHNpZGUgdGhlIHNwZWNpZmllZCBtb250aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICogQHBhcmFtIG1vbnRoXG4gICAgICogQHBhcmFtIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENhbGVuZGFyXG4gICAgICovXG4gICAgcHVibGljIG1vbnRoZGF0ZXMoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBleHRyYVdlZWsgPSBmYWxzZSk6IElDYWxlbmRhckRhdGVbXSB7XG4gICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpO1xuICAgICAgICBsZXQgZGF5cyA9IChkYXRlLmdldERheSgpIC0gdGhpcy5maXJzdFdlZWtEYXkpICUgNztcbiAgICAgICAgaWYgKGRheXMgPCAwKSB7XG4gICAgICAgICAgICBkYXlzID0gNyAtIE1hdGguYWJzKGRheXMpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGUgPSB0aGlzLnRpbWVkZWx0YShkYXRlLCAnZGF5JywgLWRheXMpO1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgbGV0IHZhbHVlOiBJQ2FsZW5kYXJEYXRlO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcblxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdlbmVyYXRlSUNhbGVuZGFyRGF0ZShkYXRlLCB5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICByZXMucHVzaCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLnRpbWVkZWx0YShkYXRlLCAnZGF5JywgMSk7XG5cbiAgICAgICAgICAgIGlmICgoZGF0ZS5nZXRNb250aCgpICE9PSBtb250aCkgJiYgKGRhdGUuZ2V0RGF5KCkgPT09IHRoaXMuZmlyc3RXZWVrRGF5KSkge1xuICAgICAgICAgICAgICAgIGlmIChleHRyYVdlZWsgJiYgcmVzLmxlbmd0aCA8PSAzNSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IF8gb2YgcmFuZ2UoMCwgNykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZW5lcmF0ZUlDYWxlbmRhckRhdGUoZGF0ZSwgeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IHRoaXMudGltZWRlbHRhKGRhdGUsICdkYXknLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXRyaXggKGFycmF5IG9mIGFycmF5cykgcmVwcmVzZW50aW5nIGEgbW9udGgncyBjYWxlbmRhci5cbiAgICAgKiBFYWNoIHJvdyByZXByZXNlbnRzIGEgZnVsbCB3ZWVrOyB3ZWVrIGVudHJpZXMgYXJlIElDYWxlbmRhckRhdGUgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICogQHBhcmFtIG1vbnRoXG4gICAgICogQHJldHVybnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDYWxlbmRhclxuICAgICAqL1xuICAgIHB1YmxpYyBtb250aGRhdGVzY2FsZW5kYXIoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBleHRyYVdlZWsgPSBmYWxzZSk6IElDYWxlbmRhckRhdGVbXVtdIHtcbiAgICAgICAgY29uc3QgZGF0ZXMgPSB0aGlzLm1vbnRoZGF0ZXMoeWVhciwgbW9udGgsIGV4dHJhV2Vlayk7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2UoMCwgZGF0ZXMubGVuZ3RoLCA3KSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZGF0ZXMuc2xpY2UoaSwgaSArIDcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHB1YmxpYyB0aW1lZGVsdGEoZGF0ZTogRGF0ZSwgaW50ZXJ2YWw6IHN0cmluZywgdW5pdHM6IG51bWJlcik6IERhdGUge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgRGF0ZShkYXRlKTtcblxuICAgICAgICBjb25zdCBjaGVja1JvbGxvdmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJldC5nZXREYXRlKCkgIT09IGRhdGUuZ2V0RGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0LnNldERhdGUoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc3dpdGNoIChpbnRlcnZhbC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICByZXQuc2V0RnVsbFllYXIocmV0LmdldEZ1bGxZZWFyKCkgKyB1bml0cyk7XG4gICAgICAgICAgICAgICAgY2hlY2tSb2xsb3ZlcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgcmV0LnNldE1vbnRoKHJldC5nZXRNb250aCgpICsgMyAqIHVuaXRzKTtcbiAgICAgICAgICAgICAgICBjaGVja1JvbGxvdmVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgcmV0LnNldE1vbnRoKHJldC5nZXRNb250aCgpICsgdW5pdHMpO1xuICAgICAgICAgICAgICAgIGNoZWNrUm9sbG92ZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHJldC5zZXREYXRlKHJldC5nZXREYXRlKCkgKyA3ICogdW5pdHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICByZXQuc2V0RGF0ZShyZXQuZ2V0RGF0ZSgpICsgdW5pdHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgcmV0LnNldFRpbWUocmV0LmdldFRpbWUoKSArIHVuaXRzICogMzYwMDAwMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHJldC5zZXRUaW1lKHJldC5nZXRUaW1lKCkgKyB1bml0cyAqIDYwMDAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgcmV0LnNldFRpbWUocmV0LmdldFRpbWUoKSArIHVuaXRzICogMTAwMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlcnZhbCBzcGVjaWZpZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHB1YmxpYyBmb3JtYXRUb1BhcnRzKGRhdGU6IERhdGUsIGxvY2FsZTogc3RyaW5nLCBvcHRpb25zOiBhbnksIHBhcnRzOiBzdHJpbmdbXSkge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgZnVsbDogZm9ybWF0dGVyLmZvcm1hdChkYXRlKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICgoZm9ybWF0dGVyIGFzIGFueSkuZm9ybWF0VG9QYXJ0cykge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkUGFydHMgPSAoZm9ybWF0dGVyIGFzIGFueSkuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcblxuICAgICAgICAgICAgY29uc3QgdG9UeXBlID0gKHBhcnRUeXBlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGZvcm1hdHRlZFBhcnRzLmZpbmRJbmRleCgoeyB0eXBlIH0pID0+IHR5cGUgPT09IHBhcnRUeXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvOiBJRm9ybWF0dGVkUGFydHMgPSB7IHZhbHVlOiAnJywgbGl0ZXJhbDogJycsIGNvbWJpbmVkOiAnJyB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRUeXBlID09PSAnZXJhJyAmJiBpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIG8udmFsdWUgPSBmb3JtYXR0ZWRQYXJ0c1tpbmRleF0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydFR5cGUgPT09ICdlcmEnICYmIGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvLnZhbHVlID0gZm9ybWF0dGVkUGFydHNbaW5kZXhdLnZhbHVlO1xuICAgICAgICAgICAgICAgIG8ubGl0ZXJhbCA9IGZvcm1hdHRlZFBhcnRzW2luZGV4ICsgMV0gPyBmb3JtYXR0ZWRQYXJ0c1tpbmRleCArIDFdLnZhbHVlIDogJyc7XG4gICAgICAgICAgICAgICAgby5jb21iaW5lZCA9IFtvLnZhbHVlLCBvLmxpdGVyYWxdLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBlYWNoIG9mIHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2VhY2hdID0gdG9UeXBlKGVhY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlYWNoIG9mIHBhcnRzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2VhY2hdID0geyB2YWx1ZTogJycsIGxpdGVyYWw6ICcnLCBjb21iaW5lZDogJycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRGaXJzdFZpZXdEYXRlKGRhdGU6IERhdGUsIGludGVydmFsOiBzdHJpbmcsIGFjdGl2ZVZpZXdJZHg6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lZGVsdGEoZGF0ZSwgaW50ZXJ2YWwsIC1hY3RpdmVWaWV3SWR4KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0RGF0ZUJ5VmlldyhkYXRlOiBEYXRlLCBpbnRlcnZhbDogc3RyaW5nLCBhY3RpdmVWaWV3SWR4OiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZWRlbHRhKGRhdGUsIGludGVydmFsLCBhY3RpdmVWaWV3SWR4KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TmV4dE1vbnRoKGRhdGU6IERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZWRlbHRhKGRhdGUsIFRpbWVEZWx0YUludGVydmFsLk1vbnRoLCAxKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UHJldk1vbnRoKGRhdGU6IERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZWRlbHRhKGRhdGUsIFRpbWVEZWx0YUludGVydmFsLk1vbnRoLCAtMSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE5leHRZZWFyKGRhdGU6IERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZWRlbHRhKGRhdGUsIFRpbWVEZWx0YUludGVydmFsLlllYXIsIDEpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRQcmV2WWVhcihkYXRlOiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVkZWx0YShkYXRlLCBUaW1lRGVsdGFJbnRlcnZhbC5ZZWFyLCAtMSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFdlZWtOdW1iZXIoZGF0ZTogRGF0ZSwgd2Vla1N0YXJ0OiBXRUVLREFZUyB8IG51bWJlcikge1xuICAgICAgICAvLyBjdXJyZW50IHllYXJcbiAgICAgICAgY29uc3QgeWVhclN0YXJ0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgICAgICAgLy8gZmlyc3QgZGF5IG51bWJlciBvZiB0aGUgY3VycmVudCB5ZWFyXG4gICAgICAgIGxldCBmaXJzdERheU9mVGhlWWVhciA9IHllYXJTdGFydC5nZXREYXkoKSAtIHdlZWtTdGFydDtcbiAgICAgICAgZmlyc3REYXlPZlRoZVllYXIgPSBmaXJzdERheU9mVGhlWWVhciA+PSAwID8gZmlyc3REYXlPZlRoZVllYXIgOiBmaXJzdERheU9mVGhlWWVhciArIDc7XG4gICAgICAgIGNvbnN0IGRheUluTWlsU2Vjb25kcyA9IDg2NDAwMDAwO1xuICAgICAgICAvLyBkYXkgbnVtYmVyIGluIHRoZSB5ZWFyXG4gICAgICAgIGNvbnN0IGRheU51bWJlciA9IE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpIC0geWVhclN0YXJ0LmdldFRpbWUoKSAtIFxuICAgICAgICAoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC0geWVhclN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogNjAwMDApIC8gZGF5SW5NaWxTZWNvbmRzKSArIDE7XG4gICAgICAgIGxldCB3ZWVrTnVtYmVyO1xuICAgICAgICAvLyBpZiAwMSBKYW4gaXMgTW9uZGF5IHRvIFRodXJzZGF5LCBpcyBjb25zaWRlcmVkIDFzdCB3ZWVrIG9mIHRoZSB5ZWFyIFxuICAgICAgICAvLyBpZiAwMSBKYW4gc3RhcnRzIEZyaWRheSB0byBTdW5kYXksIGlzIGNvbnNpZGVyZWQgbGFzdCB3ZWVrIG9mIHByZXZpb3VzIHllYXJcbiAgICAgICAgaWYgKGZpcnN0RGF5T2ZUaGVZZWFyIDwgNCkge1xuICAgICAgICAgICAgLy8gd2hlbiBjYWxjdWxhdGluZyB0aGUgd2VlayBudW1iZXIgd2UgYWRkIDEgZm9yIHRoZSAxc3Qgd2Vla1xuICAgICAgICAgICAgd2Vla051bWJlciA9IE1hdGguZmxvb3IoKGRheU51bWJlciArIGZpcnN0RGF5T2ZUaGVZZWFyIC0gMSkgLyA3KSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGluZyB0aGUgd2VlayBudW1iZXJcbiAgICAgICAgICAgIHdlZWtOdW1iZXIgPSBNYXRoLmZsb29yKChkYXlOdW1iZXIgKyBmaXJzdERheU9mVGhlWWVhciAtIDEpIC8gNyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHdlZWsgbnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB3ZWVrIDUyXG4gICAgICAgIGlmICh3ZWVrTnVtYmVyID4gNTIpIHtcbiAgICAgICAgICAgIC8vIG5leHQgeWVhclxuICAgICAgICAgICAgbGV0IG5leHRZZWFyID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpICsgMSwgMCwgMSk7XG4gICAgICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIG5leHQgeWVhclxuICAgICAgICAgICAgbGV0IG5leHRZZWFyRmlyc3REYXkgPSBuZXh0WWVhci5nZXREYXkoKSAtIHdlZWtTdGFydDtcbiAgICAgICAgICAgIG5leHRZZWFyRmlyc3REYXkgPSBuZXh0WWVhckZpcnN0RGF5ID49IDAgPyBuZXh0WWVhckZpcnN0RGF5IDogbmV4dFllYXJGaXJzdERheSArIDc7XG4gICAgICAgICAgICAvLyBpZiAwMSBKYW4gb2YgdGhlIG5leHQgeWVhciBpcyBNb25kYXkgdG8gVGh1cnNkYXksIGlzIGNvbnNpZGVyZWQgMXN0IHdlZWsgb2YgdGhlIG5leHQgeWVhciBcbiAgICAgICAgICAgIC8vIGlmIDAxIEphbiBpcyBGcmlkYXkgdG8gU3VuZGF5LCBpcyBjb25zaWRlcmVkIDUzcmQgd2VlayBvZiB0aGUgY3VycmVudCB5ZWFyXG4gICAgICAgICAgICB3ZWVrTnVtYmVyID0gbmV4dFllYXJGaXJzdERheSA8IDQgPyAxIDogNTM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlZWtOdW1iZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZUlDYWxlbmRhckRhdGUoZGF0ZTogRGF0ZSwgeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKTogSUNhbGVuZGFyRGF0ZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgaXNDdXJyZW50TW9udGg6IGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0geWVhciAmJiBkYXRlLmdldE1vbnRoKCkgPT09IG1vbnRoLFxuICAgICAgICAgICAgaXNOZXh0TW9udGg6IHRoaXMuaXNOZXh0TW9udGgoZGF0ZSwgeWVhciwgbW9udGgpLFxuICAgICAgICAgICAgaXNQcmV2TW9udGg6IHRoaXMuaXNQcmV2aW91c01vbnRoKGRhdGUsIHllYXIsIG1vbnRoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgaXNQcmV2aW91c01vbnRoKGRhdGU6IERhdGUsIHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoZGF0ZS5nZXRGdWxsWWVhcigpID09PSB5ZWFyKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpIDwgbW9udGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSA8IHllYXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc05leHRNb250aChkYXRlOiBEYXRlLCB5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0geWVhcikge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSA+IG1vbnRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSA+IHllYXI7XG4gICAgfVxufVxuIl19