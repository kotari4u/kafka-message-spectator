import { transition, trigger, useAnimation } from '@angular/animations';
import { Component, ContentChild, forwardRef, HostBinding, HostListener, Input, ViewChild, ViewChildren } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { fadeIn, scaleInCenter, slideInLeft, slideInRight } from '../animations/main';
import { IgxCalendarHeaderTemplateDirective, IgxCalendarSubheaderTemplateDirective, IgxCalendarScrollMonthDirective } from './calendar.directives';
import { IgxCalendarView, ScrollMonth, monthRange } from './calendar';
import { IgxMonthPickerBaseDirective } from './month-picker/month-picker-base';
import { IgxMonthsViewComponent } from './months-view/months-view.component';
import { IgxYearsViewComponent } from './years-view/years-view.component';
import { IgxDaysViewComponent } from './days-view/days-view.component';
import { interval } from 'rxjs';
import { takeUntil, debounce, skipLast, switchMap } from 'rxjs/operators';
import { IgxMonthViewSlotsCalendar, IgxGetViewDateCalendar } from './months-view.pipe';
import { IgxIconComponent } from '../icon/icon.component';
import { NgIf, NgTemplateOutlet, NgStyle, NgFor, DatePipe } from '@angular/common';
import * as i0 from "@angular/core";
let NEXT_ID = 0;
/**
 * Calendar provides a way to display date information.
 *
 * @igxModule IgxCalendarModule
 *
 * @igxTheme igx-calendar-theme, igx-icon-theme
 *
 * @igxKeywords calendar, datepicker, schedule, date
 *
 * @igxGroup Scheduling
 *
 * @remarks
 * The Ignite UI Calendar provides an easy way to display a calendar and allow users to select dates using single, multiple
 * or range selection.
 *
 * @example:
 * ```html
 * <igx-calendar selection="range"></igx-calendar>
 * ```
 */
export class IgxCalendarComponent extends IgxMonthPickerBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Sets/gets the `id` of the calendar.
         *
         * @remarks
         * If not set, the `id` will have value `"igx-calendar-0"`.
         *
         * @example
         * ```html
         * <igx-calendar id="my-first-calendar"></igx-calendar>
         * ```
         * @memberof IgxCalendarComponent
         */
        this.id = `igx-calendar-${NEXT_ID++}`;
        /**
         * Sets/gets whether the calendar has header.
         * Default value is `true`.
         *
         * @example
         * ```html
         * <igx-calendar [hasHeader]="false"></igx-calendar>
         * ```
         */
        this.hasHeader = true;
        /**
         * Sets/gets whether the calendar header will be in vertical position.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-calendar [vertical] = "true"></igx-calendar>
         * ```
         */
        this.vertical = false;
        /**
         * Show/hide week numbers
         *
         * @example
         * ```html
         * <igx-calendar [showWeekNumbers]="true"></igx-calendar>
         * ``
         */
        this.showWeekNumbers = false;
        /**
         * Apply the different states for the transitions of animateChange
         *
         * @hidden
         * @internal
         */
        this.animationAction = '';
        /**
         * The default css class applied to the component.
         *
         * @hidden
         * @internal
         */
        this.styleClass = true;
        /**
         * @hidden
         * @internal
         */
        this.activeDate = new Date().toLocaleDateString();
        /**
         * Denote if the calendar view was changed with the keyboard
         *
         * @hidden
         * @internal
         */
        this.isKeydownTrigger = false;
        /**
         * @hidden
         * @internal
         */
        this._monthsViewNumber = 1;
        /**
         * Continious navigation through the previous months
         *
         * @hidden
         * @internal
         */
        this.startPrevMonthScroll = (isKeydownTrigger = false) => {
            this.startMonthScroll$.next();
            this.monthScrollDirection = ScrollMonth.PREV;
            this.animationAction = ScrollMonth.PREV;
            this.previousMonth(isKeydownTrigger);
        };
        /**
         * Continious navigation through the next months
         *
         * @hidden
         * @internal
         */
        this.startNextMonthScroll = (isKeydownTrigger = false) => {
            this.startMonthScroll$.next();
            this.monthScrollDirection = ScrollMonth.NEXT;
            this.animationAction = ScrollMonth.NEXT;
            this.nextMonth(isKeydownTrigger);
        };
        /**
         * Stop continuous navigation
         *
         * @hidden
         * @internal
         */
        this.stopMonthScroll = (event) => {
            event.stopPropagation();
            // generally the scrolling is built on the calendar component
            // and all start/stop scrolling methods are called on the calendar
            // if we change below lines to call stopMonthScroll$ on the calendar instead of on the views,
            // strange bug is introduced --> after changing number of months, continuous scrolling on mouse click does not happen
            this.daysView.stopMonthScroll$.next(true);
            this.daysView.stopMonthScroll$.complete();
            if (this.monthScrollDirection === ScrollMonth.PREV) {
                this.prevMonthBtn.nativeElement.focus();
            }
            else if (this.monthScrollDirection === ScrollMonth.NEXT) {
                this.nextMonthBtn.nativeElement.focus();
            }
            if (this.platform.isActivationKey(event)) {
                this.resetActiveDate();
            }
            this.monthScrollDirection = ScrollMonth.NONE;
        };
    }
    /**
     * Sets/gets the number of month views displayed.
     * Default value is `1`.
     *
     * @example
     * ```html
     * <igx-calendar [monthsViewNumber]="2"></igx-calendar>
     * ```
     */
    get monthsViewNumber() {
        return this._monthsViewNumber;
    }
    set monthsViewNumber(val) {
        if (val < 1) {
            return;
        }
        this._monthsViewNumber = val;
    }
    /**
     * The default css class applied to the component.
     *
     * @hidden
     * @internal
     */
    get styleVerticalClass() {
        return this.vertical;
    }
    /**
     * Denote if the year view is active.
     *
     * @hidden
     * @internal
     */
    get isYearView() {
        return this.activeView === IgxCalendarView.Year;
    }
    /**
     * Gets the header template.
     *
     * @example
     * ```typescript
     * let headerTemplate =  this.calendar.headerTeamplate;
     * ```
     * @memberof IgxCalendarComponent
     */
    get headerTemplate() {
        if (this.headerTemplateDirective) {
            return this.headerTemplateDirective.template;
        }
        return null;
    }
    /**
     * Sets the header template.
     *
     * @example
     * ```html
     * <igx-calendar headerTemplateDirective = "igxCalendarHeader"></igx-calendar>
     * ```
     * @memberof IgxCalendarComponent
     */
    set headerTemplate(directive) {
        this.headerTemplateDirective = directive;
    }
    /**
     * Gets the subheader template.
     *
     * @example
     * ```typescript
     * let subheaderTemplate = this.calendar.subheaderTemplate;
     * ```
     */
    get subheaderTemplate() {
        if (this.subheaderTemplateDirective) {
            return this.subheaderTemplateDirective.template;
        }
        return null;
    }
    /**
     * Sets the subheader template.
     *
     * @example
     * ```html
     * <igx-calendar subheaderTemplate = "igxCalendarSubheader"></igx-calendar>
     * ```
     * @memberof IgxCalendarComponent
     */
    set subheaderTemplate(directive) {
        this.subheaderTemplateDirective = directive;
    }
    /**
     * Gets the context for the template marked with the `igxCalendarHeader` directive.
     *
     * @example
     * ```typescript
     * let headerContext =  this.calendar.headerContext;
     * ```
     */
    get headerContext() {
        const date = this.headerDate;
        return this.generateContext(date);
    }
    /**
     * Gets the context for the template marked with either `igxCalendarSubHeaderMonth`
     * or `igxCalendarSubHeaderYear` directive.
     *
     * @example
     * ```typescript
     * let context =  this.calendar.context;
     * ```
     */
    get context() {
        const date = this.viewDate;
        return this.generateContext(date);
    }
    /**
     * Date displayed in header
     *
     * @hidden
     * @internal
     */
    get headerDate() {
        return this.selectedDates ? this.selectedDates : new Date();
    }
    /**
     * Keyboard navigation of the calendar
     *
     * @hidden
     * @internal
     */
    onKeydownPageDown(event) {
        event.preventDefault();
        if (!this.isDefaultView) {
            return;
        }
        const isPageDown = event.key === 'PageDown';
        const step = isPageDown ? 1 : -1;
        let monthView = this.daysView;
        let activeDate;
        while (!activeDate && monthView) {
            activeDate = monthView.dates.find((date) => date.nativeElement === document.activeElement);
            monthView = monthView.nextMonthView;
        }
        if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            let year = this.nextDate.getFullYear();
            let month = this.nextDate.getMonth() + step;
            if (isPageDown) {
                if (month > 11) {
                    month = 0;
                    year += step;
                }
            }
            else {
                if (month < 0) {
                    month = 11;
                    year += step;
                }
            }
            const range = monthRange(this.nextDate.getFullYear(), month);
            let day = this.nextDate.getDate();
            if (day > range[1]) {
                day = range[1];
            }
            this.nextDate.setDate(day);
            this.nextDate.setMonth(month);
            this.nextDate.setFullYear(year);
            this.callback = (next) => {
                monthView = this.daysView;
                let dayItem;
                while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                    dayItem = monthView.dates.find((d) => d.date.date.getTime() === next.getTime());
                    monthView = monthView.nextMonthView;
                }
                if (dayItem && dayItem.isFocusable) {
                    dayItem.nativeElement.focus();
                }
            };
        }
        if (isPageDown) {
            if (event.repeat) {
                requestAnimationFrame(() => this.nextMonth(true));
            }
            else {
                this.nextMonth(true);
            }
        }
        else {
            if (event.repeat) {
                requestAnimationFrame(() => this.previousMonth(true));
            }
            else {
                this.previousMonth(true);
            }
        }
    }
    /**
     * Keyboard navigation of the calendar
     *
     * @hidden
     * @internal
     */
    onKeydownShiftPageUp(event) {
        event.preventDefault();
        if (!this.isDefaultView) {
            return;
        }
        const isPageDown = event.key === 'PageDown';
        const step = isPageDown ? 1 : -1;
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', step);
        this.animationAction = isPageDown ? ScrollMonth.NEXT : ScrollMonth.PREV;
        this.isKeydownTrigger = true;
        let monthView = this.daysView;
        let activeDate;
        while (!activeDate && monthView) {
            activeDate = monthView.dates.find((date) => date.nativeElement === document.activeElement);
            monthView = monthView.nextMonthView;
        }
        if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            const year = this.nextDate.getFullYear() + step;
            const range = monthRange(year, this.nextDate.getMonth());
            let day = this.nextDate.getDate();
            if (day > range[1]) {
                day = range[1];
            }
            this.nextDate.setDate(day);
            this.nextDate.setFullYear(year);
            this.callback = (next) => {
                monthView = this.daysView;
                let dayItem;
                while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                    dayItem = monthView.dates.find((d) => d.date.date.getTime() === next.getTime());
                    monthView = monthView.nextMonthView;
                }
                if (dayItem && dayItem.isFocusable) {
                    dayItem.nativeElement.focus();
                }
            };
        }
    }
    /**
     * Keyboard navigation of the calendar
     *
     * @hidden
     * @internal
     */
    onKeydownHome(event) {
        if (this.daysView) {
            this.daysView.onKeydownHome(event);
        }
    }
    /**
     * Keyboard navigation of the calendar
     *
     * @hidden
     * @internal
     */
    onKeydownEnd(event) {
        if (this.daysView) {
            this.daysView.onKeydownEnd(event);
        }
    }
    /**
     * Stop continuous navigation on mouseup event
     *
     * @hidden
     * @internal
     */
    onMouseUp(event) {
        if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.stopMonthScroll(event);
        }
    }
    ngAfterViewInit() {
        this.setSiblingMonths(this.monthViews);
        this._monthViewsChanges$ = this.monthViews.changes.subscribe(c => {
            this.setSiblingMonths(c);
        });
        this.startMonthScroll$.pipe(takeUntil(this.stopMonthScroll$), switchMap(() => this.scrollMonth$.pipe(skipLast(1), debounce(() => interval(300)), takeUntil(this.stopMonthScroll$)))).subscribe(() => {
            switch (this.monthScrollDirection) {
                case ScrollMonth.PREV:
                    this.previousMonth();
                    break;
                case ScrollMonth.NEXT:
                    this.nextMonth();
                    break;
                case ScrollMonth.NONE:
                default:
                    break;
            }
        });
    }
    /**
     * Returns the locale representation of the month in the month view if enabled,
     * otherwise returns the default `Date.getMonth()` value.
     *
     * @hidden
     * @internal
     */
    formattedMonth(value) {
        if (this.formatViews.month) {
            return this.formatterMonth.format(value);
        }
        return `${value.getMonth()}`;
    }
    /**
     * Change to previous month
     *
     * @hidden
     * @internal
     */
    previousMonth(isKeydownTrigger = false) {
        if (isKeydownTrigger && this.animationAction === ScrollMonth.NEXT) {
            return;
        }
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getPrevMonth(this.viewDate);
        this.animationAction = ScrollMonth.PREV;
        this.isKeydownTrigger = isKeydownTrigger;
    }
    suppressBlur() {
        this.monthViews?.forEach(d => d.shouldResetDate = false);
        if (this.daysView) {
            this.daysView.shouldResetDate = false;
        }
    }
    /**
     * Change to next month
     *
     * @hidden
     * @internal
     */
    nextMonth(isKeydownTrigger = false) {
        if (isKeydownTrigger && this.animationAction === 'prev') {
            return;
        }
        this.isKeydownTrigger = isKeydownTrigger;
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getNextMonth(this.viewDate);
        this.animationAction = ScrollMonth.NEXT;
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewDecade(args, activeViewIdx) {
        super.activeViewDecade(activeViewIdx);
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.date = args;
                this.dacadeView.calendarDir.find(date => date.isCurrentYear).nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewDecadeKB(event, args, activeViewIdx) {
        super.activeViewDecadeKB(event, activeViewIdx);
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.date = args;
                this.dacadeView.calendarDir.find(date => date.isCurrentYear).nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @internal
     */
    getFormattedDate() {
        const date = this.headerDate;
        return {
            monthday: this.formatterMonthday.format(date),
            weekday: this.formatterWeekday.format(date),
        };
    }
    /**
     * Handles invoked on date selection
     *
     * @hidden
     * @internal
     */
    childClicked(instance) {
        if (instance.isPrevMonth) {
            this.previousMonth();
        }
        if (instance.isNextMonth) {
            this.nextMonth();
        }
        // selectDateFromClient is called both here and in days-view.component
        // when multiple months are in view, 'shiftKey' and 'lastSelectedDate'
        // should be set before and after selectDateFromClient
        // in order all views to have the same values for these properties
        this.monthViews.forEach(m => {
            m.shiftKey = this.shiftKey;
            m.lastSelectedDate = this.lastSelectedDate;
        });
        this.selectDateFromClient(instance.date);
        if (this.selection === 'multi' && this._deselectDate) {
            this.deselectDateInMonthViews(instance.date);
        }
        this.selected.emit(this.selectedDates);
        this.monthViews.forEach(m => {
            m.shiftKey = this.shiftKey;
            m.lastSelectedDate = this.lastSelectedDate;
        });
    }
    /**
     * @hidden
     * @internal
     */
    viewChanging(args) {
        this.animationAction = args.monthAction;
        this.isKeydownTrigger = true;
        this.nextDate = args.nextDate;
        this.callback = (next) => {
            const day = this.daysView.dates.find((item) => item.date.date.getTime() === next.getTime());
            if (day) {
                this.daysView.daysNavService.focusNextDate(day.nativeElement, args.key, true);
            }
        };
        this.previousViewDate = this.viewDate;
        this.viewDate = this.nextDate;
    }
    /**
     * @hidden
     * @intenal
     */
    changeMonth(event) {
        this.previousViewDate = this.viewDate;
        this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
        this.activeView = IgxCalendarView.Month;
        requestAnimationFrame(() => {
            const elem = this.monthsBtns.find((e, idx) => idx === this.activeViewIdx);
            if (elem) {
                elem.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewYear(args, activeViewIdx) {
        this.activeView = IgxCalendarView.Year;
        this.activeViewIdx = activeViewIdx;
        requestAnimationFrame(() => {
            this.monthsView.date = args;
            this.focusMonth();
        });
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewYearKB(args, event, activeViewIdx) {
        if (this.platform.isActivationKey(event)) {
            event.preventDefault();
            this.onActiveViewYear(args, activeViewIdx);
        }
    }
    /**
     * Deselects date(s) (based on the selection type).
     *
     * @example
     * ```typescript
     *  this.calendar.deselectDate(new Date(`2018-06-12`));
     * ````
     */
    deselectDate(value) {
        super.deselectDate(value);
        this.monthViews.forEach((view) => {
            view.selectedDates = this.selectedDates;
            view.rangeStarted = false;
        });
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * @hidden
     * @internal
     */
    getViewDate(i) {
        const date = this.calendarModel.timedelta(this.viewDate, 'month', i);
        return date;
    }
    /**
     * Getter for the context object inside the calendar templates.
     *
     * @hidden
     * @internal
     */
    getContext(i) {
        const date = this.getViewDate(i);
        return this.generateContext(date, i);
    }
    /**
     * @hidden
     * @internal
     */
    animationDone(event) {
        if ((event.fromState === ScrollMonth.NONE && (event.toState === ScrollMonth.PREV || event.toState === ScrollMonth.NEXT)) ||
            (event.fromState === 'void' && event.toState === ScrollMonth.NONE)) {
            this.viewDateChanged.emit({ previousValue: this.previousViewDate, currentValue: this.viewDate });
        }
        if (!this.isKeydownTrigger) {
            this.resetActiveDate();
        }
        if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.scrollMonth$.next();
        }
        if (!this.isDefaultView) {
            return;
        }
        let monthView = this.daysView;
        let date = monthView?.dates.find((d) => d.selected);
        while (!date && monthView?.nextMonthView) {
            monthView = monthView.nextMonthView;
            date = monthView.dates.find((d) => d.selected);
        }
        if (date && date.isFocusable && !this.isKeydownTrigger) {
            setTimeout(() => {
                date.nativeElement.focus();
            }, parseInt(slideInRight.options.params.duration, 10));
        }
        else if (this.callback && (event.toState === ScrollMonth.NEXT || event.toState === ScrollMonth.PREV)) {
            this.callback(this.nextDate);
        }
        this.animationAction = ScrollMonth.NONE;
    }
    /**
     * @hidden
     * @internal
     */
    viewRendered(event) {
        if (event.fromState !== 'void') {
            this.activeViewChanged.emit(this.activeView);
            if (this.isDefaultView) {
                this.resetActiveDate();
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    resetActiveDate() {
        if (!this.monthViews) {
            return;
        }
        let dates = [];
        this.monthViews.map(mv => mv.dates).forEach(days => {
            dates = dates.concat(days.toArray());
        });
        const date = dates.find(day => day.selected && day.isCurrentMonth) || dates.find(day => day.isToday && day.isCurrentMonth)
            || dates.find(d => d.isFocusable);
        if (date) {
            this.activeDate = date.date.date.toLocaleDateString();
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        if (this._monthViewsChanges$) {
            this._monthViewsChanges$.unsubscribe();
        }
    }
    /**
     * @hidden
     * @internal
     */
    getPrevMonth(date) {
        return this.calendarModel.getPrevMonth(date);
    }
    /**
     * @hidden
     * @internal
     */
    getNextMonth(date, viewIndex) {
        return this.calendarModel.getDateByView(date, 'Month', viewIndex);
    }
    /**
     * Helper method building and returning the context object inside
     * the calendar templates.
     *
     * @hidden
     * @internal
     */
    generateContext(value, i) {
        const formatObject = {
            index: i,
            monthView: () => this.onActiveViewYear(value, i),
            yearView: () => this.onActiveViewDecade(value, i),
            ...this.calendarModel.formatToParts(value, this.locale, this.formatOptions, ['era', 'year', 'month', 'day', 'weekday'])
        };
        return { $implicit: formatObject };
    }
    /**
     * Helper method that sets references for prev/next months for each month in the view
     *
     * @hidden
     * @internal
     */
    setSiblingMonths(monthViews) {
        monthViews.forEach((item, index) => {
            const prevMonthView = this.getMonthView(index - 1);
            const nextMonthView = this.getMonthView(index + 1);
            item.nextMonthView = nextMonthView;
            item.prevMonthView = prevMonthView;
        });
    }
    /**
     * Helper method returning previous/next day views
     *
     * @hidden
     * @internal
     */
    getMonthView(index) {
        if (index === -1 || index === this.monthViews.length) {
            return null;
        }
        else {
            return this.monthViews.toArray()[index];
        }
    }
    /**
     * Helper method that does deselection for all month views when selection is "multi"
     * If not called, selection in other month views stays
     *
     * @hidden
     * @internal
     */
    deselectDateInMonthViews(value) {
        this.monthViews.forEach(m => {
            m.deselectMultipleInMonth(value);
        });
    }
    focusMonth() {
        const month = this.monthsView.monthsRef.find((e) => e.index === this.monthsView.date.getMonth());
        if (month) {
            month.nativeElement.focus();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxCalendarComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxCalendarComponent, isStandalone: true, selector: "igx-calendar", inputs: { id: "id", hasHeader: "hasHeader", vertical: "vertical", monthsViewNumber: "monthsViewNumber", showWeekNumbers: "showWeekNumbers", animationAction: "animationAction" }, host: { listeners: { "keydown.pagedown": "onKeydownPageDown($event)", "keydown.pageup": "onKeydownPageDown($event)", "keydown.shift.pageup": "onKeydownShiftPageUp($event)", "keydown.shift.pagedown": "onKeydownShiftPageUp($event)", "keydown.home": "onKeydownHome($event)", "keydown.end": "onKeydownEnd($event)", "document:mouseup": "onMouseUp($event)" }, properties: { "attr.id": "this.id", "class.igx-calendar--vertical": "this.styleVerticalClass", "class.igx-calendar": "this.styleClass" } }, providers: [
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxCalendarComponent
            }
        ], queries: [{ propertyName: "headerTemplateDirective", first: true, predicate: i0.forwardRef(function () { return IgxCalendarHeaderTemplateDirective; }), descendants: true, read: IgxCalendarHeaderTemplateDirective, static: true }, { propertyName: "subheaderTemplateDirective", first: true, predicate: i0.forwardRef(function () { return IgxCalendarSubheaderTemplateDirective; }), descendants: true, read: IgxCalendarSubheaderTemplateDirective, static: true }], viewQueries: [{ propertyName: "monthsView", first: true, predicate: ["months"], descendants: true, read: IgxMonthsViewComponent }, { propertyName: "dacadeView", first: true, predicate: ["decade"], descendants: true, read: IgxYearsViewComponent }, { propertyName: "daysView", first: true, predicate: ["days"], descendants: true, read: IgxDaysViewComponent }, { propertyName: "prevMonthBtn", first: true, predicate: ["prevMonthBtn"], descendants: true }, { propertyName: "nextMonthBtn", first: true, predicate: ["nextMonthBtn"], descendants: true }, { propertyName: "monthsBtns", predicate: ["monthsBtn"], descendants: true }, { propertyName: "monthViews", predicate: ["days"], descendants: true, read: IgxDaysViewComponent }], usesInheritance: true, ngImport: i0, template: "<ng-template let-result #defaultHeader>\n    <span>{{ getFormattedDate().weekday }},&nbsp;</span>\n    <span>{{ getFormattedDate().monthday }}</span>\n</ng-template>\n\n<ng-template let-result #defaultMonth let-obj>\n        <span *ngIf=\"monthsViewNumber < 2 || obj.index < 1\" class=\"igx-calendar__aria-off-screen\" aria-live=\"polite\">\n            {{ monthsViewNumber > 1 ? (resourceStrings.igx_calendar_first_picker_of.replace('{0}', monthsViewNumber.toString())  + ' ' + (getViewDate(obj.index) | date: 'LLLL yyyy')) : resourceStrings.igx_calendar_selected_month_is + (getViewDate(obj.index) | date: 'LLLL yyyy')}}\n        </span>\n        <span\n            tabindex=\"0\"\n            role=\"button\"\n            [attr.aria-label]=\"(getViewDate(obj.index) | date: 'LLLL') + ' ' + resourceStrings.igx_calendar_select_month\"\n            #monthsBtn\n            (keydown)=\"onActiveViewYearKB(getViewDate(obj.index), $event, obj.index)\"\n            (click)=\"onActiveViewYear(getViewDate(obj.index), obj.index)\"\n            class=\"igx-calendar-picker__date\">\n            {{ formattedMonth(getViewDate(obj.index)) }}\n        </span>\n\n        <span\n            tabindex=\"0\"\n            role=\"button\"\n            [attr.aria-label]=\"(getViewDate(obj.index) | date: 'yyyy') + ' ' + resourceStrings.igx_calendar_select_year\"\n            #yearsBtn\n            (keydown)=\"onActiveViewDecadeKB($event, getViewDate(obj.index), obj.index)\"\n            (click)=\"onActiveViewDecade(getViewDate(obj.index), obj.index)\"\n            class=\"igx-calendar-picker__date\">\n            {{ formattedYear(getViewDate(obj.index)) }}\n        </span>\n</ng-template>\n\n<header\n    aria-labelledby=\"igx-aria-calendar-title-month igx-aria-calendar-title-year\"\n    class=\"igx-calendar__header\"\n    *ngIf=\"selection === 'single' && hasHeader\">\n\n    <h5 id=\"igx-aria-calendar-title-year\" class=\"igx-calendar__header-year\">\n        {{ formattedYear(headerDate) }}\n    </h5>\n\n    <h2 id=\"igx-aria-calendar-title-month\" class=\"igx-calendar__header-date\">\n        <ng-container *ngTemplateOutlet=\"headerTemplate ? headerTemplate : defaultHeader; context: headerContext\">\n        </ng-container>\n    </h2>\n</header>\n\n<div *ngIf=\"isDefaultView\"  class=\"igx-calendar__body\" [@animateView]=\"activeView\" (@animateView.done)=\"viewRendered($event)\" (swiperight)=\"previousMonth()\"\n    (swipeleft)=\"nextMonth()\" (pointerdown)=\"suppressBlur()\">\n    <section class=\"igx-calendar-picker\">\n        <span tabindex=\"0\" class=\"igx-calendar__aria-off-screen\">\n            <ng-container *ngIf=\"selection === 'multi'\">\n                {{ monthsViewNumber && monthsViewNumber > 1 ?  resourceStrings.igx_calendar_multi_selection.replace('{0}', monthsViewNumber.toString()) : resourceStrings.igx_calendar_singular_multi_selection}}\n            </ng-container>\n            <ng-container *ngIf=\"selection === 'range'\">\n                {{ monthsViewNumber && monthsViewNumber > 1 ?  resourceStrings.igx_calendar_range_selection.replace('{0}', monthsViewNumber.toString()) : resourceStrings.igx_calendar_singular_range_selection}}\n            </ng-container>\n            <ng-container *ngIf=\"selection === 'single'\">\n                {{ monthsViewNumber && monthsViewNumber > 1 ?  resourceStrings.igx_calendar_single_selection.replace('{0}', monthsViewNumber.toString()) : resourceStrings.igx_calendar_singular_single_selection}}\n            </ng-container>\n        </span>\n        <div\n            tabindex=\"0\"\n            class=\"igx-calendar-picker__prev\"\n            role=\"button\"\n            [attr.aria-label]=\"resourceStrings.igx_calendar_previous_month + ', ' + (getPrevMonth(viewDate) | date: 'LLLL')\"\n            data-action=\"prev\"\n            #prevMonthBtn\n            igxCalendarScrollMonth\n            [startScroll]=\"startPrevMonthScroll\"\n            [stopScroll]=\"stopMonthScroll\"\n            [ngStyle]=\"{ 'min-width.%': 100/(monthsViewNumber*7)}\">\n            <igx-icon aria-hidden=\"true\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div class=\"igx-calendar-picker__dates\"\n             *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\"\n             [style.width.%]=\"100/monthsViewNumber\"\n             [attr.data-month]=\"i | IgxGetViewDate:viewDate:false\">\n            <ng-container *ngTemplateOutlet=\"subheaderTemplate ? subheaderTemplate : defaultMonth; context: getContext(i)\">\n            </ng-container>\n        </div>\n        <div\n            tabindex=\"0\"\n            class=\"igx-calendar-picker__next\"\n            role=\"button\"\n            [attr.aria-label]=\"resourceStrings.igx_calendar_next_month + ', ' +  (getNextMonth(viewDate, monthsViewNumber) | date: 'LLLL')\"\n            data-action=\"next\"\n            #nextMonthBtn\n            igxCalendarScrollMonth\n            [startScroll]=\"startNextMonthScroll\"\n            [stopScroll]=\"stopMonthScroll\"\n            [ngStyle]=\"{'min-width.%': 100/(monthsViewNumber*7)}\">\n            <igx-icon aria-hidden=\"true\">keyboard_arrow_right</igx-icon>\n        </div>\n    </section>\n\n    <section style=\"display: flex\"\n        [@animateChange]=\"animationAction\"\n        (@animateChange.done)=\"animationDone($event)\">\n        <igx-days-view role=\"grid\" *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [changeDaysView]=\"true\" #days\n                [selection]=\"selection\"\n                [locale]=\"locale\"\n                [value]=\"value\"\n                [(activeDate)]=\"activeDate\"\n                [viewDate]=\"i | IgxGetViewDate:viewDate\"\n                [weekStart]=\"weekStart\"\n                [formatOptions]=\"formatOptions\"\n                [formatViews]=\"formatViews\"\n                [disabledDates]=\"disabledDates\"\n                [specialDates]=\"specialDates\"\n                [hideOutsideDays]=\"hideOutsideDays\"\n                [showWeekNumbers]=\"showWeekNumbers\"\n                (viewChanging)=\"viewChanging($event)\"\n                (dateSelection)=\"childClicked($event)\"\n                (monthsViewBlur)=\"resetActiveDate()\">\n        </igx-days-view>\n    </section>\n</div>\n\n<igx-months-view *ngIf=\"isYearView\"\n                 [@animateView]=\"activeView\"\n                 #months\n                 (@animateView.done)=\"viewRendered($event)\"\n                 [date]=\"viewDate\"\n                 [locale]=\"locale\"\n                 [formatView]=\"formatViews.month\"\n                 [monthFormat]=\"formatOptions.month\"\n                 (selected)=\"changeMonth($event)\">\n</igx-months-view>\n\n<igx-years-view *ngIf=\"isDecadeView\"\n                [@animateView]=\"activeView\"\n                #decade\n                (@animateView.done)=\"viewRendered($event)\"\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (selected)=\"changeYear($event)\">\n</igx-years-view>\n", dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: IgxCalendarScrollMonthDirective, selector: "[igxCalendarScrollMonth]", inputs: ["startScroll", "stopScroll"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: IgxDaysViewComponent, selector: "igx-days-view", inputs: ["id", "changeDaysView", "showWeekNumbers", "activeDate"], outputs: ["dateSelection", "viewChanging", "activeDateChange", "monthsViewBlur"] }, { kind: "component", type: IgxMonthsViewComponent, selector: "igx-months-view", inputs: ["id", "date", "monthFormat", "locale", "formatView"], outputs: ["selected"] }, { kind: "component", type: IgxYearsViewComponent, selector: "igx-years-view", inputs: ["formatView", "date", "yearFormat", "locale"], outputs: ["selected"] }, { kind: "pipe", type: DatePipe, name: "date" }, { kind: "pipe", type: IgxMonthViewSlotsCalendar, name: "IgxMonthViewSlots" }, { kind: "pipe", type: IgxGetViewDateCalendar, name: "IgxGetViewDate" }], animations: [
            trigger('animateView', [
                transition('void => 0', useAnimation(fadeIn)),
                transition('void => *', useAnimation(scaleInCenter, {
                    params: {
                        duration: '.2s',
                        fromScale: .9
                    }
                }))
            ]),
            trigger('animateChange', [
                transition('* => prev', useAnimation(slideInLeft, {
                    params: {
                        fromPosition: 'translateX(-30%)'
                    }
                })),
                transition('* => next', useAnimation(slideInRight, {
                    params: {
                        fromPosition: 'translateX(30%)'
                    }
                }))
            ])
        ] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxCalendarComponent, decorators: [{
            type: Component,
            args: [{ providers: [
                        {
                            multi: true,
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IgxCalendarComponent
                        }
                    ], animations: [
                        trigger('animateView', [
                            transition('void => 0', useAnimation(fadeIn)),
                            transition('void => *', useAnimation(scaleInCenter, {
                                params: {
                                    duration: '.2s',
                                    fromScale: .9
                                }
                            }))
                        ]),
                        trigger('animateChange', [
                            transition('* => prev', useAnimation(slideInLeft, {
                                params: {
                                    fromPosition: 'translateX(-30%)'
                                }
                            })),
                            transition('* => next', useAnimation(slideInRight, {
                                params: {
                                    fromPosition: 'translateX(30%)'
                                }
                            }))
                        ])
                    ], selector: 'igx-calendar', standalone: true, imports: [NgIf, NgTemplateOutlet, IgxCalendarScrollMonthDirective, NgStyle, IgxIconComponent, NgFor, IgxDaysViewComponent, IgxMonthsViewComponent, IgxYearsViewComponent, DatePipe, IgxMonthViewSlotsCalendar, IgxGetViewDateCalendar], template: "<ng-template let-result #defaultHeader>\n    <span>{{ getFormattedDate().weekday }},&nbsp;</span>\n    <span>{{ getFormattedDate().monthday }}</span>\n</ng-template>\n\n<ng-template let-result #defaultMonth let-obj>\n        <span *ngIf=\"monthsViewNumber < 2 || obj.index < 1\" class=\"igx-calendar__aria-off-screen\" aria-live=\"polite\">\n            {{ monthsViewNumber > 1 ? (resourceStrings.igx_calendar_first_picker_of.replace('{0}', monthsViewNumber.toString())  + ' ' + (getViewDate(obj.index) | date: 'LLLL yyyy')) : resourceStrings.igx_calendar_selected_month_is + (getViewDate(obj.index) | date: 'LLLL yyyy')}}\n        </span>\n        <span\n            tabindex=\"0\"\n            role=\"button\"\n            [attr.aria-label]=\"(getViewDate(obj.index) | date: 'LLLL') + ' ' + resourceStrings.igx_calendar_select_month\"\n            #monthsBtn\n            (keydown)=\"onActiveViewYearKB(getViewDate(obj.index), $event, obj.index)\"\n            (click)=\"onActiveViewYear(getViewDate(obj.index), obj.index)\"\n            class=\"igx-calendar-picker__date\">\n            {{ formattedMonth(getViewDate(obj.index)) }}\n        </span>\n\n        <span\n            tabindex=\"0\"\n            role=\"button\"\n            [attr.aria-label]=\"(getViewDate(obj.index) | date: 'yyyy') + ' ' + resourceStrings.igx_calendar_select_year\"\n            #yearsBtn\n            (keydown)=\"onActiveViewDecadeKB($event, getViewDate(obj.index), obj.index)\"\n            (click)=\"onActiveViewDecade(getViewDate(obj.index), obj.index)\"\n            class=\"igx-calendar-picker__date\">\n            {{ formattedYear(getViewDate(obj.index)) }}\n        </span>\n</ng-template>\n\n<header\n    aria-labelledby=\"igx-aria-calendar-title-month igx-aria-calendar-title-year\"\n    class=\"igx-calendar__header\"\n    *ngIf=\"selection === 'single' && hasHeader\">\n\n    <h5 id=\"igx-aria-calendar-title-year\" class=\"igx-calendar__header-year\">\n        {{ formattedYear(headerDate) }}\n    </h5>\n\n    <h2 id=\"igx-aria-calendar-title-month\" class=\"igx-calendar__header-date\">\n        <ng-container *ngTemplateOutlet=\"headerTemplate ? headerTemplate : defaultHeader; context: headerContext\">\n        </ng-container>\n    </h2>\n</header>\n\n<div *ngIf=\"isDefaultView\"  class=\"igx-calendar__body\" [@animateView]=\"activeView\" (@animateView.done)=\"viewRendered($event)\" (swiperight)=\"previousMonth()\"\n    (swipeleft)=\"nextMonth()\" (pointerdown)=\"suppressBlur()\">\n    <section class=\"igx-calendar-picker\">\n        <span tabindex=\"0\" class=\"igx-calendar__aria-off-screen\">\n            <ng-container *ngIf=\"selection === 'multi'\">\n                {{ monthsViewNumber && monthsViewNumber > 1 ?  resourceStrings.igx_calendar_multi_selection.replace('{0}', monthsViewNumber.toString()) : resourceStrings.igx_calendar_singular_multi_selection}}\n            </ng-container>\n            <ng-container *ngIf=\"selection === 'range'\">\n                {{ monthsViewNumber && monthsViewNumber > 1 ?  resourceStrings.igx_calendar_range_selection.replace('{0}', monthsViewNumber.toString()) : resourceStrings.igx_calendar_singular_range_selection}}\n            </ng-container>\n            <ng-container *ngIf=\"selection === 'single'\">\n                {{ monthsViewNumber && monthsViewNumber > 1 ?  resourceStrings.igx_calendar_single_selection.replace('{0}', monthsViewNumber.toString()) : resourceStrings.igx_calendar_singular_single_selection}}\n            </ng-container>\n        </span>\n        <div\n            tabindex=\"0\"\n            class=\"igx-calendar-picker__prev\"\n            role=\"button\"\n            [attr.aria-label]=\"resourceStrings.igx_calendar_previous_month + ', ' + (getPrevMonth(viewDate) | date: 'LLLL')\"\n            data-action=\"prev\"\n            #prevMonthBtn\n            igxCalendarScrollMonth\n            [startScroll]=\"startPrevMonthScroll\"\n            [stopScroll]=\"stopMonthScroll\"\n            [ngStyle]=\"{ 'min-width.%': 100/(monthsViewNumber*7)}\">\n            <igx-icon aria-hidden=\"true\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div class=\"igx-calendar-picker__dates\"\n             *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\"\n             [style.width.%]=\"100/monthsViewNumber\"\n             [attr.data-month]=\"i | IgxGetViewDate:viewDate:false\">\n            <ng-container *ngTemplateOutlet=\"subheaderTemplate ? subheaderTemplate : defaultMonth; context: getContext(i)\">\n            </ng-container>\n        </div>\n        <div\n            tabindex=\"0\"\n            class=\"igx-calendar-picker__next\"\n            role=\"button\"\n            [attr.aria-label]=\"resourceStrings.igx_calendar_next_month + ', ' +  (getNextMonth(viewDate, monthsViewNumber) | date: 'LLLL')\"\n            data-action=\"next\"\n            #nextMonthBtn\n            igxCalendarScrollMonth\n            [startScroll]=\"startNextMonthScroll\"\n            [stopScroll]=\"stopMonthScroll\"\n            [ngStyle]=\"{'min-width.%': 100/(monthsViewNumber*7)}\">\n            <igx-icon aria-hidden=\"true\">keyboard_arrow_right</igx-icon>\n        </div>\n    </section>\n\n    <section style=\"display: flex\"\n        [@animateChange]=\"animationAction\"\n        (@animateChange.done)=\"animationDone($event)\">\n        <igx-days-view role=\"grid\" *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [changeDaysView]=\"true\" #days\n                [selection]=\"selection\"\n                [locale]=\"locale\"\n                [value]=\"value\"\n                [(activeDate)]=\"activeDate\"\n                [viewDate]=\"i | IgxGetViewDate:viewDate\"\n                [weekStart]=\"weekStart\"\n                [formatOptions]=\"formatOptions\"\n                [formatViews]=\"formatViews\"\n                [disabledDates]=\"disabledDates\"\n                [specialDates]=\"specialDates\"\n                [hideOutsideDays]=\"hideOutsideDays\"\n                [showWeekNumbers]=\"showWeekNumbers\"\n                (viewChanging)=\"viewChanging($event)\"\n                (dateSelection)=\"childClicked($event)\"\n                (monthsViewBlur)=\"resetActiveDate()\">\n        </igx-days-view>\n    </section>\n</div>\n\n<igx-months-view *ngIf=\"isYearView\"\n                 [@animateView]=\"activeView\"\n                 #months\n                 (@animateView.done)=\"viewRendered($event)\"\n                 [date]=\"viewDate\"\n                 [locale]=\"locale\"\n                 [formatView]=\"formatViews.month\"\n                 [monthFormat]=\"formatOptions.month\"\n                 (selected)=\"changeMonth($event)\">\n</igx-months-view>\n\n<igx-years-view *ngIf=\"isDecadeView\"\n                [@animateView]=\"activeView\"\n                #decade\n                (@animateView.done)=\"viewRendered($event)\"\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (selected)=\"changeYear($event)\">\n</igx-years-view>\n" }]
        }], propDecorators: { id: [{
                type: HostBinding,
                args: ['attr.id']
            }, {
                type: Input
            }], hasHeader: [{
                type: Input
            }], vertical: [{
                type: Input
            }], monthsViewNumber: [{
                type: Input
            }], showWeekNumbers: [{
                type: Input
            }], animationAction: [{
                type: Input
            }], styleVerticalClass: [{
                type: HostBinding,
                args: ['class.igx-calendar--vertical']
            }], styleClass: [{
                type: HostBinding,
                args: ['class.igx-calendar']
            }], monthsView: [{
                type: ViewChild,
                args: ['months', { read: IgxMonthsViewComponent }]
            }], monthsBtns: [{
                type: ViewChildren,
                args: ['monthsBtn']
            }], dacadeView: [{
                type: ViewChild,
                args: ['decade', { read: IgxYearsViewComponent }]
            }], daysView: [{
                type: ViewChild,
                args: ['days', { read: IgxDaysViewComponent }]
            }], monthViews: [{
                type: ViewChildren,
                args: ['days', { read: IgxDaysViewComponent }]
            }], prevMonthBtn: [{
                type: ViewChild,
                args: ['prevMonthBtn']
            }], nextMonthBtn: [{
                type: ViewChild,
                args: ['nextMonthBtn']
            }], headerTemplateDirective: [{
                type: ContentChild,
                args: [forwardRef(() => IgxCalendarHeaderTemplateDirective), { read: IgxCalendarHeaderTemplateDirective, static: true }]
            }], subheaderTemplateDirective: [{
                type: ContentChild,
                args: [forwardRef(() => IgxCalendarSubheaderTemplateDirective), { read: IgxCalendarSubheaderTemplateDirective, static: true }]
            }], onKeydownPageDown: [{
                type: HostListener,
                args: ['keydown.pagedown', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.pageup', ['$event']]
            }], onKeydownShiftPageUp: [{
                type: HostListener,
                args: ['keydown.shift.pageup', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.shift.pagedown', ['$event']]
            }], onKeydownHome: [{
                type: HostListener,
                args: ['keydown.home', ['$event']]
            }], onKeydownEnd: [{
                type: HostListener,
                args: ['keydown.end', ['$event']]
            }], onMouseUp: [{
                type: HostListener,
                args: ['document:mouseup', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2NhbGVuZGFyL2NhbGVuZGFyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9jYWxlbmRhci9jYWxlbmRhci5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN4RSxPQUFPLEVBQ0gsU0FBUyxFQUNULFlBQVksRUFDWixVQUFVLEVBQ1YsV0FBVyxFQUNYLFlBQVksRUFDWixLQUFLLEVBQ0wsU0FBUyxFQUdULFlBQVksRUFHZixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsTUFBTSxFQUFFLGFBQWEsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDdEYsT0FBTyxFQUFFLGtDQUFrQyxFQUFFLHFDQUFxQyxFQUFFLCtCQUErQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDbkosT0FBTyxFQUFpQixlQUFlLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNyRixPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUMvRSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUM3RSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUMxRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUN2RSxPQUFPLEVBQUUsUUFBUSxFQUFnQixNQUFNLE1BQU0s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LElBQUksRUFBRztnQkFrRDlILGlCQUFpQjtzQkFGdkIsWUFBWTt1QkFBQyxrQkFBa0IsRUFBRSxDQUFDLFFBQVEsQ0FBQzs7c0JBQzNDLFlBQVk7dUJBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxRQUFRLENBQUM7Z0JBZ0ZuQyxvQkFBb0I7c0JBRjFCLFlBQVk7dUJBQUMsc0JBQXNCLEVBQUUsQ0FBQyxRQUFRLENBQUM7O3NCQUMvQyxZQUFZO3VCQUFDLHdCQUF3QixFQUFFLENBQUMsUUFBUSxDQUFDO2dCQTREM0MsYUFBYTtzQkFEbkIsWUFBWTt1QkFBQyxjQUFjLEVBQUUsQ0FBQyxRQUFRLENBQUM7Z0JBY2pDLFlBQVk7c0JBRGxCLFlBQVk7dUJBQUMsYUFBYSxFQUFFLENBQUMsUUFBUSxDQUFDO2dCQWNoQyxTQUFTO3NCQURmLFlBQVk7dUJBQUMsa0JBQWtCLEVBQUUsQ0FBQyxRQUFRLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0cmFuc2l0aW9uLCB0cmlnZ2VyLCB1c2VBbmltYXRpb24gfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBmb3J3YXJkUmVmLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBJbnB1dCxcbiAgICBWaWV3Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIFZpZXdDaGlsZHJlbixcbiAgICBRdWVyeUxpc3QsXG4gICAgT25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBmYWRlSW4sIHNjYWxlSW5DZW50ZXIsIHNsaWRlSW5MZWZ0LCBzbGlkZUluUmlnaHQgfSBmcm9tICcuLi9hbmltYXRpb25zL21haW4nO1xuaW1wb3J0IHsgSWd4Q2FsZW5kYXJIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4Q2FsZW5kYXJTdWJoZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4Q2FsZW5kYXJTY3JvbGxNb250aERpcmVjdGl2ZSB9IGZyb20gJy4vY2FsZW5kYXIuZGlyZWN0aXZlcyc7XG5pbXBvcnQgeyBJQ2FsZW5kYXJEYXRlLCBJZ3hDYWxlbmRhclZpZXcsIFNjcm9sbE1vbnRoLCBtb250aFJhbmdlIH0gZnJvbSAnLi9jYWxlbmRhcic7XG5pbXBvcnQgeyBJZ3hNb250aFBpY2tlckJhc2VEaXJlY3RpdmUgfSBmcm9tICcuL21vbnRoLXBpY2tlci9tb250aC1waWNrZXItYmFzZSc7XG5pbXBvcnQgeyBJZ3hNb250aHNWaWV3Q29tcG9uZW50IH0gZnJvbSAnLi9tb250aHMtdmlldy9tb250aHMtdmlldy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4WWVhcnNWaWV3Q29tcG9uZW50IH0gZnJvbSAnLi95ZWFycy12aWV3L3llYXJzLXZpZXcuY29tcG9uZW50JztcbmltcG9ydCB7IElneERheXNWaWV3Q29tcG9uZW50IH0gZnJvbSAnLi9kYXlzLXZpZXcvZGF5cy12aWV3LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBpbnRlcnZhbCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwsIGRlYm91bmNlLCBza2lwTGFzdCwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSVZpZXdDaGFuZ2luZ0V2ZW50QXJncyB9IGZyb20gJy4vZGF5cy12aWV3L2RheXMtdmlldy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSWd4TW9udGhWaWV3U2xvdHNDYWxlbmRhciwgSWd4R2V0Vmlld0RhdGVDYWxlbmRhciB9IGZyb20gJy4vbW9udGhzLXZpZXcucGlwZSc7XG5pbXBvcnQgeyBJZ3hJY29uQ29tcG9uZW50IH0gZnJvbSAnLi4vaWNvbi9pY29uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOZ0lmLCBOZ1RlbXBsYXRlT3V0bGV0LCBOZ1N0eWxlLCBOZ0ZvciwgRGF0ZVBpcGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5sZXQgTkVYVF9JRCA9IDA7XG5cbi8qKlxuICogQ2FsZW5kYXIgcHJvdmlkZXMgYSB3YXkgdG8gZGlzcGxheSBkYXRlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBpZ3hNb2R1bGUgSWd4Q2FsZW5kYXJNb2R1bGVcbiAqXG4gKiBAaWd4VGhlbWUgaWd4LWNhbGVuZGFyLXRoZW1lLCBpZ3gtaWNvbi10aGVtZVxuICpcbiAqIEBpZ3hLZXl3b3JkcyBjYWxlbmRhciwgZGF0ZXBpY2tlciwgc2NoZWR1bGUsIGRhdGVcbiAqXG4gKiBAaWd4R3JvdXAgU2NoZWR1bGluZ1xuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgSWduaXRlIFVJIENhbGVuZGFyIHByb3ZpZGVzIGFuIGVhc3kgd2F5IHRvIGRpc3BsYXkgYSBjYWxlbmRhciBhbmQgYWxsb3cgdXNlcnMgdG8gc2VsZWN0IGRhdGVzIHVzaW5nIHNpbmdsZSwgbXVsdGlwbGVcbiAqIG9yIHJhbmdlIHNlbGVjdGlvbi5cbiAqXG4gKiBAZXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtY2FsZW5kYXIgc2VsZWN0aW9uPVwicmFuZ2VcIj48L2lneC1jYWxlbmRhcj5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBJZ3hDYWxlbmRhckNvbXBvbmVudFxuICAgICAgICB9XG4gICAgXSxcbiAgICBhbmltYXRpb25zOiBbXG4gICAgICAgIHRyaWdnZXIoJ2FuaW1hdGVWaWV3JywgW1xuICAgICAgICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiAwJywgdXNlQW5pbWF0aW9uKGZhZGVJbikpLFxuICAgICAgICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgdXNlQW5pbWF0aW9uKHNjYWxlSW5DZW50ZXIsIHtcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246ICcuMnMnLFxuICAgICAgICAgICAgICAgICAgICBmcm9tU2NhbGU6IC45XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgIF0pLFxuICAgICAgICB0cmlnZ2VyKCdhbmltYXRlQ2hhbmdlJywgW1xuICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiBwcmV2JywgdXNlQW5pbWF0aW9uKHNsaWRlSW5MZWZ0LCB7XG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21Qb3NpdGlvbjogJ3RyYW5zbGF0ZVgoLTMwJSknXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiBuZXh0JywgdXNlQW5pbWF0aW9uKHNsaWRlSW5SaWdodCwge1xuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBmcm9tUG9zaXRpb246ICd0cmFuc2xhdGVYKDMwJSknXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgIF0pXG4gICAgXSxcbiAgICBzZWxlY3RvcjogJ2lneC1jYWxlbmRhcicsXG4gICAgdGVtcGxhdGVVcmw6ICdjYWxlbmRhci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbTmdJZiwgTmdUZW1wbGF0ZU91dGxldCwgSWd4Q2FsZW5kYXJTY3JvbGxNb250aERpcmVjdGl2ZSwgTmdTdHlsZSwgSWd4SWNvbkNvbXBvbmVudCwgTmdGb3IsIElneERheXNWaWV3Q29tcG9uZW50LCBJZ3hNb250aHNWaWV3Q29tcG9uZW50LCBJZ3hZZWFyc1ZpZXdDb21wb25lbnQsIERhdGVQaXBlLCBJZ3hNb250aFZpZXdTbG90c0NhbGVuZGFyLCBJZ3hHZXRWaWV3RGF0ZUNhbGVuZGFyXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hDYWxlbmRhckNvbXBvbmVudCBleHRlbmRzIElneE1vbnRoUGlja2VyQmFzZURpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgaWRgIG9mIHRoZSBjYWxlbmRhci5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgbm90IHNldCwgdGhlIGBpZGAgd2lsbCBoYXZlIHZhbHVlIGBcImlneC1jYWxlbmRhci0wXCJgLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jYWxlbmRhciBpZD1cIm15LWZpcnN0LWNhbGVuZGFyXCI+PC9pZ3gtY2FsZW5kYXI+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENhbGVuZGFyQ29tcG9uZW50XG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZCA9IGBpZ3gtY2FsZW5kYXItJHtORVhUX0lEKyt9YDtcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjYWxlbmRhciBoYXMgaGVhZGVyLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYHRydWVgLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jYWxlbmRhciBbaGFzSGVhZGVyXT1cImZhbHNlXCI+PC9pZ3gtY2FsZW5kYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaGFzSGVhZGVyID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB3aGV0aGVyIHRoZSBjYWxlbmRhciBoZWFkZXIgd2lsbCBiZSBpbiB2ZXJ0aWNhbCBwb3NpdGlvbi5cbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNhbGVuZGFyIFt2ZXJ0aWNhbF0gPSBcInRydWVcIj48L2lneC1jYWxlbmRhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB2ZXJ0aWNhbCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBudW1iZXIgb2YgbW9udGggdmlld3MgZGlzcGxheWVkLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYDFgLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jYWxlbmRhciBbbW9udGhzVmlld051bWJlcl09XCIyXCI+PC9pZ3gtY2FsZW5kYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IG1vbnRoc1ZpZXdOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNWaWV3TnVtYmVyO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgbW9udGhzVmlld051bWJlcih2YWw6IG51bWJlcikge1xuICAgICAgICBpZiAodmFsIDwgMSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1ZpZXdOdW1iZXIgPSB2YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdy9oaWRlIHdlZWsgbnVtYmVyc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jYWxlbmRhciBbc2hvd1dlZWtOdW1iZXJzXT1cInRydWVcIj48L2lneC1jYWxlbmRhcj5cbiAgICAgKiBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNob3dXZWVrTnVtYmVycyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIGRpZmZlcmVudCBzdGF0ZXMgZm9yIHRoZSB0cmFuc2l0aW9ucyBvZiBhbmltYXRlQ2hhbmdlXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgYW5pbWF0aW9uQWN0aW9uOiBhbnkgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGNzcyBjbGFzcyBhcHBsaWVkIHRvIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtY2FsZW5kYXItLXZlcnRpY2FsJylcbiAgICBwdWJsaWMgZ2V0IHN0eWxlVmVydGljYWxDbGFzcygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljYWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY3NzIGNsYXNzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jYWxlbmRhcicpXG4gICAgcHVibGljIHN0eWxlQ2xhc3MgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVmlld0NoaWxkIHRoYXQgcmVwcmVzZW50cyB0aGUgbW9udGhzIHZpZXcuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnbW9udGhzJywgeyByZWFkOiBJZ3hNb250aHNWaWV3Q29tcG9uZW50IH0pXG4gICAgcHVibGljIG1vbnRoc1ZpZXc6IElneE1vbnRoc1ZpZXdDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBNb250aCBidXR0b24sIHRoYXQgZGlzcGxheXMgdGhlIG1vbnRocyB2aWV3LlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGRyZW4oJ21vbnRoc0J0bicpXG4gICAgcHVibGljIG1vbnRoc0J0bnM6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPjtcblxuICAgIC8qKlxuICAgICAqIFZpZXdDaGlsZCB0aGF0IHJlcHJlc2VudHMgdGhlIGRlY2FkZSB2aWV3LlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2RlY2FkZScsIHsgcmVhZDogSWd4WWVhcnNWaWV3Q29tcG9uZW50IH0pXG4gICAgcHVibGljIGRhY2FkZVZpZXc6IElneFllYXJzVmlld0NvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIFZpZXdDaGlsZCB0aGF0IHJlcHJlc2VudHMgdGhlIGRheXMgdmlldy5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdkYXlzJywgeyByZWFkOiBJZ3hEYXlzVmlld0NvbXBvbmVudCB9KVxuICAgIHB1YmxpYyBkYXlzVmlldzogSWd4RGF5c1ZpZXdDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBWaWV3Q2hpbGRyZW5kZW4gcmVwcmVzZW50aW5nIGFsbCBvZiB0aGUgcmVuZGVyZWQgZGF5cyB2aWV3cy5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkcmVuKCdkYXlzJywgeyByZWFkOiBJZ3hEYXlzVmlld0NvbXBvbmVudCB9KVxuICAgIHB1YmxpYyBtb250aFZpZXdzOiBRdWVyeUxpc3Q8SWd4RGF5c1ZpZXdDb21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgICogQnV0dG9uIGZvciBwcmV2aW91cyBtb250aC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdwcmV2TW9udGhCdG4nKVxuICAgIHB1YmxpYyBwcmV2TW9udGhCdG46IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBCdXR0b24gZm9yIG5leHQgbW9udGguXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnbmV4dE1vbnRoQnRuJylcbiAgICBwdWJsaWMgbmV4dE1vbnRoQnRuOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogRGVub3RlIGlmIHRoZSB5ZWFyIHZpZXcgaXMgYWN0aXZlLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaXNZZWFyVmlldygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVmlldyA9PT0gSWd4Q2FsZW5kYXJWaWV3LlllYXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGVhZGVyIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGhlYWRlclRlbXBsYXRlID0gIHRoaXMuY2FsZW5kYXIuaGVhZGVyVGVhbXBsYXRlO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDYWxlbmRhckNvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaGVhZGVyVGVtcGxhdGUoKTogYW55IHtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlYWRlciB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY2FsZW5kYXIgaGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUgPSBcImlneENhbGVuZGFySGVhZGVyXCI+PC9pZ3gtY2FsZW5kYXI+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneENhbGVuZGFyQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBoZWFkZXJUZW1wbGF0ZShkaXJlY3RpdmU6IGFueSkge1xuICAgICAgICB0aGlzLmhlYWRlclRlbXBsYXRlRGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN1YmhlYWRlciB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzdWJoZWFkZXJUZW1wbGF0ZSA9IHRoaXMuY2FsZW5kYXIuc3ViaGVhZGVyVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBzdWJoZWFkZXJUZW1wbGF0ZSgpOiBhbnkge1xuICAgICAgICBpZiAodGhpcy5zdWJoZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViaGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3ViaGVhZGVyIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jYWxlbmRhciBzdWJoZWFkZXJUZW1wbGF0ZSA9IFwiaWd4Q2FsZW5kYXJTdWJoZWFkZXJcIj48L2lneC1jYWxlbmRhcj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q2FsZW5kYXJDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHN1YmhlYWRlclRlbXBsYXRlKGRpcmVjdGl2ZTogYW55KSB7XG4gICAgICAgIHRoaXMuc3ViaGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUgPSBkaXJlY3RpdmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY29udGV4dCBmb3IgdGhlIHRlbXBsYXRlIG1hcmtlZCB3aXRoIHRoZSBgaWd4Q2FsZW5kYXJIZWFkZXJgIGRpcmVjdGl2ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBoZWFkZXJDb250ZXh0ID0gIHRoaXMuY2FsZW5kYXIuaGVhZGVyQ29udGV4dDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGhlYWRlckNvbnRleHQoKSB7XG4gICAgICAgIGNvbnN0IGRhdGU6IERhdGUgPSB0aGlzLmhlYWRlckRhdGU7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQ29udGV4dChkYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb250ZXh0IGZvciB0aGUgdGVtcGxhdGUgbWFya2VkIHdpdGggZWl0aGVyIGBpZ3hDYWxlbmRhclN1YkhlYWRlck1vbnRoYFxuICAgICAqIG9yIGBpZ3hDYWxlbmRhclN1YkhlYWRlclllYXJgIGRpcmVjdGl2ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb250ZXh0ID0gIHRoaXMuY2FsZW5kYXIuY29udGV4dDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNvbnRleHQoKSB7XG4gICAgICAgIGNvbnN0IGRhdGU6IERhdGUgPSB0aGlzLnZpZXdEYXRlO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUNvbnRleHQoZGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGF0ZSBkaXNwbGF5ZWQgaW4gaGVhZGVyXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBoZWFkZXJEYXRlKCk6IERhdGUge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZERhdGVzID8gdGhpcy5zZWxlY3RlZERhdGVzIDogbmV3IERhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChmb3J3YXJkUmVmKCgpID0+IElneENhbGVuZGFySGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUpLCB7IHJlYWQ6IElneENhbGVuZGFySGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsIHN0YXRpYzogdHJ1ZSAgfSlcbiAgICBwcml2YXRlIGhlYWRlclRlbXBsYXRlRGlyZWN0aXZlOiBJZ3hDYWxlbmRhckhlYWRlclRlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgQENvbnRlbnRDaGlsZChmb3J3YXJkUmVmKCgpID0+IElneENhbGVuZGFyU3ViaGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUpLCB7IHJlYWQ6IElneENhbGVuZGFyU3ViaGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsIHN0YXRpYzogdHJ1ZSAgfSlcbiAgICBwcml2YXRlIHN1YmhlYWRlclRlbXBsYXRlRGlyZWN0aXZlOiBJZ3hDYWxlbmRhclN1YmhlYWRlclRlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBhY3RpdmVEYXRlID0gbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gYXBwbHkgdGhlIGFjdGl2ZSBkYXRlIHdoZW4gdGhlIGNhbGVuZGFyIHZpZXcgaXMgY2hhbmdlZFxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBuZXh0RGF0ZTogRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIERlbm90ZSBpZiB0aGUgY2FsZW5kYXIgdmlldyB3YXMgY2hhbmdlZCB3aXRoIHRoZSBrZXlib2FyZFxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBpc0tleWRvd25UcmlnZ2VyID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGNhbGxiYWNrOiAobmV4dCkgPT4gdm9pZDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcml2YXRlIF9tb250aHNWaWV3TnVtYmVyID0gMTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHJpdmF0ZSBfbW9udGhWaWV3c0NoYW5nZXMkOiBTdWJzY3JpcHRpb247XG5cbiAgICAvKipcbiAgICAgKiBLZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSBjYWxlbmRhclxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24ucGFnZWRvd24nLCBbJyRldmVudCddKVxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24ucGFnZXVwJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25LZXlkb3duUGFnZURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRGVmYXVsdFZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzUGFnZURvd24gPSBldmVudC5rZXkgPT09ICdQYWdlRG93bic7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBpc1BhZ2VEb3duID8gMSA6IC0xO1xuICAgICAgICBsZXQgbW9udGhWaWV3ID0gdGhpcy5kYXlzVmlldyBhcyBJZ3hEYXlzVmlld0NvbXBvbmVudDtcbiAgICAgICAgbGV0IGFjdGl2ZURhdGU7XG5cbiAgICAgICAgd2hpbGUgKCFhY3RpdmVEYXRlICYmIG1vbnRoVmlldykge1xuICAgICAgICAgICAgYWN0aXZlRGF0ZSA9IG1vbnRoVmlldy5kYXRlcy5maW5kKChkYXRlKSA9PiBkYXRlLm5hdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgbW9udGhWaWV3ID0gbW9udGhWaWV3Lm5leHRNb250aFZpZXc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aXZlRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0RGF0ZSA9IG5ldyBEYXRlKGFjdGl2ZURhdGUuZGF0ZS5kYXRlKTtcblxuICAgICAgICAgICAgbGV0IHllYXIgPSB0aGlzLm5leHREYXRlLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgICAgIGxldCBtb250aCA9IHRoaXMubmV4dERhdGUuZ2V0TW9udGgoKSArIHN0ZXA7XG4gICAgICAgICAgICBpZiAoaXNQYWdlRG93bikge1xuICAgICAgICAgICAgICAgIGlmIChtb250aCA+IDExKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID0gMDsgeWVhciArPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBtb250aCA9IDExOyB5ZWFyICs9IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IG1vbnRoUmFuZ2UodGhpcy5uZXh0RGF0ZS5nZXRGdWxsWWVhcigpLCBtb250aCk7XG5cbiAgICAgICAgICAgIGxldCBkYXkgPSB0aGlzLm5leHREYXRlLmdldERhdGUoKTtcbiAgICAgICAgICAgIGlmIChkYXkgPiByYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgIGRheSA9IHJhbmdlWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm5leHREYXRlLnNldERhdGUoZGF5KTtcbiAgICAgICAgICAgIHRoaXMubmV4dERhdGUuc2V0TW9udGgobW9udGgpO1xuICAgICAgICAgICAgdGhpcy5uZXh0RGF0ZS5zZXRGdWxsWWVhcih5ZWFyKTtcblxuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IChuZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgbW9udGhWaWV3ID0gdGhpcy5kYXlzVmlldyBhcyBJZ3hEYXlzVmlld0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBsZXQgZGF5SXRlbTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKCFkYXlJdGVtICYmIG1vbnRoVmlldykgfHwgKGRheUl0ZW0gJiYgIWRheUl0ZW0uaXNDdXJyZW50TW9udGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheUl0ZW0gPSBtb250aFZpZXcuZGF0ZXMuZmluZCgoZCkgPT4gZC5kYXRlLmRhdGUuZ2V0VGltZSgpID09PSBuZXh0LmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoVmlldyA9IG1vbnRoVmlldy5uZXh0TW9udGhWaWV3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF5SXRlbSAmJiBkYXlJdGVtLmlzRm9jdXNhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheUl0ZW0ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQYWdlRG93bikge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnJlcGVhdCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLm5leHRNb250aCh0cnVlKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dE1vbnRoKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnJlcGVhdCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnByZXZpb3VzTW9udGgodHJ1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzTW9udGgodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBLZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSBjYWxlbmRhclxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uc2hpZnQucGFnZXVwJywgWyckZXZlbnQnXSlcbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLnNoaWZ0LnBhZ2Vkb3duJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25LZXlkb3duU2hpZnRQYWdlVXAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNEZWZhdWx0Vmlldykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNQYWdlRG93biA9IGV2ZW50LmtleSA9PT0gJ1BhZ2VEb3duJztcbiAgICAgICAgY29uc3Qgc3RlcCA9IGlzUGFnZURvd24gPyAxIDogLTE7XG4gICAgICAgIHRoaXMucHJldmlvdXNWaWV3RGF0ZSA9IHRoaXMudmlld0RhdGU7XG4gICAgICAgIHRoaXMudmlld0RhdGUgPSB0aGlzLmNhbGVuZGFyTW9kZWwudGltZWRlbHRhKHRoaXMudmlld0RhdGUsICd5ZWFyJywgc3RlcCk7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25BY3Rpb24gPSBpc1BhZ2VEb3duID8gU2Nyb2xsTW9udGguTkVYVCA6IFNjcm9sbE1vbnRoLlBSRVY7XG4gICAgICAgIHRoaXMuaXNLZXlkb3duVHJpZ2dlciA9IHRydWU7XG5cbiAgICAgICAgbGV0IG1vbnRoVmlldyA9IHRoaXMuZGF5c1ZpZXcgYXMgSWd4RGF5c1ZpZXdDb21wb25lbnQ7XG4gICAgICAgIGxldCBhY3RpdmVEYXRlO1xuXG4gICAgICAgIHdoaWxlICghYWN0aXZlRGF0ZSAmJiBtb250aFZpZXcpIHtcbiAgICAgICAgICAgIGFjdGl2ZURhdGUgPSBtb250aFZpZXcuZGF0ZXMuZmluZCgoZGF0ZSkgPT4gZGF0ZS5uYXRpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIG1vbnRoVmlldyA9IG1vbnRoVmlldy5uZXh0TW9udGhWaWV3O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGl2ZURhdGUpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dERhdGUgPSBuZXcgRGF0ZShhY3RpdmVEYXRlLmRhdGUuZGF0ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHllYXIgPSB0aGlzLm5leHREYXRlLmdldEZ1bGxZZWFyKCkgKyBzdGVwO1xuXG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IG1vbnRoUmFuZ2UoeWVhciwgdGhpcy5uZXh0RGF0ZS5nZXRNb250aCgpKTtcblxuICAgICAgICAgICAgbGV0IGRheSA9IHRoaXMubmV4dERhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICAgICAgaWYgKGRheSA+IHJhbmdlWzFdKSB7XG4gICAgICAgICAgICAgICAgZGF5ID0gcmFuZ2VbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubmV4dERhdGUuc2V0RGF0ZShkYXkpO1xuICAgICAgICAgICAgdGhpcy5uZXh0RGF0ZS5zZXRGdWxsWWVhcih5ZWFyKTtcblxuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IChuZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgbW9udGhWaWV3ID0gdGhpcy5kYXlzVmlldyBhcyBJZ3hEYXlzVmlld0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBsZXQgZGF5SXRlbTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKCFkYXlJdGVtICYmIG1vbnRoVmlldykgfHwgKGRheUl0ZW0gJiYgIWRheUl0ZW0uaXNDdXJyZW50TW9udGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheUl0ZW0gPSBtb250aFZpZXcuZGF0ZXMuZmluZCgoZCkgPT4gZC5kYXRlLmRhdGUuZ2V0VGltZSgpID09PSBuZXh0LmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoVmlldyA9IG1vbnRoVmlldy5uZXh0TW9udGhWaWV3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF5SXRlbSAmJiBkYXlJdGVtLmlzRm9jdXNhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheUl0ZW0ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBLZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSBjYWxlbmRhclxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uaG9tZScsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uS2V5ZG93bkhvbWUoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF5c1ZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuZGF5c1ZpZXcub25LZXlkb3duSG9tZShldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBLZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSBjYWxlbmRhclxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uZW5kJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25LZXlkb3duRW5kKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRheXNWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLmRheXNWaWV3Lm9uS2V5ZG93bkVuZChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdG9wIGNvbnRpbnVvdXMgbmF2aWdhdGlvbiBvbiBtb3VzZXVwIGV2ZW50XG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6bW91c2V1cCcsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uTW91c2VVcChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5tb250aFNjcm9sbERpcmVjdGlvbiAhPT0gU2Nyb2xsTW9udGguTk9ORSkge1xuICAgICAgICAgICAgdGhpcy5zdG9wTW9udGhTY3JvbGwoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZXRTaWJsaW5nTW9udGhzKHRoaXMubW9udGhWaWV3cyk7XG4gICAgICAgIHRoaXMuX21vbnRoVmlld3NDaGFuZ2VzJCA9IHRoaXMubW9udGhWaWV3cy5jaGFuZ2VzLnN1YnNjcmliZShjID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2libGluZ01vbnRocyhjKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zdGFydE1vbnRoU2Nyb2xsJC5waXBlKFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuc3RvcE1vbnRoU2Nyb2xsJCksXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKCkgPT4gdGhpcy5zY3JvbGxNb250aCQucGlwZShcbiAgICAgICAgICAgICAgICBza2lwTGFzdCgxKSxcbiAgICAgICAgICAgICAgICBkZWJvdW5jZSgoKSA9PiBpbnRlcnZhbCgzMDApKSxcbiAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5zdG9wTW9udGhTY3JvbGwkKVxuICAgICAgICAgICAgKSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1vbnRoU2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU2Nyb2xsTW9udGguUFJFVjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNNb250aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU2Nyb2xsTW9udGguTkVYVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dE1vbnRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTY3JvbGxNb250aC5OT05FOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2NhbGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1vbnRoIGluIHRoZSBtb250aCB2aWV3IGlmIGVuYWJsZWQsXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgdGhlIGRlZmF1bHQgYERhdGUuZ2V0TW9udGgoKWAgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGZvcm1hdHRlZE1vbnRoKHZhbHVlOiBEYXRlKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0Vmlld3MubW9udGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlck1vbnRoLmZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlLmdldE1vbnRoKCl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdG8gcHJldmlvdXMgbW9udGhcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgcHJldmlvdXNNb250aChpc0tleWRvd25UcmlnZ2VyID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGlzS2V5ZG93blRyaWdnZXIgJiYgdGhpcy5hbmltYXRpb25BY3Rpb24gPT09IFNjcm9sbE1vbnRoLk5FWFQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZpb3VzVmlld0RhdGUgPSB0aGlzLnZpZXdEYXRlO1xuICAgICAgICB0aGlzLnZpZXdEYXRlID0gdGhpcy5jYWxlbmRhck1vZGVsLmdldFByZXZNb250aCh0aGlzLnZpZXdEYXRlKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25BY3Rpb24gPSBTY3JvbGxNb250aC5QUkVWO1xuICAgICAgICB0aGlzLmlzS2V5ZG93blRyaWdnZXIgPSBpc0tleWRvd25UcmlnZ2VyO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwcmVzc0JsdXIoKSB7XG4gICAgICAgIHRoaXMubW9udGhWaWV3cz8uZm9yRWFjaChkID0+IGQuc2hvdWxkUmVzZXREYXRlID0gZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5kYXlzVmlldykge1xuICAgICAgICAgICAgdGhpcy5kYXlzVmlldy5zaG91bGRSZXNldERhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0byBuZXh0IG1vbnRoXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG5leHRNb250aChpc0tleWRvd25UcmlnZ2VyID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGlzS2V5ZG93blRyaWdnZXIgJiYgdGhpcy5hbmltYXRpb25BY3Rpb24gPT09ICdwcmV2Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNLZXlkb3duVHJpZ2dlciA9IGlzS2V5ZG93blRyaWdnZXI7XG4gICAgICAgIHRoaXMucHJldmlvdXNWaWV3RGF0ZSA9IHRoaXMudmlld0RhdGU7XG4gICAgICAgIHRoaXMudmlld0RhdGUgPSB0aGlzLmNhbGVuZGFyTW9kZWwuZ2V0TmV4dE1vbnRoKHRoaXMudmlld0RhdGUpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkFjdGlvbiA9IFNjcm9sbE1vbnRoLk5FWFQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udGluaW91cyBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIHByZXZpb3VzIG1vbnRoc1xuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGFydFByZXZNb250aFNjcm9sbCA9IChpc0tleWRvd25UcmlnZ2VyID0gZmFsc2UpID0+IHtcbiAgICAgICAgdGhpcy5zdGFydE1vbnRoU2Nyb2xsJC5uZXh0KCk7XG4gICAgICAgIHRoaXMubW9udGhTY3JvbGxEaXJlY3Rpb24gPSBTY3JvbGxNb250aC5QUkVWO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkFjdGlvbiA9IFNjcm9sbE1vbnRoLlBSRVY7XG4gICAgICAgIHRoaXMucHJldmlvdXNNb250aChpc0tleWRvd25UcmlnZ2VyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGluaW91cyBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIG5leHQgbW9udGhzXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHN0YXJ0TmV4dE1vbnRoU2Nyb2xsID0gKGlzS2V5ZG93blRyaWdnZXIgPSBmYWxzZSkgPT4ge1xuICAgICAgICB0aGlzLnN0YXJ0TW9udGhTY3JvbGwkLm5leHQoKTtcbiAgICAgICAgdGhpcy5tb250aFNjcm9sbERpcmVjdGlvbiA9IFNjcm9sbE1vbnRoLk5FWFQ7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQWN0aW9uID0gU2Nyb2xsTW9udGguTkVYVDtcbiAgICAgICAgdGhpcy5uZXh0TW9udGgoaXNLZXlkb3duVHJpZ2dlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN0b3AgY29udGludW91cyBuYXZpZ2F0aW9uXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHN0b3BNb250aFNjcm9sbCA9IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAvLyBnZW5lcmFsbHkgdGhlIHNjcm9sbGluZyBpcyBidWlsdCBvbiB0aGUgY2FsZW5kYXIgY29tcG9uZW50XG4gICAgICAgIC8vIGFuZCBhbGwgc3RhcnQvc3RvcCBzY3JvbGxpbmcgbWV0aG9kcyBhcmUgY2FsbGVkIG9uIHRoZSBjYWxlbmRhclxuICAgICAgICAvLyBpZiB3ZSBjaGFuZ2UgYmVsb3cgbGluZXMgdG8gY2FsbCBzdG9wTW9udGhTY3JvbGwkIG9uIHRoZSBjYWxlbmRhciBpbnN0ZWFkIG9mIG9uIHRoZSB2aWV3cyxcbiAgICAgICAgLy8gc3RyYW5nZSBidWcgaXMgaW50cm9kdWNlZCAtLT4gYWZ0ZXIgY2hhbmdpbmcgbnVtYmVyIG9mIG1vbnRocywgY29udGludW91cyBzY3JvbGxpbmcgb24gbW91c2UgY2xpY2sgZG9lcyBub3QgaGFwcGVuXG4gICAgICAgIHRoaXMuZGF5c1ZpZXcuc3RvcE1vbnRoU2Nyb2xsJC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLmRheXNWaWV3LnN0b3BNb250aFNjcm9sbCQuY29tcGxldGUoKTtcblxuXG4gICAgICAgIGlmICh0aGlzLm1vbnRoU2Nyb2xsRGlyZWN0aW9uID09PSBTY3JvbGxNb250aC5QUkVWKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZNb250aEJ0bi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tb250aFNjcm9sbERpcmVjdGlvbiA9PT0gU2Nyb2xsTW9udGguTkVYVCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0TW9udGhCdG4ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBsYXRmb3JtLmlzQWN0aXZhdGlvbktleShldmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRBY3RpdmVEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vbnRoU2Nyb2xsRGlyZWN0aW9uID0gU2Nyb2xsTW9udGguTk9ORTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvbkFjdGl2ZVZpZXdEZWNhZGUoYXJnczogRGF0ZSwgYWN0aXZlVmlld0lkeDogbnVtYmVyKSB7XG4gICAgICAgIHN1cGVyLmFjdGl2ZVZpZXdEZWNhZGUoYWN0aXZlVmlld0lkeCk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYWNhZGVWaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYWNhZGVWaWV3LmRhdGUgPSBhcmdzO1xuICAgICAgICAgICAgICAgIHRoaXMuZGFjYWRlVmlldy5jYWxlbmRhckRpci5maW5kKGRhdGUgPT4gZGF0ZS5pc0N1cnJlbnRZZWFyKS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25BY3RpdmVWaWV3RGVjYWRlS0IoZXZlbnQsIGFyZ3M6IERhdGUsIGFjdGl2ZVZpZXdJZHg6IG51bWJlcikge1xuICAgICAgICBzdXBlci5hY3RpdmVWaWV3RGVjYWRlS0IoZXZlbnQsIGFjdGl2ZVZpZXdJZHgpO1xuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYWNhZGVWaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYWNhZGVWaWV3LmRhdGUgPSBhcmdzO1xuICAgICAgICAgICAgICAgIHRoaXMuZGFjYWRlVmlldy5jYWxlbmRhckRpci5maW5kKGRhdGUgPT4gZGF0ZS5pc0N1cnJlbnRZZWFyKS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Rm9ybWF0dGVkRGF0ZSgpOiB7IHdlZWtkYXk6IHN0cmluZzsgbW9udGhkYXk6IHN0cmluZyB9IHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuaGVhZGVyRGF0ZTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9udGhkYXk6IHRoaXMuZm9ybWF0dGVyTW9udGhkYXkuZm9ybWF0KGRhdGUpLFxuICAgICAgICAgICAgd2Vla2RheTogdGhpcy5mb3JtYXR0ZXJXZWVrZGF5LmZvcm1hdChkYXRlKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGludm9rZWQgb24gZGF0ZSBzZWxlY3Rpb25cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgY2hpbGRDbGlja2VkKGluc3RhbmNlOiBJQ2FsZW5kYXJEYXRlKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5pc1ByZXZNb250aCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c01vbnRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zdGFuY2UuaXNOZXh0TW9udGgpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dE1vbnRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWxlY3REYXRlRnJvbUNsaWVudCBpcyBjYWxsZWQgYm90aCBoZXJlIGFuZCBpbiBkYXlzLXZpZXcuY29tcG9uZW50XG4gICAgICAgIC8vIHdoZW4gbXVsdGlwbGUgbW9udGhzIGFyZSBpbiB2aWV3LCAnc2hpZnRLZXknIGFuZCAnbGFzdFNlbGVjdGVkRGF0ZSdcbiAgICAgICAgLy8gc2hvdWxkIGJlIHNldCBiZWZvcmUgYW5kIGFmdGVyIHNlbGVjdERhdGVGcm9tQ2xpZW50XG4gICAgICAgIC8vIGluIG9yZGVyIGFsbCB2aWV3cyB0byBoYXZlIHRoZSBzYW1lIHZhbHVlcyBmb3IgdGhlc2UgcHJvcGVydGllc1xuICAgICAgICB0aGlzLm1vbnRoVmlld3MuZm9yRWFjaChtID0+IHtcbiAgICAgICAgICAgIG0uc2hpZnRLZXkgPSB0aGlzLnNoaWZ0S2V5O1xuICAgICAgICAgICAgbS5sYXN0U2VsZWN0ZWREYXRlID0gdGhpcy5sYXN0U2VsZWN0ZWREYXRlO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNlbGVjdERhdGVGcm9tQ2xpZW50KGluc3RhbmNlLmRhdGUpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24gPT09ICdtdWx0aScgJiYgdGhpcy5fZGVzZWxlY3REYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0RGF0ZUluTW9udGhWaWV3cyhpbnN0YW5jZS5kYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGVkLmVtaXQodGhpcy5zZWxlY3RlZERhdGVzKTtcblxuICAgICAgICB0aGlzLm1vbnRoVmlld3MuZm9yRWFjaChtID0+IHtcbiAgICAgICAgICAgIG0uc2hpZnRLZXkgPSB0aGlzLnNoaWZ0S2V5O1xuICAgICAgICAgICAgbS5sYXN0U2VsZWN0ZWREYXRlID0gdGhpcy5sYXN0U2VsZWN0ZWREYXRlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHZpZXdDaGFuZ2luZyhhcmdzOiBJVmlld0NoYW5naW5nRXZlbnRBcmdzKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQWN0aW9uID0gYXJncy5tb250aEFjdGlvbjtcbiAgICAgICAgdGhpcy5pc0tleWRvd25UcmlnZ2VyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uZXh0RGF0ZSA9IGFyZ3MubmV4dERhdGU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSAobmV4dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF5ID0gdGhpcy5kYXlzVmlldy5kYXRlcy5maW5kKChpdGVtKSA9PiBpdGVtLmRhdGUuZGF0ZS5nZXRUaW1lKCkgPT09IG5leHQuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIGlmIChkYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRheXNWaWV3LmRheXNOYXZTZXJ2aWNlLmZvY3VzTmV4dERhdGUoZGF5Lm5hdGl2ZUVsZW1lbnQsIGFyZ3Mua2V5LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1ZpZXdEYXRlID0gdGhpcy52aWV3RGF0ZTtcbiAgICAgICAgdGhpcy52aWV3RGF0ZSA9IHRoaXMubmV4dERhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlbmFsXG4gICAgICovXG4gICAgcHVibGljIGNoYW5nZU1vbnRoKGV2ZW50OiBEYXRlKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNWaWV3RGF0ZSA9IHRoaXMudmlld0RhdGU7XG4gICAgICAgIHRoaXMudmlld0RhdGUgPSB0aGlzLmNhbGVuZGFyTW9kZWwuZ2V0Rmlyc3RWaWV3RGF0ZShldmVudCwgJ21vbnRoJywgdGhpcy5hY3RpdmVWaWV3SWR4KTtcbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3ID0gSWd4Q2FsZW5kYXJWaWV3Lk1vbnRoO1xuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtID0gdGhpcy5tb250aHNCdG5zLmZpbmQoKGU6IEVsZW1lbnRSZWYsIGlkeDogbnVtYmVyKSA9PiBpZHggPT09IHRoaXMuYWN0aXZlVmlld0lkeCk7XG4gICAgICAgICAgICBpZiAoZWxlbSkge1xuICAgICAgICAgICAgICAgIGVsZW0ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG9uQWN0aXZlVmlld1llYXIoYXJnczogRGF0ZSwgYWN0aXZlVmlld0lkeDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IElneENhbGVuZGFyVmlldy5ZZWFyO1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXdJZHggPSBhY3RpdmVWaWV3SWR4O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb250aHNWaWV3LmRhdGUgPSBhcmdzO1xuICAgICAgICAgICAgdGhpcy5mb2N1c01vbnRoKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25BY3RpdmVWaWV3WWVhcktCKGFyZ3M6IERhdGUsIGV2ZW50OiBLZXlib2FyZEV2ZW50LCBhY3RpdmVWaWV3SWR4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0uaXNBY3RpdmF0aW9uS2V5KGV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMub25BY3RpdmVWaWV3WWVhcihhcmdzLCBhY3RpdmVWaWV3SWR4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyBkYXRlKHMpIChiYXNlZCBvbiB0aGUgc2VsZWN0aW9uIHR5cGUpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogIHRoaXMuY2FsZW5kYXIuZGVzZWxlY3REYXRlKG5ldyBEYXRlKGAyMDE4LTA2LTEyYCkpO1xuICAgICAqIGBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZGVzZWxlY3REYXRlKHZhbHVlPzogRGF0ZSB8IERhdGVbXSkge1xuICAgICAgICBzdXBlci5kZXNlbGVjdERhdGUodmFsdWUpO1xuXG4gICAgICAgIHRoaXMubW9udGhWaWV3cy5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICB2aWV3LnNlbGVjdGVkRGF0ZXMgPSB0aGlzLnNlbGVjdGVkRGF0ZXM7XG4gICAgICAgICAgICB2aWV3LnJhbmdlU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjayh0aGlzLnNlbGVjdGVkRGF0ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Vmlld0RhdGUoaTogbnVtYmVyKTogRGF0ZSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLmNhbGVuZGFyTW9kZWwudGltZWRlbHRhKHRoaXMudmlld0RhdGUsICdtb250aCcsIGkpO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXR0ZXIgZm9yIHRoZSBjb250ZXh0IG9iamVjdCBpbnNpZGUgdGhlIGNhbGVuZGFyIHRlbXBsYXRlcy5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q29udGV4dChpOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuZ2V0Vmlld0RhdGUoaSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQ29udGV4dChkYXRlLCBpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGFuaW1hdGlvbkRvbmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKChldmVudC5mcm9tU3RhdGUgPT09IFNjcm9sbE1vbnRoLk5PTkUgJiYgKGV2ZW50LnRvU3RhdGUgPT09IFNjcm9sbE1vbnRoLlBSRVYgfHwgZXZlbnQudG9TdGF0ZSA9PT0gU2Nyb2xsTW9udGguTkVYVCkpIHx8XG4gICAgICAgICAgICAgKGV2ZW50LmZyb21TdGF0ZSA9PT0gJ3ZvaWQnICYmIGV2ZW50LnRvU3RhdGUgPT09IFNjcm9sbE1vbnRoLk5PTkUpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdEYXRlQ2hhbmdlZC5lbWl0KHsgcHJldmlvdXNWYWx1ZTogdGhpcy5wcmV2aW91c1ZpZXdEYXRlLCBjdXJyZW50VmFsdWU6IHRoaXMudmlld0RhdGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzS2V5ZG93blRyaWdnZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRBY3RpdmVEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tb250aFNjcm9sbERpcmVjdGlvbiAhPT0gU2Nyb2xsTW9udGguTk9ORSkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxNb250aCQubmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRGVmYXVsdFZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtb250aFZpZXcgPSB0aGlzLmRheXNWaWV3IGFzIElneERheXNWaWV3Q29tcG9uZW50O1xuICAgICAgICBsZXQgZGF0ZSA9IG1vbnRoVmlldz8uZGF0ZXMuZmluZCgoZCkgPT4gZC5zZWxlY3RlZCk7XG5cbiAgICAgICAgd2hpbGUgKCFkYXRlICYmIG1vbnRoVmlldz8ubmV4dE1vbnRoVmlldykge1xuICAgICAgICAgICAgbW9udGhWaWV3ID0gbW9udGhWaWV3Lm5leHRNb250aFZpZXc7XG4gICAgICAgICAgICBkYXRlID0gbW9udGhWaWV3LmRhdGVzLmZpbmQoKGQpID0+IGQuc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlICYmIGRhdGUuaXNGb2N1c2FibGUgJiYgIXRoaXMuaXNLZXlkb3duVHJpZ2dlcikge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGF0ZS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB9LCBwYXJzZUludChzbGlkZUluUmlnaHQub3B0aW9ucy5wYXJhbXMuZHVyYXRpb24sIDEwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jYWxsYmFjayAmJiAoZXZlbnQudG9TdGF0ZSA9PT0gU2Nyb2xsTW9udGguTkVYVCB8fCBldmVudC50b1N0YXRlID09PSBTY3JvbGxNb250aC5QUkVWKSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm5leHREYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFuaW1hdGlvbkFjdGlvbiA9IFNjcm9sbE1vbnRoLk5PTkU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyB2aWV3UmVuZGVyZWQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmZyb21TdGF0ZSAhPT0gJ3ZvaWQnKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVZpZXdDaGFuZ2VkLmVtaXQodGhpcy5hY3RpdmVWaWV3KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGVmYXVsdFZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QWN0aXZlRGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyByZXNldEFjdGl2ZURhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb250aFZpZXdzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGVzID0gW107XG4gICAgICAgIHRoaXMubW9udGhWaWV3cy5tYXAobXYgPT4gbXYuZGF0ZXMpLmZvckVhY2goZGF5cyA9PiB7XG4gICAgICAgICAgICBkYXRlcyA9IGRhdGVzLmNvbmNhdChkYXlzLnRvQXJyYXkoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkYXRlID0gZGF0ZXMuZmluZChkYXkgPT4gZGF5LnNlbGVjdGVkICYmIGRheS5pc0N1cnJlbnRNb250aCkgfHwgZGF0ZXMuZmluZChkYXkgPT4gZGF5LmlzVG9kYXkgJiYgZGF5LmlzQ3VycmVudE1vbnRoKVxuICAgICAgICAgICAgfHwgZGF0ZXMuZmluZChkID0+IGQuaXNGb2N1c2FibGUpO1xuICAgICAgICBpZiAoZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gZGF0ZS5kYXRlLmRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhWaWV3c0NoYW5nZXMkKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aFZpZXdzQ2hhbmdlcyQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0UHJldk1vbnRoKGRhdGUpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJNb2RlbC5nZXRQcmV2TW9udGgoZGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXROZXh0TW9udGgoZGF0ZSwgdmlld0luZGV4KTogRGF0ZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyTW9kZWwuZ2V0RGF0ZUJ5VmlldyhkYXRlLCAnTW9udGgnLCB2aWV3SW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgYnVpbGRpbmcgYW5kIHJldHVybmluZyB0aGUgY29udGV4dCBvYmplY3QgaW5zaWRlXG4gICAgICogdGhlIGNhbGVuZGFyIHRlbXBsYXRlcy5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcml2YXRlIGdlbmVyYXRlQ29udGV4dCh2YWx1ZTogRGF0ZSwgaT86IG51bWJlcikge1xuICAgICAgICBjb25zdCBmb3JtYXRPYmplY3QgPSB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIG1vbnRoVmlldzogKCkgPT4gdGhpcy5vbkFjdGl2ZVZpZXdZZWFyKHZhbHVlLCBpKSxcbiAgICAgICAgICAgIHllYXJWaWV3OiAoKSA9PiB0aGlzLm9uQWN0aXZlVmlld0RlY2FkZSh2YWx1ZSwgaSksXG4gICAgICAgICAgICAuLi50aGlzLmNhbGVuZGFyTW9kZWwuZm9ybWF0VG9QYXJ0cyh2YWx1ZSwgdGhpcy5sb2NhbGUsIHRoaXMuZm9ybWF0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICBbJ2VyYScsICd5ZWFyJywgJ21vbnRoJywgJ2RheScsICd3ZWVrZGF5J10pXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7ICRpbXBsaWNpdDogZm9ybWF0T2JqZWN0IH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0aGF0IHNldHMgcmVmZXJlbmNlcyBmb3IgcHJldi9uZXh0IG1vbnRocyBmb3IgZWFjaCBtb250aCBpbiB0aGUgdmlld1xuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0U2libGluZ01vbnRocyhtb250aFZpZXdzOiBRdWVyeUxpc3Q8SWd4RGF5c1ZpZXdDb21wb25lbnQ+KSB7XG4gICAgICAgIG1vbnRoVmlld3MuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZNb250aFZpZXcgPSB0aGlzLmdldE1vbnRoVmlldyhpbmRleCAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbmV4dE1vbnRoVmlldyA9IHRoaXMuZ2V0TW9udGhWaWV3KGluZGV4ICsgMSk7XG4gICAgICAgICAgICBpdGVtLm5leHRNb250aFZpZXcgPSBuZXh0TW9udGhWaWV3O1xuICAgICAgICAgICAgaXRlbS5wcmV2TW9udGhWaWV3ID0gcHJldk1vbnRoVmlldztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCByZXR1cm5pbmcgcHJldmlvdXMvbmV4dCBkYXkgdmlld3NcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldE1vbnRoVmlldyhpbmRleDogbnVtYmVyKTogSWd4RGF5c1ZpZXdDb21wb25lbnQge1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xIHx8IGluZGV4ID09PSB0aGlzLm1vbnRoVmlld3MubGVuZ3RoICkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb250aFZpZXdzLnRvQXJyYXkoKVtpbmRleF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRoYXQgZG9lcyBkZXNlbGVjdGlvbiBmb3IgYWxsIG1vbnRoIHZpZXdzIHdoZW4gc2VsZWN0aW9uIGlzIFwibXVsdGlcIlxuICAgICAqIElmIG5vdCBjYWxsZWQsIHNlbGVjdGlvbiBpbiBvdGhlciBtb250aCB2aWV3cyBzdGF5c1xuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByaXZhdGUgZGVzZWxlY3REYXRlSW5Nb250aFZpZXdzKHZhbHVlOiBEYXRlKSB7XG4gICAgICAgIHRoaXMubW9udGhWaWV3cy5mb3JFYWNoKG0gPT4ge1xuICAgICAgICAgICAgbS5kZXNlbGVjdE11bHRpcGxlSW5Nb250aCh2YWx1ZSk7XG4gICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGZvY3VzTW9udGgoKSB7XG4gICAgICAgIGNvbnN0IG1vbnRoID0gdGhpcy5tb250aHNWaWV3Lm1vbnRoc1JlZi5maW5kKChlKSA9PlxuICAgICAgICAgICAgZS5pbmRleCA9PT0gdGhpcy5tb250aHNWaWV3LmRhdGUuZ2V0TW9udGgoKSk7XG4gICAgICAgIGlmIChtb250aCkge1xuICAgICAgICAgICAgbW9udGgubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiPG5nLXRlbXBsYXRlIGxldC1yZXN1bHQgI2RlZmF1bHRIZWFkZXI+XG4gICAgPHNwYW4+e3sgZ2V0Rm9ybWF0dGVkRGF0ZSgpLndlZWtkYXkgfX0sJm5ic3A7PC9zcGFuPlxuICAgIDxzcGFuPnt7IGdldEZvcm1hdHRlZERhdGUoKS5tb250aGRheSB9fTwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSBsZXQtcmVzdWx0ICNkZWZhdWx0TW9udGggbGV0LW9iaj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJtb250aHNWaWV3TnVtYmVyIDwgMiB8fCBvYmouaW5kZXggPCAxXCIgY2xhc3M9XCJpZ3gtY2FsZW5kYXJfX2FyaWEtb2ZmLXNjcmVlblwiIGFyaWEtbGl2ZT1cInBvbGl0ZVwiPlxuICAgICAgICAgICAge3sgbW9udGhzVmlld051bWJlciA+IDEgPyAocmVzb3VyY2VTdHJpbmdzLmlneF9jYWxlbmRhcl9maXJzdF9waWNrZXJfb2YucmVwbGFjZSgnezB9JywgbW9udGhzVmlld051bWJlci50b1N0cmluZygpKSAgKyAnICcgKyAoZ2V0Vmlld0RhdGUob2JqLmluZGV4KSB8IGRhdGU6ICdMTExMIHl5eXknKSkgOiByZXNvdXJjZVN0cmluZ3MuaWd4X2NhbGVuZGFyX3NlbGVjdGVkX21vbnRoX2lzICsgKGdldFZpZXdEYXRlKG9iai5pbmRleCkgfCBkYXRlOiAnTExMTCB5eXl5Jyl9fVxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxzcGFuXG4gICAgICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIihnZXRWaWV3RGF0ZShvYmouaW5kZXgpIHwgZGF0ZTogJ0xMTEwnKSArICcgJyArIHJlc291cmNlU3RyaW5ncy5pZ3hfY2FsZW5kYXJfc2VsZWN0X21vbnRoXCJcbiAgICAgICAgICAgICNtb250aHNCdG5cbiAgICAgICAgICAgIChrZXlkb3duKT1cIm9uQWN0aXZlVmlld1llYXJLQihnZXRWaWV3RGF0ZShvYmouaW5kZXgpLCAkZXZlbnQsIG9iai5pbmRleClcIlxuICAgICAgICAgICAgKGNsaWNrKT1cIm9uQWN0aXZlVmlld1llYXIoZ2V0Vmlld0RhdGUob2JqLmluZGV4KSwgb2JqLmluZGV4KVwiXG4gICAgICAgICAgICBjbGFzcz1cImlneC1jYWxlbmRhci1waWNrZXJfX2RhdGVcIj5cbiAgICAgICAgICAgIHt7IGZvcm1hdHRlZE1vbnRoKGdldFZpZXdEYXRlKG9iai5pbmRleCkpIH19XG4gICAgICAgIDwvc3Bhbj5cblxuICAgICAgICA8c3BhblxuICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCIoZ2V0Vmlld0RhdGUob2JqLmluZGV4KSB8IGRhdGU6ICd5eXl5JykgKyAnICcgKyByZXNvdXJjZVN0cmluZ3MuaWd4X2NhbGVuZGFyX3NlbGVjdF95ZWFyXCJcbiAgICAgICAgICAgICN5ZWFyc0J0blxuICAgICAgICAgICAgKGtleWRvd24pPVwib25BY3RpdmVWaWV3RGVjYWRlS0IoJGV2ZW50LCBnZXRWaWV3RGF0ZShvYmouaW5kZXgpLCBvYmouaW5kZXgpXCJcbiAgICAgICAgICAgIChjbGljayk9XCJvbkFjdGl2ZVZpZXdEZWNhZGUoZ2V0Vmlld0RhdGUob2JqLmluZGV4KSwgb2JqLmluZGV4KVwiXG4gICAgICAgICAgICBjbGFzcz1cImlneC1jYWxlbmRhci1waWNrZXJfX2RhdGVcIj5cbiAgICAgICAgICAgIHt7IGZvcm1hdHRlZFllYXIoZ2V0Vmlld0RhdGUob2JqLmluZGV4KSkgfX1cbiAgICAgICAgPC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5cblxuPGhlYWRlclxuICAgIGFyaWEtbGFiZWxsZWRieT1cImlneC1hcmlhLWNhbGVuZGFyLXRpdGxlLW1vbnRoIGlneC1hcmlhLWNhbGVuZGFyLXRpdGxlLXllYXJcIlxuICAgIGNsYXNzPVwiaWd4LWNhbGVuZGFyX19oZWFkZXJcIlxuICAgICpuZ0lmPVwic2VsZWN0aW9uID09PSAnc2luZ2xlJyAmJiBoYXNIZWFkZXJcIj5cblxuICAgIDxoNSBpZD1cImlneC1hcmlhLWNhbGVuZGFyLXRpdGxlLXllYXJcIiBjbGFzcz1cImlneC1jYWxlbmRhcl9faGVhZGVyLXllYXJcIj5cbiAgICAgICAge3sgZm9ybWF0dGVkWWVhcihoZWFkZXJEYXRlKSB9fVxuICAgIDwvaDU+XG5cbiAgICA8aDIgaWQ9XCJpZ3gtYXJpYS1jYWxlbmRhci10aXRsZS1tb250aFwiIGNsYXNzPVwiaWd4LWNhbGVuZGFyX19oZWFkZXItZGF0ZVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiaGVhZGVyVGVtcGxhdGUgPyBoZWFkZXJUZW1wbGF0ZSA6IGRlZmF1bHRIZWFkZXI7IGNvbnRleHQ6IGhlYWRlckNvbnRleHRcIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9oMj5cbjwvaGVhZGVyPlxuXG48ZGl2ICpuZ0lmPVwiaXNEZWZhdWx0Vmlld1wiICBjbGFzcz1cImlneC1jYWxlbmRhcl9fYm9keVwiIFtAYW5pbWF0ZVZpZXddPVwiYWN0aXZlVmlld1wiIChAYW5pbWF0ZVZpZXcuZG9uZSk9XCJ2aWV3UmVuZGVyZWQoJGV2ZW50KVwiIChzd2lwZXJpZ2h0KT1cInByZXZpb3VzTW9udGgoKVwiXG4gICAgKHN3aXBlbGVmdCk9XCJuZXh0TW9udGgoKVwiIChwb2ludGVyZG93bik9XCJzdXBwcmVzc0JsdXIoKVwiPlxuICAgIDxzZWN0aW9uIGNsYXNzPVwiaWd4LWNhbGVuZGFyLXBpY2tlclwiPlxuICAgICAgICA8c3BhbiB0YWJpbmRleD1cIjBcIiBjbGFzcz1cImlneC1jYWxlbmRhcl9fYXJpYS1vZmYtc2NyZWVuXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwic2VsZWN0aW9uID09PSAnbXVsdGknXCI+XG4gICAgICAgICAgICAgICAge3sgbW9udGhzVmlld051bWJlciAmJiBtb250aHNWaWV3TnVtYmVyID4gMSA/ICByZXNvdXJjZVN0cmluZ3MuaWd4X2NhbGVuZGFyX211bHRpX3NlbGVjdGlvbi5yZXBsYWNlKCd7MH0nLCBtb250aHNWaWV3TnVtYmVyLnRvU3RyaW5nKCkpIDogcmVzb3VyY2VTdHJpbmdzLmlneF9jYWxlbmRhcl9zaW5ndWxhcl9tdWx0aV9zZWxlY3Rpb259fVxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwic2VsZWN0aW9uID09PSAncmFuZ2UnXCI+XG4gICAgICAgICAgICAgICAge3sgbW9udGhzVmlld051bWJlciAmJiBtb250aHNWaWV3TnVtYmVyID4gMSA/ICByZXNvdXJjZVN0cmluZ3MuaWd4X2NhbGVuZGFyX3JhbmdlX3NlbGVjdGlvbi5yZXBsYWNlKCd7MH0nLCBtb250aHNWaWV3TnVtYmVyLnRvU3RyaW5nKCkpIDogcmVzb3VyY2VTdHJpbmdzLmlneF9jYWxlbmRhcl9zaW5ndWxhcl9yYW5nZV9zZWxlY3Rpb259fVxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwic2VsZWN0aW9uID09PSAnc2luZ2xlJ1wiPlxuICAgICAgICAgICAgICAgIHt7IG1vbnRoc1ZpZXdOdW1iZXIgJiYgbW9udGhzVmlld051bWJlciA+IDEgPyAgcmVzb3VyY2VTdHJpbmdzLmlneF9jYWxlbmRhcl9zaW5nbGVfc2VsZWN0aW9uLnJlcGxhY2UoJ3swfScsIG1vbnRoc1ZpZXdOdW1iZXIudG9TdHJpbmcoKSkgOiByZXNvdXJjZVN0cmluZ3MuaWd4X2NhbGVuZGFyX3Npbmd1bGFyX3NpbmdsZV9zZWxlY3Rpb259fVxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgIGNsYXNzPVwiaWd4LWNhbGVuZGFyLXBpY2tlcl9fcHJldlwiXG4gICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwicmVzb3VyY2VTdHJpbmdzLmlneF9jYWxlbmRhcl9wcmV2aW91c19tb250aCArICcsICcgKyAoZ2V0UHJldk1vbnRoKHZpZXdEYXRlKSB8IGRhdGU6ICdMTExMJylcIlxuICAgICAgICAgICAgZGF0YS1hY3Rpb249XCJwcmV2XCJcbiAgICAgICAgICAgICNwcmV2TW9udGhCdG5cbiAgICAgICAgICAgIGlneENhbGVuZGFyU2Nyb2xsTW9udGhcbiAgICAgICAgICAgIFtzdGFydFNjcm9sbF09XCJzdGFydFByZXZNb250aFNjcm9sbFwiXG4gICAgICAgICAgICBbc3RvcFNjcm9sbF09XCJzdG9wTW9udGhTY3JvbGxcIlxuICAgICAgICAgICAgW25nU3R5bGVdPVwieyAnbWluLXdpZHRoLiUnOiAxMDAvKG1vbnRoc1ZpZXdOdW1iZXIqNyl9XCI+XG4gICAgICAgICAgICA8aWd4LWljb24gYXJpYS1oaWRkZW49XCJ0cnVlXCI+a2V5Ym9hcmRfYXJyb3dfbGVmdDwvaWd4LWljb24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaWd4LWNhbGVuZGFyLXBpY2tlcl9fZGF0ZXNcIlxuICAgICAgICAgICAgICpuZ0Zvcj1cImxldCB2aWV3IG9mIG1vbnRoc1ZpZXdOdW1iZXIgfCBJZ3hNb250aFZpZXdTbG90czsgaW5kZXggYXMgaTtcIlxuICAgICAgICAgICAgIFtzdHlsZS53aWR0aC4lXT1cIjEwMC9tb250aHNWaWV3TnVtYmVyXCJcbiAgICAgICAgICAgICBbYXR0ci5kYXRhLW1vbnRoXT1cImkgfCBJZ3hHZXRWaWV3RGF0ZTp2aWV3RGF0ZTpmYWxzZVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInN1YmhlYWRlclRlbXBsYXRlID8gc3ViaGVhZGVyVGVtcGxhdGUgOiBkZWZhdWx0TW9udGg7IGNvbnRleHQ6IGdldENvbnRleHQoaSlcIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgIGNsYXNzPVwiaWd4LWNhbGVuZGFyLXBpY2tlcl9fbmV4dFwiXG4gICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwicmVzb3VyY2VTdHJpbmdzLmlneF9jYWxlbmRhcl9uZXh0X21vbnRoICsgJywgJyArICAoZ2V0TmV4dE1vbnRoKHZpZXdEYXRlLCBtb250aHNWaWV3TnVtYmVyKSB8IGRhdGU6ICdMTExMJylcIlxuICAgICAgICAgICAgZGF0YS1hY3Rpb249XCJuZXh0XCJcbiAgICAgICAgICAgICNuZXh0TW9udGhCdG5cbiAgICAgICAgICAgIGlneENhbGVuZGFyU2Nyb2xsTW9udGhcbiAgICAgICAgICAgIFtzdGFydFNjcm9sbF09XCJzdGFydE5leHRNb250aFNjcm9sbFwiXG4gICAgICAgICAgICBbc3RvcFNjcm9sbF09XCJzdG9wTW9udGhTY3JvbGxcIlxuICAgICAgICAgICAgW25nU3R5bGVdPVwieydtaW4td2lkdGguJSc6IDEwMC8obW9udGhzVmlld051bWJlcio3KX1cIj5cbiAgICAgICAgICAgIDxpZ3gtaWNvbiBhcmlhLWhpZGRlbj1cInRydWVcIj5rZXlib2FyZF9hcnJvd19yaWdodDwvaWd4LWljb24+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvc2VjdGlvbj5cblxuICAgIDxzZWN0aW9uIHN0eWxlPVwiZGlzcGxheTogZmxleFwiXG4gICAgICAgIFtAYW5pbWF0ZUNoYW5nZV09XCJhbmltYXRpb25BY3Rpb25cIlxuICAgICAgICAoQGFuaW1hdGVDaGFuZ2UuZG9uZSk9XCJhbmltYXRpb25Eb25lKCRldmVudClcIj5cbiAgICAgICAgPGlneC1kYXlzLXZpZXcgcm9sZT1cImdyaWRcIiAqbmdGb3I9XCJsZXQgdmlldyBvZiBtb250aHNWaWV3TnVtYmVyIHwgSWd4TW9udGhWaWV3U2xvdHM7IGluZGV4IGFzIGk7XCIgW2NoYW5nZURheXNWaWV3XT1cInRydWVcIiAjZGF5c1xuICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25dPVwic2VsZWN0aW9uXCJcbiAgICAgICAgICAgICAgICBbbG9jYWxlXT1cImxvY2FsZVwiXG4gICAgICAgICAgICAgICAgW3ZhbHVlXT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICBbKGFjdGl2ZURhdGUpXT1cImFjdGl2ZURhdGVcIlxuICAgICAgICAgICAgICAgIFt2aWV3RGF0ZV09XCJpIHwgSWd4R2V0Vmlld0RhdGU6dmlld0RhdGVcIlxuICAgICAgICAgICAgICAgIFt3ZWVrU3RhcnRdPVwid2Vla1N0YXJ0XCJcbiAgICAgICAgICAgICAgICBbZm9ybWF0T3B0aW9uc109XCJmb3JtYXRPcHRpb25zXCJcbiAgICAgICAgICAgICAgICBbZm9ybWF0Vmlld3NdPVwiZm9ybWF0Vmlld3NcIlxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZERhdGVzXT1cImRpc2FibGVkRGF0ZXNcIlxuICAgICAgICAgICAgICAgIFtzcGVjaWFsRGF0ZXNdPVwic3BlY2lhbERhdGVzXCJcbiAgICAgICAgICAgICAgICBbaGlkZU91dHNpZGVEYXlzXT1cImhpZGVPdXRzaWRlRGF5c1wiXG4gICAgICAgICAgICAgICAgW3Nob3dXZWVrTnVtYmVyc109XCJzaG93V2Vla051bWJlcnNcIlxuICAgICAgICAgICAgICAgICh2aWV3Q2hhbmdpbmcpPVwidmlld0NoYW5naW5nKCRldmVudClcIlxuICAgICAgICAgICAgICAgIChkYXRlU2VsZWN0aW9uKT1cImNoaWxkQ2xpY2tlZCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAobW9udGhzVmlld0JsdXIpPVwicmVzZXRBY3RpdmVEYXRlKClcIj5cbiAgICAgICAgPC9pZ3gtZGF5cy12aWV3PlxuICAgIDwvc2VjdGlvbj5cbjwvZGl2PlxuXG48aWd4LW1vbnRocy12aWV3ICpuZ0lmPVwiaXNZZWFyVmlld1wiXG4gICAgICAgICAgICAgICAgIFtAYW5pbWF0ZVZpZXddPVwiYWN0aXZlVmlld1wiXG4gICAgICAgICAgICAgICAgICNtb250aHNcbiAgICAgICAgICAgICAgICAgKEBhbmltYXRlVmlldy5kb25lKT1cInZpZXdSZW5kZXJlZCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgW2RhdGVdPVwidmlld0RhdGVcIlxuICAgICAgICAgICAgICAgICBbbG9jYWxlXT1cImxvY2FsZVwiXG4gICAgICAgICAgICAgICAgIFtmb3JtYXRWaWV3XT1cImZvcm1hdFZpZXdzLm1vbnRoXCJcbiAgICAgICAgICAgICAgICAgW21vbnRoRm9ybWF0XT1cImZvcm1hdE9wdGlvbnMubW9udGhcIlxuICAgICAgICAgICAgICAgICAoc2VsZWN0ZWQpPVwiY2hhbmdlTW9udGgoJGV2ZW50KVwiPlxuPC9pZ3gtbW9udGhzLXZpZXc+XG5cbjxpZ3gteWVhcnMtdmlldyAqbmdJZj1cImlzRGVjYWRlVmlld1wiXG4gICAgICAgICAgICAgICAgW0BhbmltYXRlVmlld109XCJhY3RpdmVWaWV3XCJcbiAgICAgICAgICAgICAgICAjZGVjYWRlXG4gICAgICAgICAgICAgICAgKEBhbmltYXRlVmlldy5kb25lKT1cInZpZXdSZW5kZXJlZCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICBbZGF0ZV09XCJ2aWV3RGF0ZVwiXG4gICAgICAgICAgICAgICAgW2xvY2FsZV09XCJsb2NhbGVcIlxuICAgICAgICAgICAgICAgIFtmb3JtYXRWaWV3XT1cImZvcm1hdFZpZXdzLnllYXJcIlxuICAgICAgICAgICAgICAgIFt5ZWFyRm9ybWF0XT1cImZvcm1hdE9wdGlvbnMueWVhclwiXG4gICAgICAgICAgICAgICAgKHNlbGVjdGVkKT1cImNoYW5nZVllYXIoJGV2ZW50KVwiPlxuPC9pZ3gteWVhcnMtdmlldz5cbiJdfQ==