import { Component, Input, Output, EventEmitter, ContentChild, Directive, TemplateRef, ContentChildren, HostBinding, Optional, Inject } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { growVerIn, growVerOut } from '../animations/grow';
import { DisplayDensityBase, DisplayDensityToken } from '../core/density';
import { IGX_TREE_COMPONENT, IgxTreeSelectionType } from './common';
import { IgxTreeNavigationService } from './tree-navigation.service';
import { IgxTreeNodeComponent } from './tree-node/tree-node.component';
import { IgxTreeSelectionService } from './tree-selection.service';
import { IgxTreeService } from './tree.service';
import * as i0 from "@angular/core";
import * as i1 from "./tree-navigation.service";
import * as i2 from "./tree-selection.service";
import * as i3 from "./tree.service";
/**
 * @hidden @internal
 * Used for templating the select marker of the tree
 */
export class IgxTreeSelectMarkerDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxTreeSelectMarkerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: IgxTreeSelectMarkerDirective, isStandalone: true, selector: "[igxTreeSelectMarker]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxTreeSelectMarkerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxTreeSelectMarker]',
                    standalone: true
                }]
        }] });
/**
 * @hidden @internal
 * Used for templating the expand indicator of the tree
 */
export class IgxTreeExpandIndicatorDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxTreeExpandIndicatorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: IgxTreeExpandIndicatorDirective, isStandalone: true, selector: "[igxTreeExpandIndicator]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxTreeExpandIndicatorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxTreeExpandIndicator]',
                    standalone: true
                }]
        }] });
/**
 * IgxTreeComponent allows a developer to show a set of nodes in a hierarchical fashion.
 *
 * @igxModule IgxTreeModule
 * @igxKeywords tree
 * @igxTheme igx-tree-theme
 * @igxGroup Grids & Lists
 *
 * @remark
 * The Angular Tree Component allows users to represent hierarchical data in a tree-view structure,
 * maintaining parent-child relationships, as well as to define static tree-view structure without a corresponding data model.
 * Its primary purpose is to allow end-users to visualize and navigate within hierarchical data structures.
 * The Ignite UI for Angular Tree Component also provides load on demand capabilities, item activation,
 * bi-state and cascading selection of items through built-in checkboxes, built-in keyboard navigation and more.
 *
 * @example
 * ```html
 * <igx-tree>
 *   <igx-tree-node>
 *      I am a parent node 1
 *      <igx-tree-node>
 *          I am a child node 1
 *      </igx-tree-node>
 *      ...
 *   </igx-tree-node>
 *	 ...
 * </igx-tree>
 * ```
 */
export class IgxTreeComponent extends DisplayDensityBase {
    /**
     * Gets/Sets tree selection mode
     *
     * @remarks
     * By default the tree selection mode is 'None'
     * @param selectionMode: IgxTreeSelectionType
     */
    get selection() {
        return this._selection;
    }
    set selection(selectionMode) {
        this._selection = selectionMode;
        this.selectionService.clearNodesSelection();
    }
    /**
     * Returns all **root level** nodes
     *
     * ```typescript
     * const tree: IgxTree = this.tree;
     * const rootNodes: IgxTreeNodeComponent<any>[] = tree.rootNodes;
     * ```
     */
    get rootNodes() {
        return this.nodes?.filter(node => node.level === 0);
    }
    constructor(navService, selectionService, treeService, element, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.navService = navService;
        this.selectionService = selectionService;
        this.treeService = treeService;
        this.element = element;
        this._displayDensityOptions = _displayDensityOptions;
        this.cssClass = 'igx-tree';
        /** Get/Set how the tree should handle branch expansion.
         * If set to `true`, only a single branch can be expanded at a time, collapsing all others
         *
         * ```html
         * <igx-tree [singleBranchExpand]="true">
         * ...
         * </igx-tree>
         * ```
         *
         * ```typescript
         * const tree: IgxTree = this.tree;
         * this.tree.singleBranchExpand = false;
         * ```
         */
        this.singleBranchExpand = false;
        /** Get/Set the animation settings that branches should use when expanding/collpasing.
         *
         * ```html
         * <igx-tree [animationSettings]="customAnimationSettings">
         * </igx-tree>
         * ```
         *
         * ```typescript
         * const animationSettings: ToggleAnimationSettings = {
         *      openAnimation: growVerIn,
         *      closeAnimation: growVerOut
         * };
         *
         * this.tree.animationSettings = animationSettings;
         * ```
         */
        this.animationSettings = {
            openAnimation: growVerIn,
            closeAnimation: growVerOut
        };
        /** Emitted when the node selection is changed through interaction
         *
         * ```html
         * <igx-tree (nodeSelection)="handleNodeSelection($event)">
         * </igx-tree>
         * ```
         *
         *```typescript
         * public handleNodeSelection(event: ITreeNodeSelectionEvent) {
         *  const newSelection: IgxTreeNode<any>[] = event.newSelection;
         *  const added: IgxTreeNode<any>[] = event.added;
         *  console.log("New selection will be: ", newSelection);
         *  console.log("Added nodes: ", event.added);
         * }
         *```
         */
        this.nodeSelection = new EventEmitter();
        /** Emitted when a node is expanding, before it finishes
         *
         * ```html
         * <igx-tree (nodeExpanding)="handleNodeExpanding($event)">
         * </igx-tree>
         * ```
         *
         *```typescript
         * public handleNodeExpanding(event: ITreeNodeTogglingEventArgs) {
         *  const expandedNode: IgxTreeNode<any> = event.node;
         *  if (expandedNode.disabled) {
         *      event.cancel = true;
         *  }
         * }
         *```
         */
        this.nodeExpanding = new EventEmitter();
        /** Emitted when a node is expanded, after it finishes
         *
         * ```html
         * <igx-tree (nodeExpanded)="handleNodeExpanded($event)">
         * </igx-tree>
         * ```
         *
         *```typescript
         * public handleNodeExpanded(event: ITreeNodeToggledEventArgs) {
         *  const expandedNode: IgxTreeNode<any> = event.node;
         *  console.log("Node is expanded: ", expandedNode.data);
         * }
         *```
         */
        this.nodeExpanded = new EventEmitter();
        /** Emitted when a node is collapsing, before it finishes
         *
         * ```html
         * <igx-tree (nodeCollapsing)="handleNodeCollapsing($event)">
         * </igx-tree>
         * ```
         *
         *```typescript
         * public handleNodeCollapsing(event: ITreeNodeTogglingEventArgs) {
         *  const collapsedNode: IgxTreeNode<any> = event.node;
         *  if (collapsedNode.alwaysOpen) {
         *      event.cancel = true;
         *  }
         * }
         *```
         */
        this.nodeCollapsing = new EventEmitter();
        /** Emitted when a node is collapsed, after it finishes
         *
         * @example
         * ```html
         * <igx-tree (nodeCollapsed)="handleNodeCollapsed($event)">
         * </igx-tree>
         * ```
         * ```typescript
         * public handleNodeCollapsed(event: ITreeNodeToggledEventArgs) {
         *  const collapsedNode: IgxTreeNode<any> = event.node;
         *  console.log("Node is collapsed: ", collapsedNode.data);
         * }
         * ```
         */
        this.nodeCollapsed = new EventEmitter();
        /**
         * Emitted when the active node is changed.
         *
         * @example
         * ```
         * <igx-tree (activeNodeChanged)="activeNodeChanged($event)"></igx-tree>
         * ```
         */
        this.activeNodeChanged = new EventEmitter();
        /** @hidden @internal */
        this.disabledChange = new EventEmitter();
        /**
         * Emitted when the active node is set through API
         *
         * @hidden @internal
         */
        this.activeNodeBindingChange = new EventEmitter();
        /** @hidden @internal */
        this.forceSelect = [];
        this._selection = IgxTreeSelectionType.None;
        this.destroy$ = new Subject();
        this.unsubChildren$ = new Subject();
        this._comparer = (data, node) => node.data === data;
        this.selectionService.register(this);
        this.treeService.register(this);
        this.navService.register(this);
    }
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Expands all of the passed nodes.
     * If no nodes are passed, expands ALL nodes
     *
     * @param nodes nodes to be expanded
     *
     * ```typescript
     * const targetNodes: IgxTreeNode<any> = this.tree.findNodes(true, (_data: any, node: IgxTreeNode<any>) => node.data.expandable);
     * tree.expandAll(nodes);
     * ```
     */
    expandAll(nodes) {
        nodes = nodes || this.nodes.toArray();
        nodes.forEach(e => e.expanded = true);
    }
    /**
     * Collapses all of the passed nodes.
     * If no nodes are passed, collapses ALL nodes
     *
     * @param nodes nodes to be collapsed
     *
     * ```typescript
     * const targetNodes: IgxTreeNode<any> = this.tree.findNodes(true, (_data: any, node: IgxTreeNode<any>) => node.data.collapsible);
     * tree.collapseAll(nodes);
     * ```
     */
    collapseAll(nodes) {
        nodes = nodes || this.nodes.toArray();
        nodes.forEach(e => e.expanded = false);
    }
    /**
     * Deselect all nodes if the nodes collection is empty. Otherwise, deselect the nodes in the nodes collection.
     *
     * @example
     * ```typescript
     *  const arr = [
     *      this.tree.nodes.toArray()[0],
     *      this.tree.nodes.toArray()[1]
     *  ];
     *  this.tree.deselectAll(arr);
     * ```
     * @param nodes: IgxTreeNodeComponent<any>[]
     */
    deselectAll(nodes) {
        this.selectionService.deselectNodesWithNoEvent(nodes);
    }
    /**
     * Returns all of the nodes that match the passed searchTerm.
     * Accepts a custom comparer function for evaluating the search term against the nodes.
     *
     * @remark
     * Default search compares the passed `searchTerm` against the node's `data` Input.
     * When using `findNodes` w/o a `comparer`, make sure all nodes have `data` passed.
     *
     * @param searchTerm The data of the searched node
     * @param comparer A custom comparer function that evaluates the passed `searchTerm` against all nodes.
     * @returns Array of nodes that match the search. `null` if no nodes are found.
     *
     * ```html
     * <igx-tree>
     *     <igx-tree-node *ngFor="let node of data" [data]="node">
     *          {{ node.label }}
     *     </igx-tree-node>
     * </igx-tree>
     * ```
     *
     * ```typescript
     * public data: DataEntry[] = FETCHED_DATA;
     * ...
     * const matchedNodes: IgxTreeNode<DataEntry>[] = this.tree.findNodes<DataEntry>(searchTerm: data[5]);
     * ```
     *
     * Using a custom comparer
     * ```typescript
     * public data: DataEntry[] = FETCHED_DATA;
     * ...
     * const comparer: IgxTreeSearchResolver = (data: any, node: IgxTreeNode<DataEntry>) {
     *      return node.data.index % 2 === 0;
     * }
     * const evenIndexNodes: IgxTreeNode<DataEntry>[] = this.tree.findNodes<DataEntry>(null, comparer);
     * ```
     */
    findNodes(searchTerm, comparer) {
        const compareFunc = comparer || this._comparer;
        const results = this.nodes.filter(node => compareFunc(searchTerm, node));
        return results?.length === 0 ? null : results;
    }
    /** @hidden @internal */
    handleKeydown(event) {
        this.navService.handleKeydown(event);
    }
    /** @hidden @internal */
    ngOnInit() {
        super.ngOnInit();
        this.disabledChange.pipe(takeUntil(this.destroy$)).subscribe((e) => {
            this.navService.update_disabled_cache(e);
        });
        this.activeNodeBindingChange.pipe(takeUntil(this.destroy$)).subscribe((node) => {
            this.expandToNode(this.navService.activeNode);
            this.scrollNodeIntoView(node?.header?.nativeElement);
        });
        this.densityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
            requestAnimationFrame(() => {
                this.scrollNodeIntoView(this.navService.activeNode?.header.nativeElement);
            });
        });
        this.subToCollapsing();
    }
    /** @hidden @internal */
    ngAfterViewInit() {
        this.nodes.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.subToChanges();
        });
        this.scrollNodeIntoView(this.navService.activeNode?.header?.nativeElement);
        this.subToChanges();
    }
    /** @hidden @internal */
    ngOnDestroy() {
        this.unsubChildren$.next();
        this.unsubChildren$.complete();
        this.destroy$.next();
        this.destroy$.complete();
    }
    expandToNode(node) {
        if (node && node.parentNode) {
            node.path.forEach(n => {
                if (n !== node && !n.expanded) {
                    n.expanded = true;
                }
            });
        }
    }
    subToCollapsing() {
        this.nodeCollapsing.pipe(takeUntil(this.destroy$)).subscribe(event => {
            if (event.cancel) {
                return;
            }
            this.navService.update_visible_cache(event.node, false);
        });
        this.nodeExpanding.pipe(takeUntil(this.destroy$)).subscribe(event => {
            if (event.cancel) {
                return;
            }
            this.navService.update_visible_cache(event.node, true);
        });
    }
    subToChanges() {
        this.unsubChildren$.next();
        const toBeSelected = [...this.forceSelect];
        requestAnimationFrame(() => {
            this.selectionService.selectNodesWithNoEvent(toBeSelected);
        });
        this.forceSelect = [];
        this.nodes.forEach(node => {
            node.expandedChange.pipe(takeUntil(this.unsubChildren$)).subscribe(nodeState => {
                this.navService.update_visible_cache(node, nodeState);
            });
            node.closeAnimationDone.pipe(takeUntil(this.unsubChildren$)).subscribe(() => {
                const targetElement = this.navService.focusedNode?.header.nativeElement;
                this.scrollNodeIntoView(targetElement);
            });
            node.openAnimationDone.pipe(takeUntil(this.unsubChildren$)).subscribe(() => {
                const targetElement = this.navService.focusedNode?.header.nativeElement;
                this.scrollNodeIntoView(targetElement);
            });
        });
        this.navService.init_invisible_cache();
    }
    scrollNodeIntoView(el) {
        if (!el) {
            return;
        }
        const nodeRect = el.getBoundingClientRect();
        const treeRect = this.nativeElement.getBoundingClientRect();
        const topOffset = treeRect.top > nodeRect.top ? nodeRect.top - treeRect.top : 0;
        const bottomOffset = treeRect.bottom < nodeRect.bottom ? nodeRect.bottom - treeRect.bottom : 0;
        const shouldScroll = !!topOffset || !!bottomOffset;
        if (shouldScroll && this.nativeElement.scrollHeight > this.nativeElement.clientHeight) {
            // this.nativeElement.scrollTop = nodeRect.y - treeRect.y - nodeRect.height;
            this.nativeElement.scrollTop =
                this.nativeElement.scrollTop + bottomOffset + topOffset + (topOffset ? -1 : +1) * nodeRect.height;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxTreeComponent, deps: [{ token: i1.IgxTreeNavigationService }, { token: i2.IgxTreeSelectionService }, { token: i3.IgxTreeService }, { token: i0.ElementRef }, { token: DisplayDensityToken, optional: true }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxTreeComponent, isStandalone: true, selector: "igx-tree", inputs: { selection: "selection", singleBranchExpand: "singleBranchExpand", animationSettings: "animationSettings" }, outputs: { nodeSelection: "nodeSelection", nodeExpanding: "nodeExpanding", nodeExpanded: "nodeExpanded", nodeCollapsing: "nodeCollapsing", nodeCollapsed: "nodeCollapsed", activeNodeChanged: "activeNodeChanged" }, host: { properties: { "class.igx-tree": "this.cssClass" } }, providers: [
            IgxTreeService,
            IgxTreeSelectionService,
            IgxTreeNavigationService,
            { provide: IGX_TREE_COMPONENT, useExisting: IgxTreeComponent },
        ], queries: [{ propertyName: "expandIndicator", first: true, predicate: IgxTreeExpandIndicatorDirective, descendants: true, read: TemplateRef }, { propertyName: "nodes", predicate: IgxTreeNodeComponent, descendants: true }], usesInheritance: true, ngImport: i0, template: "<div class=\"igx-tree__root\" role=\"tree\" (keydown)=\"handleKeydown($event)\">\n    <ng-content select=\"igx-tree-node\"></ng-content>\n</div>\n" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxTreeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tree', providers: [
                        IgxTreeService,
                        IgxTreeSelectionService,
                        IgxTreeNavigationService,
                        { provide: IGX_TREE_COMPONENT, useExisting: IgxTreeComponent },
                    ], standalone: true, template: "<div class=\"igx-tree__root\" role=\"tree\" (keydown)=\"handleKeydown($event)\">\n    <ng-content select=\"igx-tree-node\"></ng-content>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.IgxTreeNavigationService }, { type: i2.IgxTreeSelectionService }, { type: i3.IgxTreeService }, { type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DisplayDensityToken]
                }] }]; }, propDecorators: { cssClass: [{
                type: HostBinding,
                args: ['class.igx-tree']
            }], selection: [{
                type: Input
            }], singleBranchExpand: [{
                type: Input
            }], animationSettings: [{
                type: Input
            }], nodeSelection: [{
                type: Output
            }], nodeExpanding: [{
                type: Output
            }], nodeExpanded: [{
                type: Output
            }], nodeCollapsing: [{
                type: Output
            }], nodeCollapsed: [{
                type: Output
            }], activeNodeChanged: [{
                type: Output
            }], expandIndicator: [{
                type: ContentChild,
                args: [IgxTreeExpandIndicatorDirective, { read: TemplateRef }]
            }], nodes: [{
                type: ContentChildren,
                args: [IgxTreeNodeComponent, { descendants: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvdHJlZS90cmVlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi90cmVlL3RyZWUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILFNBQVMsRUFBYSxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUMxRSxXQUFXLEVBQXlCLGVBQWUsRUFBYSxXQUFXLEVBQWMsUUFBUSxFQUFFLE1BQU0sRUFDNUcsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUMzRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQTBCLE1BQU0saUJBQWlCLENBQUM7QUFFbEcsT0FBTyxFQUNILGtCQUFrQixFQUFFLG9CQUFvQixFQUUzQyxNQUFNLFVBQVUsQ0FBQztBQUNsQixPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUNyRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUN2RSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNuRSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7O0FBRWhEOzs7R0FHRztBQUtILE1BQU0sT0FBTyw0QkFBNEI7OEdBQTVCLDRCQUE0QjtrR0FBNUIsNEJBQTRCOzsyRkFBNUIsNEJBQTRCO2tCQUp4QyxTQUFTO21CQUFDO29CQUNQLFFBQVEsRUFBRSx1QkFBdUI7b0JBQ2pDLFVBQVUsRUFBRSxJQUFJO2lCQUNuQjs7QUFJRDs7O0dBR0c7QUFLSCxNQUFNLE9BQU8sK0JBQStCOzhHQUEvQiwrQkFBK0I7a0dBQS9CLCtCQUErQjs7MkZBQS9CLCtCQUErQjtrQkFKM0MsU0FBUzttQkFBQztvQkFDUCxRQUFRLEVBQUUsMEJBQTBCO29CQUNwQyxVQUFVLEVBQUUsSUFBSTtpQkFDbkI7O0FBSUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E0Qkc7QUFZSCxNQUFNLE9BQU8sZ0JBQWlCLFNBQVEsa0JBQWtCO0lBS3BEOzs7Ozs7T0FNRztJQUNILElBQ1csU0FBUztRQUNoQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDM0IsQ0FBQztJQUVELElBQVcsU0FBUyxDQUFDLGFBQW1DO1FBQ3BELElBQUksQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFDO1FBQ2hDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0lBQ2hELENBQUM7SUFtS0Q7Ozs7Ozs7T0FPRztJQUNILElBQVcsU0FBUztRQUNoQixPQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBZ0JELFlBQ1ksVUFBb0MsRUFDcEMsZ0JBQXlDLEVBQ3pDLFdBQTJCLEVBQzNCLE9BQWdDLEVBQ1csc0JBQStDO1FBQ2xHLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1FBTHRCLGVBQVUsR0FBVixVQUFVLENBQTBCO1FBQ3BDLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBeUI7UUFDekMsZ0JBQVcsR0FBWCxXQUFXLENBQWdCO1FBQzNCLFlBQU8sR0FBUCxPQUFPLENBQXlCO1FBQ1csMkJBQXNCLEdBQXRCLHNCQUFzQixDQUF5QjtRQW5OL0YsYUFBUSxHQUFHLFVBQVUsQ0FBQztRQW1CN0I7Ozs7Ozs7Ozs7Ozs7V0FhRztRQUVJLHVCQUFrQixHQUFHLEtBQUssQ0FBQztRQUVsQzs7Ozs7Ozs7Ozs7Ozs7O1dBZUc7UUFFSSxzQkFBaUIsR0FBNEI7WUFDaEQsYUFBYSxFQUFFLFNBQVM7WUFDeEIsY0FBYyxFQUFFLFVBQVU7U0FDN0IsQ0FBQztRQUVGOzs7Ozs7Ozs7Ozs7Ozs7V0FlRztRQUVJLGtCQUFhLEdBQUcsSUFBSSxZQUFZLEVBQTJCLENBQUM7UUFFbkU7Ozs7Ozs7Ozs7Ozs7OztXQWVHO1FBRUksa0JBQWEsR0FBRyxJQUFJLFlBQVksRUFBOEIsQ0FBQztRQUV0RTs7Ozs7Ozs7Ozs7OztXQWFHO1FBRUksaUJBQVksR0FBRyxJQUFJLFlBQVksRUFBNkIsQ0FBQztRQUVwRTs7Ozs7Ozs7Ozs7Ozs7O1dBZUc7UUFFSSxtQkFBYyxHQUFHLElBQUksWUFBWSxFQUE4QixDQUFDO1FBRXZFOzs7Ozs7Ozs7Ozs7O1dBYUc7UUFFSSxrQkFBYSxHQUFHLElBQUksWUFBWSxFQUE2QixDQUFDO1FBRXJFOzs7Ozs7O1dBT0c7UUFFSSxzQkFBaUIsR0FBRyxJQUFJLFlBQVksRUFBb0IsQ0FBQztRQW1CaEUsd0JBQXdCO1FBQ2pCLG1CQUFjLEdBQUcsSUFBSSxZQUFZLEVBQW9CLENBQUM7UUFjN0Q7Ozs7V0FJRztRQUNJLDRCQUF1QixHQUFHLElBQUksWUFBWSxFQUFvQixDQUFDO1FBRXRFLHdCQUF3QjtRQUNqQixnQkFBVyxHQUFHLEVBQUUsQ0FBQztRQUVoQixlQUFVLEdBQXlCLG9CQUFvQixDQUFDLElBQUksQ0FBQztRQUM3RCxhQUFRLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztRQUMvQixtQkFBYyxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFzTnJDLGNBQVMsR0FBRyxDQUFJLElBQU8sRUFBRSxJQUE2QixFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQztRQTdNbEYsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNyQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoQyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQsd0JBQXdCO0lBQ3hCLElBQVcsYUFBYTtRQUNwQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0ksU0FBUyxDQUFDLEtBQTBCO1FBQ3ZDLEtBQUssR0FBRyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN0QyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLFdBQVcsQ0FBQyxLQUEwQjtRQUN6QyxLQUFLLEdBQUcsS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdEMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsS0FBSyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNJLFdBQVcsQ0FBQyxLQUFtQztRQUNsRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsd0JBQXdCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQW1DRztJQUNJLFNBQVMsQ0FBQyxVQUFlLEVBQUUsUUFBZ0M7UUFDOUQsTUFBTSxXQUFXLEdBQUcsUUFBUSxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDL0MsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDekUsT0FBTyxPQUFPLEVBQUUsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7SUFDbEQsQ0FBQztJQUVELHdCQUF3QjtJQUNqQixhQUFhLENBQUMsS0FBb0I7UUFDckMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVELHdCQUF3QjtJQUNSLFFBQVE7UUFDcEIsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUMvRCxJQUFJLENBQUMsVUFBVSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdDLENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDM0UsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQzlDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ3pELENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDOUQscUJBQXFCLENBQUMsR0FBRyxFQUFFO2dCQUN2QixJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQzlFLENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVELHdCQUF3QjtJQUNqQixlQUFlO1FBQ2xCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRTtZQUM3RCxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDeEIsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQzNFLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRUQsd0JBQXdCO0lBQ2pCLFdBQVc7UUFDZCxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQzNCLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFTyxZQUFZLENBQUMsSUFBc0I7UUFDdkMsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUN6QixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDbEIsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRTtvQkFDM0IsQ0FBQyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7aUJBQ3JCO1lBQ0wsQ0FBQyxDQUFDLENBQUM7U0FDTjtJQUNMLENBQUM7SUFFTyxlQUFlO1FBQ25CLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDakUsSUFBSSxLQUFLLENBQUMsTUFBTSxFQUFFO2dCQUNkLE9BQU87YUFDVjtZQUNELElBQUksQ0FBQyxVQUFVLENBQUMsb0JBQW9CLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUM1RCxDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDaEUsSUFBSSxLQUFLLENBQUMsTUFBTSxFQUFFO2dCQUNkLE9BQU87YUFDVjtZQUNELElBQUksQ0FBQyxVQUFVLENBQUMsb0JBQW9CLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMzRCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFTyxZQUFZO1FBQ2hCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDM0IsTUFBTSxZQUFZLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMzQyxxQkFBcUIsQ0FBQyxHQUFHLEVBQUU7WUFDdkIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLHNCQUFzQixDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQy9ELENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7UUFDdEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDM0UsSUFBSSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDMUQsQ0FBQyxDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO2dCQUN4RSxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsYUFBYSxDQUFDO2dCQUN4RSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDM0MsQ0FBQyxDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO2dCQUN2RSxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsYUFBYSxDQUFDO2dCQUN4RSxJQUFJLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDM0MsQ0FBQyxDQUFDLENBQUM7UUFDUCxDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxVQUFVLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztJQUMzQyxDQUFDO0lBRU8sa0JBQWtCLENBQUMsRUFBZTtRQUN0QyxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ0wsT0FBTztTQUNWO1FBQ0QsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLHFCQUFxQixFQUFFLENBQUM7UUFDNUMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBQzVELE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEYsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvRixNQUFNLFlBQVksR0FBRyxDQUFDLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUM7UUFDbkQsSUFBSSxZQUFZLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQUU7WUFDbkYsNEVBQTRFO1lBQzVFLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUztnQkFDNUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEdBQUcsWUFBWSxHQUFHLFNBQVMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQztTQUNyRztJQUNMLENBQUM7OEdBbmFRLGdCQUFnQix5SkFzTkQsbUJBQW1CO2tHQXRObEMsZ0JBQWdCLCtiQVJkO1lBQ1AsY0FBYztZQUNkLHVCQUF1QjtZQUN2Qix3QkFBd0I7WUFDeEIsRUFBRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFFO1NBQ2pFLHVFQWdMYSwrQkFBK0IsMkJBQVUsV0FBVyx3Q0FJakQsb0JBQW9CLHVFQ25RekMsb0pBR0E7OzJGRCtFYSxnQkFBZ0I7a0JBWDVCLFNBQVM7K0JBQ0ksVUFBVSxhQUVUO3dCQUNQLGNBQWM7d0JBQ2QsdUJBQXVCO3dCQUN2Qix3QkFBd0I7d0JBQ3hCLEVBQUUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLFdBQVcsa0JBQWtCLEVBQUU7cUJBQ2pFLGNBQ1csSUFBSTs7MEJBd05YLFFBQVE7OzBCQUFJLE1BQU07MkJBQUMsbUJBQW1COzRDQW5OcEMsUUFBUTtzQkFEZCxXQUFXO3VCQUFDLGdCQUFnQjtnQkFXbEIsU0FBUztzQkFEbkIsS0FBSztnQkF5QkMsa0JBQWtCO3NCQUR4QixLQUFLO2dCQW9CQyxpQkFBaUI7c0JBRHZCLEtBQUs7Z0JBdUJDLGFBQWE7c0JBRG5CLE1BQU07Z0JBb0JBLGFBQWE7c0JBRG5CLE1BQU07Z0JBa0JBLFlBQVk7c0JBRGxCLE1BQU07Z0JBb0JBLGNBQWM7c0JBRHBCLE1BQU07Z0JBa0JBLGFBQWE7c0JBRG5CLE1BQU07Z0JBWUEsaUJBQWlCO3NCQUR2QixNQUFNO2dCQWNBLGVBQWU7c0JBRHJCLFlBQVk7dUJBQUMsK0JBQStCLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFO2dCQUs3RCxLQUFLO3NCQURYLGVBQWU7dUJBQUMsb0JBQW9CLEVBQUUsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDb21wb25lbnQsIFF1ZXJ5TGlzdCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBDb250ZW50Q2hpbGQsIERpcmVjdGl2ZSxcbiAgICBUZW1wbGF0ZVJlZiwgT25Jbml0LCBBZnRlclZpZXdJbml0LCBDb250ZW50Q2hpbGRyZW4sIE9uRGVzdHJveSwgSG9zdEJpbmRpbmcsIEVsZW1lbnRSZWYsIE9wdGlvbmFsLCBJbmplY3Rcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgZ3Jvd1ZlckluLCBncm93VmVyT3V0IH0gZnJvbSAnLi4vYW5pbWF0aW9ucy9ncm93JztcbmltcG9ydCB7IERpc3BsYXlEZW5zaXR5QmFzZSwgRGlzcGxheURlbnNpdHlUb2tlbiwgSURpc3BsYXlEZW5zaXR5T3B0aW9ucyB9IGZyb20gJy4uL2NvcmUvZGVuc2l0eSc7XG5pbXBvcnQgeyBUb2dnbGVBbmltYXRpb25TZXR0aW5ncyB9IGZyb20gJy4uL2V4cGFuc2lvbi1wYW5lbC90b2dnbGUtYW5pbWF0aW9uLWNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIElHWF9UUkVFX0NPTVBPTkVOVCwgSWd4VHJlZVNlbGVjdGlvblR5cGUsIElneFRyZWUsIElUcmVlTm9kZVRvZ2dsZWRFdmVudEFyZ3MsXG4gICAgSVRyZWVOb2RlVG9nZ2xpbmdFdmVudEFyZ3MsIElUcmVlTm9kZVNlbGVjdGlvbkV2ZW50LCBJZ3hUcmVlTm9kZSwgSWd4VHJlZVNlYXJjaFJlc29sdmVyXG59IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IElneFRyZWVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vdHJlZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4VHJlZU5vZGVDb21wb25lbnQgfSBmcm9tICcuL3RyZWUtbm9kZS90cmVlLW5vZGUuY29tcG9uZW50JztcbmltcG9ydCB7IElneFRyZWVTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi90cmVlLXNlbGVjdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IElneFRyZWVTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLnNlcnZpY2UnO1xuXG4vKipcbiAqIEBoaWRkZW4gQGludGVybmFsXG4gKiBVc2VkIGZvciB0ZW1wbGF0aW5nIHRoZSBzZWxlY3QgbWFya2VyIG9mIHRoZSB0cmVlXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneFRyZWVTZWxlY3RNYXJrZXJdJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVTZWxlY3RNYXJrZXJEaXJlY3RpdmUge1xufVxuXG4vKipcbiAqIEBoaWRkZW4gQGludGVybmFsXG4gKiBVc2VkIGZvciB0ZW1wbGF0aW5nIHRoZSBleHBhbmQgaW5kaWNhdG9yIG9mIHRoZSB0cmVlXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneFRyZWVFeHBhbmRJbmRpY2F0b3JdJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVFeHBhbmRJbmRpY2F0b3JEaXJlY3RpdmUge1xufVxuXG4vKipcbiAqIElneFRyZWVDb21wb25lbnQgYWxsb3dzIGEgZGV2ZWxvcGVyIHRvIHNob3cgYSBzZXQgb2Ygbm9kZXMgaW4gYSBoaWVyYXJjaGljYWwgZmFzaGlvbi5cbiAqXG4gKiBAaWd4TW9kdWxlIElneFRyZWVNb2R1bGVcbiAqIEBpZ3hLZXl3b3JkcyB0cmVlXG4gKiBAaWd4VGhlbWUgaWd4LXRyZWUtdGhlbWVcbiAqIEBpZ3hHcm91cCBHcmlkcyAmIExpc3RzXG4gKlxuICogQHJlbWFya1xuICogVGhlIEFuZ3VsYXIgVHJlZSBDb21wb25lbnQgYWxsb3dzIHVzZXJzIHRvIHJlcHJlc2VudCBoaWVyYXJjaGljYWwgZGF0YSBpbiBhIHRyZWUtdmlldyBzdHJ1Y3R1cmUsXG4gKiBtYWludGFpbmluZyBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwcywgYXMgd2VsbCBhcyB0byBkZWZpbmUgc3RhdGljIHRyZWUtdmlldyBzdHJ1Y3R1cmUgd2l0aG91dCBhIGNvcnJlc3BvbmRpbmcgZGF0YSBtb2RlbC5cbiAqIEl0cyBwcmltYXJ5IHB1cnBvc2UgaXMgdG8gYWxsb3cgZW5kLXVzZXJzIHRvIHZpc3VhbGl6ZSBhbmQgbmF2aWdhdGUgd2l0aGluIGhpZXJhcmNoaWNhbCBkYXRhIHN0cnVjdHVyZXMuXG4gKiBUaGUgSWduaXRlIFVJIGZvciBBbmd1bGFyIFRyZWUgQ29tcG9uZW50IGFsc28gcHJvdmlkZXMgbG9hZCBvbiBkZW1hbmQgY2FwYWJpbGl0aWVzLCBpdGVtIGFjdGl2YXRpb24sXG4gKiBiaS1zdGF0ZSBhbmQgY2FzY2FkaW5nIHNlbGVjdGlvbiBvZiBpdGVtcyB0aHJvdWdoIGJ1aWx0LWluIGNoZWNrYm94ZXMsIGJ1aWx0LWluIGtleWJvYXJkIG5hdmlnYXRpb24gYW5kIG1vcmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtdHJlZT5cbiAqICAgPGlneC10cmVlLW5vZGU+XG4gKiAgICAgIEkgYW0gYSBwYXJlbnQgbm9kZSAxXG4gKiAgICAgIDxpZ3gtdHJlZS1ub2RlPlxuICogICAgICAgICAgSSBhbSBhIGNoaWxkIG5vZGUgMVxuICogICAgICA8L2lneC10cmVlLW5vZGU+XG4gKiAgICAgIC4uLlxuICogICA8L2lneC10cmVlLW5vZGU+XG4gKlx0IC4uLlxuICogPC9pZ3gtdHJlZT5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC10cmVlJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RyZWUuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBJZ3hUcmVlU2VydmljZSxcbiAgICAgICAgSWd4VHJlZVNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIElneFRyZWVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgeyBwcm92aWRlOiBJR1hfVFJFRV9DT01QT05FTlQsIHVzZUV4aXN0aW5nOiBJZ3hUcmVlQ29tcG9uZW50IH0sXG4gICAgXSxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVDb21wb25lbnQgZXh0ZW5kcyBEaXNwbGF5RGVuc2l0eUJhc2UgaW1wbGVtZW50cyBJZ3hUcmVlLCBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10cmVlJylcbiAgICBwdWJsaWMgY3NzQ2xhc3MgPSAnaWd4LXRyZWUnO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRyZWUgc2VsZWN0aW9uIG1vZGVcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQnkgZGVmYXVsdCB0aGUgdHJlZSBzZWxlY3Rpb24gbW9kZSBpcyAnTm9uZSdcbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uTW9kZTogSWd4VHJlZVNlbGVjdGlvblR5cGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgc2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgc2VsZWN0aW9uKHNlbGVjdGlvbk1vZGU6IElneFRyZWVTZWxlY3Rpb25UeXBlKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbiA9IHNlbGVjdGlvbk1vZGU7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5jbGVhck5vZGVzU2VsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqIEdldC9TZXQgaG93IHRoZSB0cmVlIHNob3VsZCBoYW5kbGUgYnJhbmNoIGV4cGFuc2lvbi5cbiAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCBvbmx5IGEgc2luZ2xlIGJyYW5jaCBjYW4gYmUgZXhwYW5kZWQgYXQgYSB0aW1lLCBjb2xsYXBzaW5nIGFsbCBvdGhlcnNcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUgW3NpbmdsZUJyYW5jaEV4cGFuZF09XCJ0cnVlXCI+XG4gICAgICogLi4uXG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB0cmVlOiBJZ3hUcmVlID0gdGhpcy50cmVlO1xuICAgICAqIHRoaXMudHJlZS5zaW5nbGVCcmFuY2hFeHBhbmQgPSBmYWxzZTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzaW5nbGVCcmFuY2hFeHBhbmQgPSBmYWxzZTtcblxuICAgIC8qKiBHZXQvU2V0IHRoZSBhbmltYXRpb24gc2V0dGluZ3MgdGhhdCBicmFuY2hlcyBzaG91bGQgdXNlIHdoZW4gZXhwYW5kaW5nL2NvbGxwYXNpbmcuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlIFthbmltYXRpb25TZXR0aW5nc109XCJjdXN0b21BbmltYXRpb25TZXR0aW5nc1wiPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgYW5pbWF0aW9uU2V0dGluZ3M6IFRvZ2dsZUFuaW1hdGlvblNldHRpbmdzID0ge1xuICAgICAqICAgICAgb3BlbkFuaW1hdGlvbjogZ3Jvd1ZlckluLFxuICAgICAqICAgICAgY2xvc2VBbmltYXRpb246IGdyb3dWZXJPdXRcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdGhpcy50cmVlLmFuaW1hdGlvblNldHRpbmdzID0gYW5pbWF0aW9uU2V0dGluZ3M7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgYW5pbWF0aW9uU2V0dGluZ3M6IFRvZ2dsZUFuaW1hdGlvblNldHRpbmdzID0ge1xuICAgICAgICBvcGVuQW5pbWF0aW9uOiBncm93VmVySW4sXG4gICAgICAgIGNsb3NlQW5pbWF0aW9uOiBncm93VmVyT3V0XG4gICAgfTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIG5vZGUgc2VsZWN0aW9uIGlzIGNoYW5nZWQgdGhyb3VnaCBpbnRlcmFjdGlvblxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZSAobm9kZVNlbGVjdGlvbik9XCJoYW5kbGVOb2RlU2VsZWN0aW9uKCRldmVudClcIj5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGhhbmRsZU5vZGVTZWxlY3Rpb24oZXZlbnQ6IElUcmVlTm9kZVNlbGVjdGlvbkV2ZW50KSB7XG4gICAgICogIGNvbnN0IG5ld1NlbGVjdGlvbjogSWd4VHJlZU5vZGU8YW55PltdID0gZXZlbnQubmV3U2VsZWN0aW9uO1xuICAgICAqICBjb25zdCBhZGRlZDogSWd4VHJlZU5vZGU8YW55PltdID0gZXZlbnQuYWRkZWQ7XG4gICAgICogIGNvbnNvbGUubG9nKFwiTmV3IHNlbGVjdGlvbiB3aWxsIGJlOiBcIiwgbmV3U2VsZWN0aW9uKTtcbiAgICAgKiAgY29uc29sZS5sb2coXCJBZGRlZCBub2RlczogXCIsIGV2ZW50LmFkZGVkKTtcbiAgICAgKiB9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgbm9kZVNlbGVjdGlvbiA9IG5ldyBFdmVudEVtaXR0ZXI8SVRyZWVOb2RlU2VsZWN0aW9uRXZlbnQ+KCk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGEgbm9kZSBpcyBleHBhbmRpbmcsIGJlZm9yZSBpdCBmaW5pc2hlc1xuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZSAobm9kZUV4cGFuZGluZyk9XCJoYW5kbGVOb2RlRXhwYW5kaW5nKCRldmVudClcIj5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGhhbmRsZU5vZGVFeHBhbmRpbmcoZXZlbnQ6IElUcmVlTm9kZVRvZ2dsaW5nRXZlbnRBcmdzKSB7XG4gICAgICogIGNvbnN0IGV4cGFuZGVkTm9kZTogSWd4VHJlZU5vZGU8YW55PiA9IGV2ZW50Lm5vZGU7XG4gICAgICogIGlmIChleHBhbmRlZE5vZGUuZGlzYWJsZWQpIHtcbiAgICAgKiAgICAgIGV2ZW50LmNhbmNlbCA9IHRydWU7XG4gICAgICogIH1cbiAgICAgKiB9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgbm9kZUV4cGFuZGluZyA9IG5ldyBFdmVudEVtaXR0ZXI8SVRyZWVOb2RlVG9nZ2xpbmdFdmVudEFyZ3M+KCk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGEgbm9kZSBpcyBleHBhbmRlZCwgYWZ0ZXIgaXQgZmluaXNoZXNcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUgKG5vZGVFeHBhbmRlZCk9XCJoYW5kbGVOb2RlRXhwYW5kZWQoJGV2ZW50KVwiPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgaGFuZGxlTm9kZUV4cGFuZGVkKGV2ZW50OiBJVHJlZU5vZGVUb2dnbGVkRXZlbnRBcmdzKSB7XG4gICAgICogIGNvbnN0IGV4cGFuZGVkTm9kZTogSWd4VHJlZU5vZGU8YW55PiA9IGV2ZW50Lm5vZGU7XG4gICAgICogIGNvbnNvbGUubG9nKFwiTm9kZSBpcyBleHBhbmRlZDogXCIsIGV4cGFuZGVkTm9kZS5kYXRhKTtcbiAgICAgKiB9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgbm9kZUV4cGFuZGVkID0gbmV3IEV2ZW50RW1pdHRlcjxJVHJlZU5vZGVUb2dnbGVkRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhIG5vZGUgaXMgY29sbGFwc2luZywgYmVmb3JlIGl0IGZpbmlzaGVzXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlIChub2RlQ29sbGFwc2luZyk9XCJoYW5kbGVOb2RlQ29sbGFwc2luZygkZXZlbnQpXCI+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBoYW5kbGVOb2RlQ29sbGFwc2luZyhldmVudDogSVRyZWVOb2RlVG9nZ2xpbmdFdmVudEFyZ3MpIHtcbiAgICAgKiAgY29uc3QgY29sbGFwc2VkTm9kZTogSWd4VHJlZU5vZGU8YW55PiA9IGV2ZW50Lm5vZGU7XG4gICAgICogIGlmIChjb2xsYXBzZWROb2RlLmFsd2F5c09wZW4pIHtcbiAgICAgKiAgICAgIGV2ZW50LmNhbmNlbCA9IHRydWU7XG4gICAgICogIH1cbiAgICAgKiB9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgbm9kZUNvbGxhcHNpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPElUcmVlTm9kZVRvZ2dsaW5nRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhIG5vZGUgaXMgY29sbGFwc2VkLCBhZnRlciBpdCBmaW5pc2hlc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlIChub2RlQ29sbGFwc2VkKT1cImhhbmRsZU5vZGVDb2xsYXBzZWQoJGV2ZW50KVwiPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBoYW5kbGVOb2RlQ29sbGFwc2VkKGV2ZW50OiBJVHJlZU5vZGVUb2dnbGVkRXZlbnRBcmdzKSB7XG4gICAgICogIGNvbnN0IGNvbGxhcHNlZE5vZGU6IElneFRyZWVOb2RlPGFueT4gPSBldmVudC5ub2RlO1xuICAgICAqICBjb25zb2xlLmxvZyhcIk5vZGUgaXMgY29sbGFwc2VkOiBcIiwgY29sbGFwc2VkTm9kZS5kYXRhKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG5vZGVDb2xsYXBzZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElUcmVlTm9kZVRvZ2dsZWRFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIGFjdGl2ZSBub2RlIGlzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIDxpZ3gtdHJlZSAoYWN0aXZlTm9kZUNoYW5nZWQpPVwiYWN0aXZlTm9kZUNoYW5nZWQoJGV2ZW50KVwiPjwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGFjdGl2ZU5vZGVDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxJZ3hUcmVlTm9kZTxhbnk+PigpO1xuXG4gICAgLyoqXG4gICAgICogQSBjdXN0b20gdGVtcGxhdGUgdG8gYmUgdXNlZCBmb3IgdGhlIGV4cGFuZCBpbmRpY2F0b3Igb2Ygbm9kZXNcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICA8bmctdGVtcGxhdGUgaWd4VHJlZUV4cGFuZEluZGljYXRvciBsZXQtZXhwYW5kZWQ+XG4gICAgICogICAgICA8aWd4LWljb24+e3sgZXhwYW5kZWQgPyBcImNsb3NlX2Z1bGxzY3JlZW5cIjogXCJvcGVuX2luX2Z1bGxcIn19PC9pZ3gtaWNvbj5cbiAgICAgKiAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4VHJlZUV4cGFuZEluZGljYXRvckRpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgIHB1YmxpYyBleHBhbmRJbmRpY2F0b3I6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKElneFRyZWVOb2RlQ29tcG9uZW50LCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pXG4gICAgcHVibGljIG5vZGVzOiBRdWVyeUxpc3Q8SWd4VHJlZU5vZGVDb21wb25lbnQ8YW55Pj47XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZGlzYWJsZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPElneFRyZWVOb2RlPGFueT4+KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCAqKnJvb3QgbGV2ZWwqKiBub2Rlc1xuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHRyZWU6IElneFRyZWUgPSB0aGlzLnRyZWU7XG4gICAgICogY29uc3Qgcm9vdE5vZGVzOiBJZ3hUcmVlTm9kZUNvbXBvbmVudDxhbnk+W10gPSB0cmVlLnJvb3ROb2RlcztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHJvb3ROb2RlcygpOiBJZ3hUcmVlTm9kZUNvbXBvbmVudDxhbnk+W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcz8uZmlsdGVyKG5vZGUgPT4gbm9kZS5sZXZlbCA9PT0gMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBhY3RpdmUgbm9kZSBpcyBzZXQgdGhyb3VnaCBBUElcbiAgICAgKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGFjdGl2ZU5vZGVCaW5kaW5nQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxJZ3hUcmVlTm9kZTxhbnk+PigpO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGZvcmNlU2VsZWN0ID0gW107XG5cbiAgICBwcml2YXRlIF9zZWxlY3Rpb246IElneFRyZWVTZWxlY3Rpb25UeXBlID0gSWd4VHJlZVNlbGVjdGlvblR5cGUuTm9uZTtcbiAgICBwcml2YXRlIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBwcml2YXRlIHVuc3ViQ2hpbGRyZW4kID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIG5hdlNlcnZpY2U6IElneFRyZWVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBzZWxlY3Rpb25TZXJ2aWNlOiBJZ3hUcmVlU2VsZWN0aW9uU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSB0cmVlU2VydmljZTogSWd4VHJlZVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRGlzcGxheURlbnNpdHlUb2tlbikgcHJvdGVjdGVkIF9kaXNwbGF5RGVuc2l0eU9wdGlvbnM/OiBJRGlzcGxheURlbnNpdHlPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKF9kaXNwbGF5RGVuc2l0eU9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHRoaXMudHJlZVNlcnZpY2UucmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHRoaXMubmF2U2VydmljZS5yZWdpc3Rlcih0aGlzKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZ2V0IG5hdGl2ZUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIGFsbCBvZiB0aGUgcGFzc2VkIG5vZGVzLlxuICAgICAqIElmIG5vIG5vZGVzIGFyZSBwYXNzZWQsIGV4cGFuZHMgQUxMIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZXMgbm9kZXMgdG8gYmUgZXhwYW5kZWRcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB0YXJnZXROb2RlczogSWd4VHJlZU5vZGU8YW55PiA9IHRoaXMudHJlZS5maW5kTm9kZXModHJ1ZSwgKF9kYXRhOiBhbnksIG5vZGU6IElneFRyZWVOb2RlPGFueT4pID0+IG5vZGUuZGF0YS5leHBhbmRhYmxlKTtcbiAgICAgKiB0cmVlLmV4cGFuZEFsbChub2Rlcyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGV4cGFuZEFsbChub2Rlcz86IElneFRyZWVOb2RlPGFueT5bXSkge1xuICAgICAgICBub2RlcyA9IG5vZGVzIHx8IHRoaXMubm9kZXMudG9BcnJheSgpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGUgPT4gZS5leHBhbmRlZCA9IHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyBhbGwgb2YgdGhlIHBhc3NlZCBub2Rlcy5cbiAgICAgKiBJZiBubyBub2RlcyBhcmUgcGFzc2VkLCBjb2xsYXBzZXMgQUxMIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZXMgbm9kZXMgdG8gYmUgY29sbGFwc2VkXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdGFyZ2V0Tm9kZXM6IElneFRyZWVOb2RlPGFueT4gPSB0aGlzLnRyZWUuZmluZE5vZGVzKHRydWUsIChfZGF0YTogYW55LCBub2RlOiBJZ3hUcmVlTm9kZTxhbnk+KSA9PiBub2RlLmRhdGEuY29sbGFwc2libGUpO1xuICAgICAqIHRyZWUuY29sbGFwc2VBbGwobm9kZXMpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBjb2xsYXBzZUFsbChub2Rlcz86IElneFRyZWVOb2RlPGFueT5bXSkge1xuICAgICAgICBub2RlcyA9IG5vZGVzIHx8IHRoaXMubm9kZXMudG9BcnJheSgpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGUgPT4gZS5leHBhbmRlZCA9IGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdCBhbGwgbm9kZXMgaWYgdGhlIG5vZGVzIGNvbGxlY3Rpb24gaXMgZW1wdHkuIE90aGVyd2lzZSwgZGVzZWxlY3QgdGhlIG5vZGVzIGluIHRoZSBub2RlcyBjb2xsZWN0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogIGNvbnN0IGFyciA9IFtcbiAgICAgKiAgICAgIHRoaXMudHJlZS5ub2Rlcy50b0FycmF5KClbMF0sXG4gICAgICogICAgICB0aGlzLnRyZWUubm9kZXMudG9BcnJheSgpWzFdXG4gICAgICogIF07XG4gICAgICogIHRoaXMudHJlZS5kZXNlbGVjdEFsbChhcnIpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBub2RlczogSWd4VHJlZU5vZGVDb21wb25lbnQ8YW55PltdXG4gICAgICovXG4gICAgcHVibGljIGRlc2VsZWN0QWxsKG5vZGVzPzogSWd4VHJlZU5vZGVDb21wb25lbnQ8YW55PltdKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5kZXNlbGVjdE5vZGVzV2l0aE5vRXZlbnQobm9kZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIG9mIHRoZSBub2RlcyB0aGF0IG1hdGNoIHRoZSBwYXNzZWQgc2VhcmNoVGVybS5cbiAgICAgKiBBY2NlcHRzIGEgY3VzdG9tIGNvbXBhcmVyIGZ1bmN0aW9uIGZvciBldmFsdWF0aW5nIHRoZSBzZWFyY2ggdGVybSBhZ2FpbnN0IHRoZSBub2Rlcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtcbiAgICAgKiBEZWZhdWx0IHNlYXJjaCBjb21wYXJlcyB0aGUgcGFzc2VkIGBzZWFyY2hUZXJtYCBhZ2FpbnN0IHRoZSBub2RlJ3MgYGRhdGFgIElucHV0LlxuICAgICAqIFdoZW4gdXNpbmcgYGZpbmROb2Rlc2Agdy9vIGEgYGNvbXBhcmVyYCwgbWFrZSBzdXJlIGFsbCBub2RlcyBoYXZlIGBkYXRhYCBwYXNzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VhcmNoVGVybSBUaGUgZGF0YSBvZiB0aGUgc2VhcmNoZWQgbm9kZVxuICAgICAqIEBwYXJhbSBjb21wYXJlciBBIGN1c3RvbSBjb21wYXJlciBmdW5jdGlvbiB0aGF0IGV2YWx1YXRlcyB0aGUgcGFzc2VkIGBzZWFyY2hUZXJtYCBhZ2FpbnN0IGFsbCBub2Rlcy5cbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBub2RlcyB0aGF0IG1hdGNoIHRoZSBzZWFyY2guIGBudWxsYCBpZiBubyBub2RlcyBhcmUgZm91bmQuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAgICA8aWd4LXRyZWUtbm9kZSAqbmdGb3I9XCJsZXQgbm9kZSBvZiBkYXRhXCIgW2RhdGFdPVwibm9kZVwiPlxuICAgICAqICAgICAgICAgIHt7IG5vZGUubGFiZWwgfX1cbiAgICAgKiAgICAgPC9pZ3gtdHJlZS1ub2RlPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRhdGE6IERhdGFFbnRyeVtdID0gRkVUQ0hFRF9EQVRBO1xuICAgICAqIC4uLlxuICAgICAqIGNvbnN0IG1hdGNoZWROb2RlczogSWd4VHJlZU5vZGU8RGF0YUVudHJ5PltdID0gdGhpcy50cmVlLmZpbmROb2RlczxEYXRhRW50cnk+KHNlYXJjaFRlcm06IGRhdGFbNV0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVXNpbmcgYSBjdXN0b20gY29tcGFyZXJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRhdGE6IERhdGFFbnRyeVtdID0gRkVUQ0hFRF9EQVRBO1xuICAgICAqIC4uLlxuICAgICAqIGNvbnN0IGNvbXBhcmVyOiBJZ3hUcmVlU2VhcmNoUmVzb2x2ZXIgPSAoZGF0YTogYW55LCBub2RlOiBJZ3hUcmVlTm9kZTxEYXRhRW50cnk+KSB7XG4gICAgICogICAgICByZXR1cm4gbm9kZS5kYXRhLmluZGV4ICUgMiA9PT0gMDtcbiAgICAgKiB9XG4gICAgICogY29uc3QgZXZlbkluZGV4Tm9kZXM6IElneFRyZWVOb2RlPERhdGFFbnRyeT5bXSA9IHRoaXMudHJlZS5maW5kTm9kZXM8RGF0YUVudHJ5PihudWxsLCBjb21wYXJlcik7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGZpbmROb2RlcyhzZWFyY2hUZXJtOiBhbnksIGNvbXBhcmVyPzogSWd4VHJlZVNlYXJjaFJlc29sdmVyKTogSWd4VHJlZU5vZGVDb21wb25lbnQ8YW55PltdIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvbXBhcmVGdW5jID0gY29tcGFyZXIgfHwgdGhpcy5fY29tcGFyZXI7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLm5vZGVzLmZpbHRlcihub2RlID0+IGNvbXBhcmVGdW5jKHNlYXJjaFRlcm0sIG5vZGUpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM/Lmxlbmd0aCA9PT0gMCA/IG51bGwgOiByZXN1bHRzO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBoYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIHRoaXMubmF2U2VydmljZS5oYW5kbGVLZXlkb3duKGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWRDaGFuZ2UucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLnVwZGF0ZV9kaXNhYmxlZF9jYWNoZShlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWN0aXZlTm9kZUJpbmRpbmdDaGFuZ2UucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgobm9kZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRUb05vZGUodGhpcy5uYXZTZXJ2aWNlLmFjdGl2ZU5vZGUpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxOb2RlSW50b1ZpZXcobm9kZT8uaGVhZGVyPy5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVuc2l0eUNoYW5nZWQucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTm9kZUludG9WaWV3KHRoaXMubmF2U2VydmljZS5hY3RpdmVOb2RlPy5oZWFkZXIubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3ViVG9Db2xsYXBzaW5nKCk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5ub2Rlcy5jaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJUb0NoYW5nZXMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsTm9kZUludG9WaWV3KHRoaXMubmF2U2VydmljZS5hY3RpdmVOb2RlPy5oZWFkZXI/Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB0aGlzLnN1YlRvQ2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy51bnN1YkNoaWxkcmVuJC5uZXh0KCk7XG4gICAgICAgIHRoaXMudW5zdWJDaGlsZHJlbiQuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGV4cGFuZFRvTm9kZShub2RlOiBJZ3hUcmVlTm9kZTxhbnk+KSB7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXRoLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG4gIT09IG5vZGUgJiYgIW4uZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbi5leHBhbmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN1YlRvQ29sbGFwc2luZygpIHtcbiAgICAgICAgdGhpcy5ub2RlQ29sbGFwc2luZy5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5hdlNlcnZpY2UudXBkYXRlX3Zpc2libGVfY2FjaGUoZXZlbnQubm9kZSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub2RlRXhwYW5kaW5nLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmNhbmNlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmF2U2VydmljZS51cGRhdGVfdmlzaWJsZV9jYWNoZShldmVudC5ub2RlLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdWJUb0NoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMudW5zdWJDaGlsZHJlbiQubmV4dCgpO1xuICAgICAgICBjb25zdCB0b0JlU2VsZWN0ZWQgPSBbLi4udGhpcy5mb3JjZVNlbGVjdF07XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0Tm9kZXNXaXRoTm9FdmVudCh0b0JlU2VsZWN0ZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mb3JjZVNlbGVjdCA9IFtdO1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBub2RlLmV4cGFuZGVkQ2hhbmdlLnBpcGUodGFrZVVudGlsKHRoaXMudW5zdWJDaGlsZHJlbiQpKS5zdWJzY3JpYmUobm9kZVN0YXRlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdlNlcnZpY2UudXBkYXRlX3Zpc2libGVfY2FjaGUobm9kZSwgbm9kZVN0YXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbm9kZS5jbG9zZUFuaW1hdGlvbkRvbmUucGlwZSh0YWtlVW50aWwodGhpcy51bnN1YkNoaWxkcmVuJCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IHRoaXMubmF2U2VydmljZS5mb2N1c2VkTm9kZT8uaGVhZGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxOb2RlSW50b1ZpZXcodGFyZ2V0RWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUub3BlbkFuaW1hdGlvbkRvbmUucGlwZSh0YWtlVW50aWwodGhpcy51bnN1YkNoaWxkcmVuJCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IHRoaXMubmF2U2VydmljZS5mb2N1c2VkTm9kZT8uaGVhZGVyLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxOb2RlSW50b1ZpZXcodGFyZ2V0RWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmF2U2VydmljZS5pbml0X2ludmlzaWJsZV9jYWNoZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2Nyb2xsTm9kZUludG9WaWV3KGVsOiBIVE1MRWxlbWVudCkge1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgdHJlZVJlY3QgPSB0aGlzLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRvcE9mZnNldCA9IHRyZWVSZWN0LnRvcCA+IG5vZGVSZWN0LnRvcCA/IG5vZGVSZWN0LnRvcCAtIHRyZWVSZWN0LnRvcCA6IDA7XG4gICAgICAgIGNvbnN0IGJvdHRvbU9mZnNldCA9IHRyZWVSZWN0LmJvdHRvbSA8IG5vZGVSZWN0LmJvdHRvbSA/IG5vZGVSZWN0LmJvdHRvbSAtIHRyZWVSZWN0LmJvdHRvbSA6IDA7XG4gICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9ICEhdG9wT2Zmc2V0IHx8ICEhYm90dG9tT2Zmc2V0O1xuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsICYmIHRoaXMubmF0aXZlRWxlbWVudC5zY3JvbGxIZWlnaHQgPiB0aGlzLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gbm9kZVJlY3QueSAtIHRyZWVSZWN0LnkgLSBub2RlUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID1cbiAgICAgICAgICAgIHRoaXMubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgKyBib3R0b21PZmZzZXQgKyB0b3BPZmZzZXQgKyAodG9wT2Zmc2V0ID8gLTEgOiArMSkgKiBub2RlUmVjdC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9jb21wYXJlciA9IDxUPihkYXRhOiBULCBub2RlOiBJZ3hUcmVlTm9kZUNvbXBvbmVudDxUPikgPT4gbm9kZS5kYXRhID09PSBkYXRhO1xuXG59XG4iLCI8ZGl2IGNsYXNzPVwiaWd4LXRyZWVfX3Jvb3RcIiByb2xlPVwidHJlZVwiIChrZXlkb3duKT1cImhhbmRsZUtleWRvd24oJGV2ZW50KVwiPlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImlneC10cmVlLW5vZGVcIj48L25nLWNvbnRlbnQ+XG48L2Rpdj5cbiJdfQ==