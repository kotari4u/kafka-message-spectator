import { Inject, Injectable } from '@angular/core';
import { ɵgetDOM as getDOM } from '@angular/platform-browser';
import { DOCUMENT } from '@angular/common';
import * as i0 from "@angular/core";
import * as i1 from "./utils";
const EVENT_SUFFIX = 'precise';
/**
 * Touch gestures manager based on Hammer.js
 * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.
 *
 * @hidden
 */
export class HammerGesturesManager {
    constructor(_zone, doc, platformUtil) {
        this._zone = _zone;
        this.doc = doc;
        this.platformUtil = platformUtil;
        /**
         * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
         */
        this.hammerOptions = {};
        this._hammerManagers = [];
        this.platformBrowser = this.platformUtil.isBrowser;
        if (this.platformBrowser) {
            this.hammerOptions = {
                // D.P. #447 Force TouchInput due to PointerEventInput bug (https://github.com/hammerjs/hammer.js/issues/1065)
                // see https://github.com/IgniteUI/igniteui-angular/issues/447#issuecomment-324601803
                inputClass: Hammer.TouchInput,
                recognizers: [
                    [Hammer.Pan, { threshold: 0 }],
                    [Hammer.Swipe, { direction: Hammer.DIRECTION_HORIZONTAL }],
                    [Hammer.Tap],
                    [Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']]
                ]
            };
        }
    }
    supports(eventName) {
        return eventName.toLowerCase().endsWith('.' + EVENT_SUFFIX);
    }
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     */
    addEventListener(element, eventName, eventHandler, options = null) {
        if (!this.platformBrowser) {
            return;
        }
        // Creating the manager bind events, must be done outside of angular
        return this._zone.runOutsideAngular(() => {
            let mc = this.getManagerForElement(element);
            if (mc === null) {
                // new Hammer is a shortcut for Manager with defaults
                mc = new Hammer(element, Object.assign(this.hammerOptions, options));
                this.addManagerForElement(element, mc);
            }
            const handler = (eventObj) => this._zone.run(() => eventHandler(eventObj));
            mc.on(eventName, handler);
            return () => mc.off(eventName, handler);
        });
    }
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     *
     * @param target Can be one of either window, body or document(fallback default).
     */
    addGlobalEventListener(target, eventName, eventHandler) {
        if (!this.platformBrowser) {
            return;
        }
        const element = this.getGlobalEventTarget(target);
        // Creating the manager bind events, must be done outside of angular
        return this.addEventListener(element, eventName, eventHandler);
    }
    /**
     * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
     * Supported: window, document, body. Defaults to document for invalid args.
     *
     * @param target Target name
     */
    getGlobalEventTarget(target) {
        return getDOM().getGlobalEventTarget(this.doc, target);
    }
    /**
     * Set HammerManager options.
     *
     * @param element The DOM element used to create the manager on.
     *
     * ### Example
     *
     * ```ts
     * manager.setManagerOption(myElem, "pan", { pointers: 1 });
     * ```
     */
    setManagerOption(element, event, options) {
        const manager = this.getManagerForElement(element);
        manager.get(event).set(options);
    }
    /**
     * Add an element and manager map to the internal collection.
     *
     * @param element The DOM element used to create the manager on.
     */
    addManagerForElement(element, manager) {
        this._hammerManagers.push({ element, manager });
    }
    /**
     * Get HammerManager for the element or null
     *
     * @param element The DOM element used to create the manager on.
     */
    getManagerForElement(element) {
        const result = this._hammerManagers.filter(value => value.element === element);
        return result.length ? result[0].manager : null;
    }
    /**
     * Destroys the HammerManager for the element, removing event listeners in the process.
     *
     * @param element The DOM element used to create the manager on.
     */
    removeManagerForElement(element) {
        let index = null;
        for (let i = 0; i < this._hammerManagers.length; i++) {
            if (element === this._hammerManagers[i].element) {
                index = i;
                break;
            }
        }
        if (index !== null) {
            const item = this._hammerManagers.splice(index, 1)[0];
            // destroy also
            item.manager.destroy();
        }
    }
    /** Destroys all internally tracked HammerManagers, removing event listeners in the process. */
    destroy() {
        for (const item of this._hammerManagers) {
            item.manager.destroy();
        }
        this._hammerManagers = [];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: HammerGesturesManager, deps: [{ token: i0.NgZone }, { token: DOCUMENT }, { token: i1.PlatformUtil }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: HammerGesturesManager }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: HammerGesturesManager, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i1.PlatformUtil }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG91Y2guanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvY29yZS90b3VjaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUMzRCxPQUFPLEVBQUUsT0FBTyxJQUFJLE1BQU0sRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzlELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQzs7O0FBRzNDLE1BQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQztBQUUvQjs7Ozs7R0FLRztBQUVILE1BQU0sT0FBTyxxQkFBcUI7SUFTOUIsWUFBb0IsS0FBYSxFQUE0QixHQUFRLEVBQVUsWUFBMEI7UUFBckYsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQUE0QixRQUFHLEdBQUgsR0FBRyxDQUFLO1FBQVUsaUJBQVksR0FBWixZQUFZLENBQWM7UUFSekc7O1dBRUc7UUFDTyxrQkFBYSxHQUFrQixFQUFFLENBQUM7UUFHcEMsb0JBQWUsR0FBNEQsRUFBRSxDQUFDO1FBR2xGLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUM7UUFDbkQsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxhQUFhLEdBQUc7Z0JBQ2pCLDhHQUE4RztnQkFDOUcscUZBQXFGO2dCQUNyRixVQUFVLEVBQUUsTUFBTSxDQUFDLFVBQVU7Z0JBQzdCLFdBQVcsRUFBRTtvQkFDVCxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsRUFBRSxTQUFTLEVBQUUsQ0FBQyxFQUFFLENBQUM7b0JBQzlCLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztvQkFDMUQsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDO29CQUNaLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ3pEO2FBQ0osQ0FBQztTQUNMO0lBQ0wsQ0FBQztJQUVNLFFBQVEsQ0FBQyxTQUFpQjtRQUM3QixPQUFPLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsR0FBRyxHQUFHLFlBQVksQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUFFRDs7O09BR0c7SUFDSSxnQkFBZ0IsQ0FDbkIsT0FBb0IsRUFDcEIsU0FBaUIsRUFDakIsWUFBZ0MsRUFDaEMsVUFBeUIsSUFBSTtRQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN2QixPQUFPO1NBQ1Y7UUFFRCxvRUFBb0U7UUFDcEUsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtZQUNyQyxJQUFJLEVBQUUsR0FBa0IsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzNELElBQUksRUFBRSxLQUFLLElBQUksRUFBRTtnQkFDYixxREFBcUQ7Z0JBQ3JELEVBQUUsR0FBRyxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7Z0JBQ3JFLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7YUFDMUM7WUFDRCxNQUFNLE9BQU8sR0FBRyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDM0UsRUFBRSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDMUIsT0FBTyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUM1QyxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLHNCQUFzQixDQUFDLE1BQWMsRUFBRSxTQUFpQixFQUFFLFlBQWdDO1FBQzdGLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3ZCLE9BQU87U0FDVjtRQUVELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVsRCxvRUFBb0U7UUFDcEUsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBc0IsRUFBRSxTQUFTLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDbEYsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksb0JBQW9CLENBQUMsTUFBYztRQUN0QyxPQUFPLE1BQU0sRUFBRSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSSxnQkFBZ0IsQ0FBQyxPQUFvQixFQUFFLEtBQWEsRUFBRSxPQUFZO1FBQ3JFLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNuRCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLG9CQUFvQixDQUFDLE9BQW9CLEVBQUUsT0FBc0I7UUFDcEUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsRUFBQyxPQUFPLEVBQUUsT0FBTyxFQUFDLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLG9CQUFvQixDQUFDLE9BQW9CO1FBQzVDLE1BQU0sTUFBTSxHQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sS0FBSyxPQUFPLENBQUMsQ0FBQztRQUNoRixPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUNwRCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLHVCQUF1QixDQUFDLE9BQW9CO1FBQy9DLElBQUksS0FBSyxHQUFXLElBQUksQ0FBQztRQUN6QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbEQsSUFBSSxPQUFPLEtBQUssSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUU7Z0JBQzdDLEtBQUssR0FBRyxDQUFDLENBQUM7Z0JBQ1YsTUFBTTthQUNUO1NBQ0o7UUFDRCxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3RELGVBQWU7WUFDZixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQzFCO0lBQ0wsQ0FBQztJQUVELCtGQUErRjtJQUN4RixPQUFPO1FBQ1YsS0FBSyxNQUFNLElBQUksSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3JDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDMUI7UUFDRCxJQUFJLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQztJQUM5QixDQUFDOzhHQWpKUSxxQkFBcUIsd0NBU2EsUUFBUTtrSEFUMUMscUJBQXFCOzsyRkFBckIscUJBQXFCO2tCQURqQyxVQUFVOzswQkFVNkIsTUFBTTsyQkFBQyxRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IMm1Z2V0RE9NIGFzIGdldERPTSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgUGxhdGZvcm1VdGlsIH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IEVWRU5UX1NVRkZJWCA9ICdwcmVjaXNlJztcblxuLyoqXG4gKiBUb3VjaCBnZXN0dXJlcyBtYW5hZ2VyIGJhc2VkIG9uIEhhbW1lci5qc1xuICogVXNlIHdpdGggY2F1dGlvbiwgdGhpcyB3aWxsIHRyYWNrIHJlZmVyZW5jZXMgZm9yIHNpbmdsZSBtYW5hZ2VyIHBlciBlbGVtZW50LiBWZXJ5IFRCRC4gTXVjaCBUT0RPLlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEhhbW1lckdlc3R1cmVzTWFuYWdlciB7XG4gICAgLyoqXG4gICAgICogRXZlbnQgb3B0aW9uIGRlZmF1bHRzIGZvciBlYWNoIHJlY29nbml6ZXIsIHNlZSBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL2FwaS8gZm9yIEFQSSBsaXN0aW5nLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBoYW1tZXJPcHRpb25zOiBIYW1tZXJPcHRpb25zID0ge307XG5cbiAgICBwcml2YXRlIHBsYXRmb3JtQnJvd3NlcjogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9oYW1tZXJNYW5hZ2VyczogQXJyYXk8eyBlbGVtZW50OiBFdmVudFRhcmdldDsgbWFuYWdlcjogSGFtbWVyTWFuYWdlciB9PiA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfem9uZTogTmdab25lLCBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIGRvYzogYW55LCBwcml2YXRlIHBsYXRmb3JtVXRpbDogUGxhdGZvcm1VdGlsKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm1Ccm93c2VyID0gdGhpcy5wbGF0Zm9ybVV0aWwuaXNCcm93c2VyO1xuICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybUJyb3dzZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFtbWVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAvLyBELlAuICM0NDcgRm9yY2UgVG91Y2hJbnB1dCBkdWUgdG8gUG9pbnRlckV2ZW50SW5wdXQgYnVnIChodHRwczovL2dpdGh1Yi5jb20vaGFtbWVyanMvaGFtbWVyLmpzL2lzc3Vlcy8xMDY1KVxuICAgICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vSWduaXRlVUkvaWduaXRldWktYW5ndWxhci9pc3N1ZXMvNDQ3I2lzc3VlY29tbWVudC0zMjQ2MDE4MDNcbiAgICAgICAgICAgICAgICBpbnB1dENsYXNzOiBIYW1tZXIuVG91Y2hJbnB1dCxcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyczogW1xuICAgICAgICAgICAgICAgICAgICBbSGFtbWVyLlBhbiwgeyB0aHJlc2hvbGQ6IDAgfV0sXG4gICAgICAgICAgICAgICAgICAgIFtIYW1tZXIuU3dpcGUsIHsgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwgfV0sXG4gICAgICAgICAgICAgICAgICAgIFtIYW1tZXIuVGFwXSxcbiAgICAgICAgICAgICAgICAgICAgW0hhbW1lci5UYXAsIHsgZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyIH0sIFsndGFwJ11dXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzdXBwb3J0cyhldmVudE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy4nICsgRVZFTlRfU1VGRklYKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgbGlzdGVuZXIgZXh0ZW5kZWQgd2l0aCBvcHRpb25zIGZvciBIYW1tZXIuanMuIFdpbGwgdXNlIGRlZmF1bHRzIGlmIG5vbmUgYXJlIHByb3ZpZGVkLlxuICAgICAqIE1vZGVsaW5nIGFmdGVyIG90aGVyIGV2ZW50IHBsdWdpbnMgZm9yIGVhc3kgZnV0dXJlIG1vZGlmaWNhdGlvbnMuXG4gICAgICovXG4gICAgcHVibGljIGFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIGVsZW1lbnQ6IEhUTUxFbGVtZW50LFxuICAgICAgICBldmVudE5hbWU6IHN0cmluZyxcbiAgICAgICAgZXZlbnRIYW5kbGVyOiAoZXZlbnRPYmopID0+IHZvaWQsXG4gICAgICAgIG9wdGlvbnM6IEhhbW1lck9wdGlvbnMgPSBudWxsKTogKCkgPT4gdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5wbGF0Zm9ybUJyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0aW5nIHRoZSBtYW5hZ2VyIGJpbmQgZXZlbnRzLCBtdXN0IGJlIGRvbmUgb3V0c2lkZSBvZiBhbmd1bGFyXG4gICAgICAgIHJldHVybiB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBtYzogSGFtbWVyTWFuYWdlciA9IHRoaXMuZ2V0TWFuYWdlckZvckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAobWMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBuZXcgSGFtbWVyIGlzIGEgc2hvcnRjdXQgZm9yIE1hbmFnZXIgd2l0aCBkZWZhdWx0c1xuICAgICAgICAgICAgICAgIG1jID0gbmV3IEhhbW1lcihlbGVtZW50LCBPYmplY3QuYXNzaWduKHRoaXMuaGFtbWVyT3B0aW9ucywgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTWFuYWdlckZvckVsZW1lbnQoZWxlbWVudCwgbWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IChldmVudE9iaikgPT4gdGhpcy5fem9uZS5ydW4oKCkgPT4gZXZlbnRIYW5kbGVyKGV2ZW50T2JqKSk7XG4gICAgICAgICAgICBtYy5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IG1jLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgbGlzdGVuZXIgZXh0ZW5kZWQgd2l0aCBvcHRpb25zIGZvciBIYW1tZXIuanMuIFdpbGwgdXNlIGRlZmF1bHRzIGlmIG5vbmUgYXJlIHByb3ZpZGVkLlxuICAgICAqIE1vZGVsaW5nIGFmdGVyIG90aGVyIGV2ZW50IHBsdWdpbnMgZm9yIGVhc3kgZnV0dXJlIG1vZGlmaWNhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IENhbiBiZSBvbmUgb2YgZWl0aGVyIHdpbmRvdywgYm9keSBvciBkb2N1bWVudChmYWxsYmFjayBkZWZhdWx0KS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0YXJnZXQ6IHN0cmluZywgZXZlbnROYW1lOiBzdHJpbmcsIGV2ZW50SGFuZGxlcjogKGV2ZW50T2JqKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5wbGF0Zm9ybUJyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmdldEdsb2JhbEV2ZW50VGFyZ2V0KHRhcmdldCk7XG5cbiAgICAgICAgLy8gQ3JlYXRpbmcgdGhlIG1hbmFnZXIgYmluZCBldmVudHMsIG11c3QgYmUgZG9uZSBvdXRzaWRlIG9mIGFuZ3VsYXJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50IGFzIEhUTUxFbGVtZW50LCBldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwb3NlcyBbRG9tXUFkYXB0ZXIuZ2V0R2xvYmFsRXZlbnRUYXJnZXQgdG8gZ2V0IGdsb2JhbCBldmVudCB0YXJnZXRzLlxuICAgICAqIFN1cHBvcnRlZDogd2luZG93LCBkb2N1bWVudCwgYm9keS4gRGVmYXVsdHMgdG8gZG9jdW1lbnQgZm9yIGludmFsaWQgYXJncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXQgVGFyZ2V0IG5hbWVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0R2xvYmFsRXZlbnRUYXJnZXQodGFyZ2V0OiBzdHJpbmcpOiBFdmVudFRhcmdldCB7XG4gICAgICAgIHJldHVybiBnZXRET00oKS5nZXRHbG9iYWxFdmVudFRhcmdldCh0aGlzLmRvYywgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgSGFtbWVyTWFuYWdlciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIERPTSBlbGVtZW50IHVzZWQgdG8gY3JlYXRlIHRoZSBtYW5hZ2VyIG9uLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbWFuYWdlci5zZXRNYW5hZ2VyT3B0aW9uKG15RWxlbSwgXCJwYW5cIiwgeyBwb2ludGVyczogMSB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0TWFuYWdlck9wdGlvbihlbGVtZW50OiBFdmVudFRhcmdldCwgZXZlbnQ6IHN0cmluZywgb3B0aW9uczogYW55KSB7XG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSB0aGlzLmdldE1hbmFnZXJGb3JFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBtYW5hZ2VyLmdldChldmVudCkuc2V0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBlbGVtZW50IGFuZCBtYW5hZ2VyIG1hcCB0byB0aGUgaW50ZXJuYWwgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBET00gZWxlbWVudCB1c2VkIHRvIGNyZWF0ZSB0aGUgbWFuYWdlciBvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkTWFuYWdlckZvckVsZW1lbnQoZWxlbWVudDogRXZlbnRUYXJnZXQsIG1hbmFnZXI6IEhhbW1lck1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5faGFtbWVyTWFuYWdlcnMucHVzaCh7ZWxlbWVudCwgbWFuYWdlcn0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBIYW1tZXJNYW5hZ2VyIGZvciB0aGUgZWxlbWVudCBvciBudWxsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgdXNlZCB0byBjcmVhdGUgdGhlIG1hbmFnZXIgb24uXG4gICAgICovXG4gICAgcHVibGljIGdldE1hbmFnZXJGb3JFbGVtZW50KGVsZW1lbnQ6IEV2ZW50VGFyZ2V0KTogSGFtbWVyTWFuYWdlciB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICB0aGlzLl9oYW1tZXJNYW5hZ2Vycy5maWx0ZXIodmFsdWUgPT4gdmFsdWUuZWxlbWVudCA9PT0gZWxlbWVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID8gcmVzdWx0WzBdLm1hbmFnZXIgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBIYW1tZXJNYW5hZ2VyIGZvciB0aGUgZWxlbWVudCwgcmVtb3ZpbmcgZXZlbnQgbGlzdGVuZXJzIGluIHRoZSBwcm9jZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIERPTSBlbGVtZW50IHVzZWQgdG8gY3JlYXRlIHRoZSBtYW5hZ2VyIG9uLlxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVNYW5hZ2VyRm9yRWxlbWVudChlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBsZXQgaW5kZXg6IG51bWJlciA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faGFtbWVyTWFuYWdlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLl9oYW1tZXJNYW5hZ2Vyc1tpXS5lbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2hhbW1lck1hbmFnZXJzLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgICAgICAgICAvLyBkZXN0cm95IGFsc29cbiAgICAgICAgICAgIGl0ZW0ubWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRGVzdHJveXMgYWxsIGludGVybmFsbHkgdHJhY2tlZCBIYW1tZXJNYW5hZ2VycywgcmVtb3ZpbmcgZXZlbnQgbGlzdGVuZXJzIGluIHRoZSBwcm9jZXNzLiAqL1xuICAgIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faGFtbWVyTWFuYWdlcnMpIHtcbiAgICAgICAgICAgIGl0ZW0ubWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFtbWVyTWFuYWdlcnMgPSBbXTtcbiAgICB9XG59XG4iXX0=