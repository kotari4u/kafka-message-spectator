import { PagingError } from './paging-state.interface';
import { mergeObjects, mkenum } from '../core/utils';
import { TransactionType } from '../services/transaction/transaction';
import { getHierarchy, isHierarchyMatch } from './operations';
import { IgxDataRecordSorting, IgxSorting, IgxGrouping } from '../grids/common/strategy';
import { DefaultDataCloneStrategy } from '../data-operations/data-clone-strategy';
/**
 * @hidden
 */
export const DataType = mkenum({
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Date: 'date',
    DateTime: 'dateTime',
    Time: 'time',
    Currency: 'currency',
    Percent: 'percent',
    Image: 'image'
});
/**
 * @hidden
 */
export const GridColumnDataType = DataType;
/**
 * @hidden
 */
export class DataUtil {
    static sort(data, expressions, sorting = new IgxSorting(), grid) {
        return sorting.sort(data, expressions, grid);
    }
    static treeGridSort(hierarchicalData, expressions, sorting = new IgxDataRecordSorting(), parent, grid) {
        let res = [];
        hierarchicalData.forEach((hr) => {
            const rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;
            if (rec.children) {
                rec.children = DataUtil.treeGridSort(rec.children, expressions, sorting, rec, grid);
            }
            res.push(rec);
        });
        res = DataUtil.sort(res, expressions, sorting, grid);
        return res;
    }
    static cloneTreeGridRecord(hierarchicalRecord) {
        const rec = {
            key: hierarchicalRecord.key,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
        };
        return rec;
    }
    static group(data, state, grouping = new IgxGrouping(), grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        groupsRecords.splice(0, groupsRecords.length);
        return grouping.groupBy(data, state, grid, groupsRecords, fullResult);
    }
    static page(data, state, dataLength) {
        if (!state) {
            return data;
        }
        const len = dataLength !== undefined ? dataLength : data.length;
        const index = state.index;
        const res = [];
        const recordsPerPage = dataLength !== undefined && state.recordsPerPage > dataLength ? dataLength : state.recordsPerPage;
        state.metadata = {
            countPages: 0,
            countRecords: len,
            error: PagingError.None
        };
        if (index < 0 || isNaN(index)) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
        }
        state.metadata.countPages = Math.ceil(len / recordsPerPage);
        if (!len) {
            return data;
        }
        if (index >= state.metadata.countPages) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
    }
    static correctPagingState(state, length) {
        const maxPage = Math.ceil(length / state.recordsPerPage) - 1;
        if (!isNaN(maxPage) && state.index > maxPage) {
            state.index = maxPage;
        }
    }
    static getHierarchy(gRow) {
        return getHierarchy(gRow);
    }
    static isHierarchyMatch(h1, h2, expressions) {
        return isHierarchyMatch(h1, h2, expressions);
    }
    /**
     * Merges all changes from provided transactions into provided data collection
     *
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    static mergeTransactions(data, transactions, primaryKey, cloneStrategy = new DefaultDataCloneStrategy(), deleteRows = false) {
        data.forEach((item, index) => {
            const rowId = primaryKey ? item[primaryKey] : item;
            const transaction = transactions.find(t => t.id === rowId);
            if (transaction && transaction.type === TransactionType.UPDATE) {
                data[index] = mergeObjects(cloneStrategy.clone(data[index]), transaction.newValue);
            }
        });
        if (deleteRows) {
            transactions
                .filter(t => t.type === TransactionType.DELETE)
                .forEach(t => {
                const index = primaryKey ? data.findIndex(d => d[primaryKey] === t.id) : data.findIndex(d => d === t.id);
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
            });
        }
        data.push(...transactions
            .filter(t => t.type === TransactionType.ADD)
            .map(t => t.newValue));
        return data;
    }
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     *
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param childDataKey Data key of child collections
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    static mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, cloneStrategy = new DefaultDataCloneStrategy(), deleteRows = false) {
        for (const transaction of transactions) {
            if (transaction.path) {
                const parent = this.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                let collection = parent ? parent[childDataKey] : data;
                switch (transaction.type) {
                    case TransactionType.ADD:
                        //  if there is no parent this is ADD row at root level
                        if (parent && !parent[childDataKey]) {
                            parent[childDataKey] = collection = [];
                        }
                        collection.push(transaction.newValue);
                        break;
                    case TransactionType.UPDATE:
                        const updateIndex = collection.findIndex(x => x[primaryKey] === transaction.id);
                        if (updateIndex !== -1) {
                            collection[updateIndex] = mergeObjects(cloneStrategy.clone(collection[updateIndex]), transaction.newValue);
                        }
                        break;
                    case TransactionType.DELETE:
                        if (deleteRows) {
                            const deleteIndex = collection.findIndex(r => r[primaryKey] === transaction.id);
                            if (deleteIndex !== -1) {
                                collection.splice(deleteIndex, 1);
                            }
                        }
                        break;
                }
            }
            else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
            }
        }
        return data;
    }
    static parseValue(dataType, value) {
        if (dataType === GridColumnDataType.Number || dataType === GridColumnDataType.Currency || dataType === GridColumnDataType.Percent) {
            value = parseFloat(value);
        }
        return value;
    }
    static findParentFromPath(data, primaryKey, childDataKey, path) {
        let collection = data;
        let result;
        for (const id of path) {
            result = collection && collection.find(x => x[primaryKey] === id);
            if (!result) {
                break;
            }
            collection = result[childDataKey];
        }
        return result;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS11dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2RhdGEtb3BlcmF0aW9ucy9kYXRhLXV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFnQixXQUFXLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUtyRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRCxPQUFPLEVBQWUsZUFBZSxFQUEyQixNQUFNLHFDQUFxQyxDQUFDO0FBQzVHLE9BQU8sRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFJOUQsT0FBTyxFQUdILG9CQUFvQixFQUNwQixVQUFVLEVBQ1YsV0FBVyxFQUNkLE1BQU0sMEJBQTBCLENBQUM7QUFDbEMsT0FBTyxFQUFFLHdCQUF3QixFQUFzQixNQUFNLHdDQUF3QyxDQUFDO0FBR3RHOztHQUVHO0FBQ0YsTUFBTSxDQUFDLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQztJQUM1QixNQUFNLEVBQUUsUUFBUTtJQUNoQixNQUFNLEVBQUUsUUFBUTtJQUNoQixPQUFPLEVBQUUsU0FBUztJQUNsQixJQUFJLEVBQUUsTUFBTTtJQUNaLFFBQVEsRUFBRSxVQUFVO0lBQ3BCLElBQUksRUFBRSxNQUFNO0lBQ1osUUFBUSxFQUFFLFVBQVU7SUFDcEIsT0FBTyxFQUFFLFNBQVM7SUFDbEIsS0FBSyxFQUFFLE9BQU87Q0FDakIsQ0FBQyxDQUFDO0FBR0g7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSxrQkFBa0IsR0FBRyxRQUFRLENBQUM7QUFHM0M7O0dBRUc7QUFDSCxNQUFNLE9BQU8sUUFBUTtJQUNWLE1BQU0sQ0FBQyxJQUFJLENBQUksSUFBUyxFQUFFLFdBQWlDLEVBQUUsVUFBZ0MsSUFBSSxVQUFVLEVBQUUsRUFDaEgsSUFBZTtRQUNmLE9BQU8sT0FB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LElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDbkM7U0FDSjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQTRCLEVBQUUsS0FBVTtRQUM3RCxJQUFJLFFBQVEsS0FBSyxrQkFBa0IsQ0FBQyxNQUFNLElBQUksUUFBUSxLQUFLLGtCQUFrQixDQUFDLFFBQVEsSUFBSSxRQUFRLEtBQUssa0JBQWtCLENBQUMsT0FBTyxFQUFFO1lBQy9ILEtBQUssR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDN0I7UUFFRCxPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDO0lBRU8sTUFBTSxDQUFDLGtCQUFrQixDQUFDLElBQVcsRUFBRSxVQUFlLEVBQUUsWUFBaUIsRUFBRSxJQUFXO1FBQzFGLElBQUksVUFBVSxHQUFVLElBQUksQ0FBQztRQUM3QixJQUFJLE1BQVcsQ0FBQztRQUVoQixLQUFLLE1BQU0sRUFBRSxJQUFJLElBQUksRUFBRTtZQUNuQixNQUFNLEdBQUcsVUFBVSxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDbEUsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDVCxNQUFNO2FBQ1Q7WUFFRCxVQUFVLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ3JDO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUdyb3VwQnlSZXN1bHQgfSBmcm9tICcuL2dyb3VwaW5nLXJlc3VsdC5pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBJUGFnaW5nU3RhdGUsIFBhZ2luZ0Vycm9yIH0gZnJvbSAnLi9wYWdpbmctc3RhdGUuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgSUdyb3VwQnlLZXkgfSBmcm9tICcuL2dyb3VwYnktZXhwYW5kLXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJR3JvdXBCeVJlY29yZCB9IGZyb20gJy4vZ3JvdXBieS1yZWNvcmQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElHcm91cGluZ1N0YXRlIH0gZnJvbSAnLi9ncm91cGJ5LXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBtZXJnZU9iamVjdHMsIG1rZW51bSB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uVHlwZSwgSGllcmFyY2hpY2FsVHJhbnNhY3Rpb24gfSBmcm9tICcuLi9zZXJ2aWNlcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBnZXRIaWVyYXJjaHksIGlzSGllcmFyY2h5TWF0Y2ggfSBmcm9tICcuL29wZXJhdGlvbnMnO1xuaW1wb3J0IHsgR3JpZFR5cGUgfSBmcm9tICcuLi9ncmlkcy9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSVRyZWVHcmlkUmVjb3JkIH0gZnJvbSAnLi4vZ3JpZHMvdHJlZS1ncmlkL3RyZWUtZ3JpZC5pbnRlcmZhY2VzJztcbmltcG9ydCB7IElTb3J0aW5nRXhwcmVzc2lvbiB9IGZyb20gJy4vc29ydGluZy1zdHJhdGVneSc7XG5pbXBvcnQge1xuICAgIElHcmlkU29ydGluZ1N0cmF0ZWd5LFxuICAgIElHcmlkR3JvdXBpbmdTdHJhdGVneSxcbiAgICBJZ3hEYXRhUmVjb3JkU29ydGluZyxcbiAgICBJZ3hTb3J0aW5nLFxuICAgIElneEdyb3VwaW5nXG59IGZyb20gJy4uL2dyaWRzL2NvbW1vbi9zdHJhdGVneSc7XG5pbXBvcnQgeyBEZWZhdWx0RGF0YUNsb25lU3RyYXRlZ3ksIElEYXRhQ2xvbmVTdHJhdGVneSB9IGZyb20gJy4uL2RhdGEtb3BlcmF0aW9ucy9kYXRhLWNsb25lLXN0cmF0ZWd5JztcbmltcG9ydCB7IElHcm91cGluZ0V4cHJlc3Npb24gfSBmcm9tICcuL2dyb3VwaW5nLWV4cHJlc3Npb24uaW50ZXJmYWNlJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbiBleHBvcnQgY29uc3QgRGF0YVR5cGUgPSBta2VudW0oe1xuICAgIFN0cmluZzogJ3N0cmluZycsXG4gICAgTnVtYmVyOiAnbnVtYmVyJyxcbiAgICBCb29sZWFuOiAnYm9vbGVhbicsXG4gICAgRGF0ZTogJ2RhdGUnLFxuICAgIERhdGVUaW1lOiAnZGF0ZVRpbWUnLFxuICAgIFRpbWU6ICd0aW1lJyxcbiAgICBDdXJyZW5jeTogJ2N1cnJlbmN5JyxcbiAgICBQZXJjZW50OiAncGVyY2VudCcsXG4gICAgSW1hZ2U6ICdpbWFnZSdcbn0pO1xuZXhwb3J0IHR5cGUgRGF0YVR5cGUgPSAodHlwZW9mIERhdGFUeXBlKVtrZXlvZiB0eXBlb2YgRGF0YVR5cGVdO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IEdyaWRDb2x1bW5EYXRhVHlwZSA9IERhdGFUeXBlO1xuZXhwb3J0IHR5cGUgR3JpZENvbHVtbkRhdGFUeXBlID0gKHR5cGVvZiBHcmlkQ29sdW1uRGF0YVR5cGUpW2tleW9mIHR5cGVvZiBHcmlkQ29sdW1uRGF0YVR5cGVdO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFVdGlsIHtcbiAgICBwdWJsaWMgc3RhdGljIHNvcnQ8VD4oZGF0YTogVFtdLCBleHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uW10sIHNvcnRpbmc6IElHcmlkU29ydGluZ1N0cmF0ZWd5ID0gbmV3IElneFNvcnRpbmcoKSxcbiAgICAgICAgZ3JpZD86IEdyaWRUeXBlKTogVFtdIHtcbiAgICAgICAgcmV0dXJuIHNvcnRpbmcuc29ydChkYXRhLCBleHByZXNzaW9ucywgZ3JpZCk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyB0cmVlR3JpZFNvcnQoaGllcmFyY2hpY2FsRGF0YTogSVRyZWVHcmlkUmVjb3JkW10sXG4gICAgICAgIGV4cHJlc3Npb25zOiBJU29ydGluZ0V4cHJlc3Npb25bXSxcbiAgICAgICAgc29ydGluZzogSUdyaWRTb3J0aW5nU3RyYXRlZ3kgPSBuZXcgSWd4RGF0YVJlY29yZFNvcnRpbmcoKSxcbiAgICAgICAgcGFyZW50PzogSVRyZWVHcmlkUmVjb3JkLFxuICAgICAgICBncmlkPzogR3JpZFR5cGUpOiBJVHJlZUdyaWRSZWNvcmRbXSB7XG4gICAgICAgIGxldCByZXM6IElUcmVlR3JpZFJlY29yZFtdID0gW107XG4gICAgICAgIGhpZXJhcmNoaWNhbERhdGEuZm9yRWFjaCgoaHI6IElUcmVlR3JpZFJlY29yZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVjOiBJVHJlZUdyaWRSZWNvcmQgPSBEYXRhVXRpbC5jbG9uZVRyZWVHcmlkUmVjb3JkKGhyKTtcbiAgICAgICAgICAgIHJlYy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAocmVjLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgcmVjLmNoaWxkcmVuID0gRGF0YVV0aWwudHJlZUdyaWRTb3J0KHJlYy5jaGlsZHJlbiwgZXhwcmVzc2lvbnMsIHNvcnRpbmcsIHJlYywgZ3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChyZWMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXMgPSBEYXRhVXRpbC5zb3J0KHJlcywgZXhwcmVzc2lvbnMsIHNvcnRpbmcsIGdyaWQpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjbG9uZVRyZWVHcmlkUmVjb3JkKGhpZXJhcmNoaWNhbFJlY29yZDogSVRyZWVHcmlkUmVjb3JkKSB7XG4gICAgICAgIGNvbnN0IHJlYzogSVRyZWVHcmlkUmVjb3JkID0ge1xuICAgICAgICAgICAga2V5OiBoaWVyYXJjaGljYWxSZWNvcmQua2V5LFxuICAgICAgICAgICAgZGF0YTogaGllcmFyY2hpY2FsUmVjb3JkLmRhdGEsXG4gICAgICAgICAgICBjaGlsZHJlbjogaGllcmFyY2hpY2FsUmVjb3JkLmNoaWxkcmVuLFxuICAgICAgICAgICAgaXNGaWx0ZXJlZE91dFBhcmVudDogaGllcmFyY2hpY2FsUmVjb3JkLmlzRmlsdGVyZWRPdXRQYXJlbnQsXG4gICAgICAgICAgICBsZXZlbDogaGllcmFyY2hpY2FsUmVjb3JkLmxldmVsLFxuICAgICAgICAgICAgZXhwYW5kZWQ6IGhpZXJhcmNoaWNhbFJlY29yZC5leHBhbmRlZFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVjO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXA8VD4oZGF0YTogVFtdLCBzdGF0ZTogSUdyb3VwaW5nU3RhdGUsIGdyb3VwaW5nOiBJR3JpZEdyb3VwaW5nU3RyYXRlZ3kgPSBuZXcgSWd4R3JvdXBpbmcoKSwgZ3JpZDogR3JpZFR5cGUgPSBudWxsLFxuICAgICAgICBncm91cHNSZWNvcmRzOiBhbnlbXSA9IFtdLCBmdWxsUmVzdWx0OiBJR3JvdXBCeVJlc3VsdCA9IHsgZGF0YTogW10sIG1ldGFkYXRhOiBbXSB9KTogSUdyb3VwQnlSZXN1bHQge1xuICAgICAgICBncm91cHNSZWNvcmRzLnNwbGljZSgwLCBncm91cHNSZWNvcmRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBncm91cGluZy5ncm91cEJ5KGRhdGEsIHN0YXRlLCBncmlkLCBncm91cHNSZWNvcmRzLCBmdWxsUmVzdWx0KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHBhZ2U8VD4oZGF0YTogVFtdLCBzdGF0ZTogSVBhZ2luZ1N0YXRlLCBkYXRhTGVuZ3RoPzogbnVtYmVyKTogVFtdIHtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gZGF0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gZGF0YUxlbmd0aCA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBpbmRleCA9IHN0YXRlLmluZGV4O1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVjb3Jkc1BlclBhZ2UgPSBkYXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgc3RhdGUucmVjb3Jkc1BlclBhZ2UgPiBkYXRhTGVuZ3RoID8gZGF0YUxlbmd0aCA6IHN0YXRlLnJlY29yZHNQZXJQYWdlO1xuICAgICAgICBzdGF0ZS5tZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIGNvdW50UGFnZXM6IDAsXG4gICAgICAgICAgICBjb3VudFJlY29yZHM6IGxlbixcbiAgICAgICAgICAgIGVycm9yOiBQYWdpbmdFcnJvci5Ob25lXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgICAgICBzdGF0ZS5tZXRhZGF0YS5lcnJvciA9IFBhZ2luZ0Vycm9yLkluY29ycmVjdFBhZ2VJbmRleDtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY29yZHNQZXJQYWdlIDw9IDAgfHwgaXNOYU4ocmVjb3Jkc1BlclBhZ2UpKSB7XG4gICAgICAgICAgICBzdGF0ZS5tZXRhZGF0YS5lcnJvciA9IFBhZ2luZ0Vycm9yLkluY29ycmVjdFJlY29yZHNQZXJQYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tZXRhZGF0YS5jb3VudFBhZ2VzID0gTWF0aC5jZWlsKGxlbiAvIHJlY29yZHNQZXJQYWdlKTtcbiAgICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSBzdGF0ZS5tZXRhZGF0YS5jb3VudFBhZ2VzKSB7XG4gICAgICAgICAgICBzdGF0ZS5tZXRhZGF0YS5lcnJvciA9IFBhZ2luZ0Vycm9yLkluY29ycmVjdFBhZ2VJbmRleDtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2UoaW5kZXggKiByZWNvcmRzUGVyUGFnZSwgKGluZGV4ICsgMSkgKiByZWNvcmRzUGVyUGFnZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjb3JyZWN0UGFnaW5nU3RhdGUoc3RhdGU6IElQYWdpbmdTdGF0ZSwgbGVuZ3RoOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbWF4UGFnZSA9IE1hdGguY2VpbChsZW5ndGggLyBzdGF0ZS5yZWNvcmRzUGVyUGFnZSkgLSAxO1xuICAgICAgICBpZiAoIWlzTmFOKG1heFBhZ2UpICYmIHN0YXRlLmluZGV4ID4gbWF4UGFnZSkge1xuICAgICAgICAgICAgc3RhdGUuaW5kZXggPSBtYXhQYWdlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRIaWVyYXJjaHkoZ1JvdzogSUdyb3VwQnlSZWNvcmQpOiBBcnJheTxJR3JvdXBCeUtleT4ge1xuICAgICAgICByZXR1cm4gZ2V0SGllcmFyY2h5KGdSb3cpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaXNIaWVyYXJjaHlNYXRjaChoMTogQXJyYXk8SUdyb3VwQnlLZXk+LCBoMjogQXJyYXk8SUdyb3VwQnlLZXk+LCBleHByZXNzaW9uczogSUdyb3VwaW5nRXhwcmVzc2lvbltdKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBpc0hpZXJhcmNoeU1hdGNoKGgxLCBoMiwgZXhwcmVzc2lvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhbGwgY2hhbmdlcyBmcm9tIHByb3ZpZGVkIHRyYW5zYWN0aW9ucyBpbnRvIHByb3ZpZGVkIGRhdGEgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgQ29sbGVjdGlvbiB0byBtZXJnZVxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgVHJhbnNhY3Rpb25zIHRvIG1lcmdlIGludG8gZGF0YVxuICAgICAqIEBwYXJhbSBwcmltYXJ5S2V5IFByaW1hcnkga2V5IG9mIHRoZSBjb2xsZWN0aW9uLCBpZiBhbnlcbiAgICAgKiBAcGFyYW0gZGVsZXRlUm93cyBTaG91bGQgZGVsZXRlIHJvd3Mgd2l0aCBERUxFVEUgdHJhbnNhY3Rpb24gdHlwZSBmcm9tIGRhdGFcbiAgICAgKiBAcmV0dXJucyBQcm92aWRlZCBkYXRhIGNvbGxlY3Rpb25zIHVwZGF0ZWQgd2l0aCBhbGwgcHJvdmlkZWQgdHJhbnNhY3Rpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBtZXJnZVRyYW5zYWN0aW9uczxUPihkYXRhOiBUW10sIHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25bXSwgcHJpbWFyeUtleT86IGFueSwgY2xvbmVTdHJhdGVneTogSURhdGFDbG9uZVN0cmF0ZWd5ID0gbmV3IERlZmF1bHREYXRhQ2xvbmVTdHJhdGVneSgpLCBkZWxldGVSb3dzID0gZmFsc2UpOiBUW10ge1xuICAgICAgICBkYXRhLmZvckVhY2goKGl0ZW06IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93SWQgPSBwcmltYXJ5S2V5ID8gaXRlbVtwcmltYXJ5S2V5XSA6IGl0ZW07XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9ucy5maW5kKHQgPT4gdC5pZCA9PT0gcm93SWQpO1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uICYmIHRyYW5zYWN0aW9uLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5VUERBVEUpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IG1lcmdlT2JqZWN0cyhjbG9uZVN0cmF0ZWd5LmNsb25lKGRhdGFbaW5kZXhdKSwgdHJhbnNhY3Rpb24ubmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGVsZXRlUm93cykge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkRFTEVURSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcmltYXJ5S2V5ID8gZGF0YS5maW5kSW5kZXgoZCA9PiBkW3ByaW1hcnlLZXldID09PSB0LmlkKSA6IGRhdGEuZmluZEluZGV4KGQgPT4gZCA9PT0gdC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwIDw9IGluZGV4ICYmIGluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5wdXNoKC4uLnRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFERClcbiAgICAgICAgICAgIC5tYXAodCA9PiB0Lm5ld1ZhbHVlKSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFsbCBjaGFuZ2VzIGZyb20gcHJvdmlkZWQgdHJhbnNhY3Rpb25zIGludG8gcHJvdmlkZWQgaGllcmFyY2hpY2FsIGRhdGEgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGEgQ29sbGVjdGlvbiB0byBtZXJnZVxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgVHJhbnNhY3Rpb25zIHRvIG1lcmdlIGludG8gZGF0YVxuICAgICAqIEBwYXJhbSBjaGlsZERhdGFLZXkgRGF0YSBrZXkgb2YgY2hpbGQgY29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0gcHJpbWFyeUtleSBQcmltYXJ5IGtleSBvZiB0aGUgY29sbGVjdGlvbiwgaWYgYW55XG4gICAgICogQHBhcmFtIGRlbGV0ZVJvd3MgU2hvdWxkIGRlbGV0ZSByb3dzIHdpdGggREVMRVRFIHRyYW5zYWN0aW9uIHR5cGUgZnJvbSBkYXRhXG4gICAgICogQHJldHVybnMgUHJvdmlkZWQgZGF0YSBjb2xsZWN0aW9ucyB1cGRhdGVkIHdpdGggYWxsIHByb3ZpZGVkIHRyYW5zYWN0aW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgbWVyZ2VIaWVyYXJjaGljYWxUcmFuc2FjdGlvbnMoXG4gICAgICAgIGRhdGE6IGFueVtdLFxuICAgICAgICB0cmFuc2FjdGlvbnM6IEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uW10sXG4gICAgICAgIGNoaWxkRGF0YUtleTogYW55LFxuICAgICAgICBwcmltYXJ5S2V5PzogYW55LFxuICAgICAgICBjbG9uZVN0cmF0ZWd5OiBJRGF0YUNsb25lU3RyYXRlZ3kgPSBuZXcgRGVmYXVsdERhdGFDbG9uZVN0cmF0ZWd5KCksXG4gICAgICAgIGRlbGV0ZVJvd3MgPSBmYWxzZSk6IGFueVtdIHtcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2FjdGlvbiBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5wYXRoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5maW5kUGFyZW50RnJvbVBhdGgoZGF0YSwgcHJpbWFyeUtleSwgY2hpbGREYXRhS2V5LCB0cmFuc2FjdGlvbi5wYXRoKTtcbiAgICAgICAgICAgICAgICBsZXQgY29sbGVjdGlvbjogYW55W10gPSBwYXJlbnQgPyBwYXJlbnRbY2hpbGREYXRhS2V5XSA6IGRhdGE7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cmFuc2FjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFERDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBpZiB0aGVyZSBpcyBubyBwYXJlbnQgdGhpcyBpcyBBREQgcm93IGF0IHJvb3QgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudFtjaGlsZERhdGFLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50W2NoaWxkRGF0YUtleV0gPSBjb2xsZWN0aW9uID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnB1c2godHJhbnNhY3Rpb24ubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlVQREFURTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUluZGV4ID0gY29sbGVjdGlvbi5maW5kSW5kZXgoeCA9PiB4W3ByaW1hcnlLZXldID09PSB0cmFuc2FjdGlvbi5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvblt1cGRhdGVJbmRleF0gPSBtZXJnZU9iamVjdHMoY2xvbmVTdHJhdGVneS5jbG9uZShjb2xsZWN0aW9uW3VwZGF0ZUluZGV4XSksIHRyYW5zYWN0aW9uLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5ERUxFVEU6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRlUm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUluZGV4ID0gY29sbGVjdGlvbi5maW5kSW5kZXgociA9PiByW3ByaW1hcnlLZXldID09PSB0cmFuc2FjdGlvbi5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnNwbGljZShkZWxldGVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAgaWYgdGhlcmUgaXMgbm8gcGF0aCB0aGlzIGlzIEFERCByb3cgaW4gcm9vdC4gUHVzaCB0aGUgbmV3VmFsdWUgdG8gZGF0YVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaCh0cmFuc2FjdGlvbi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBwYXJzZVZhbHVlKGRhdGFUeXBlOiBHcmlkQ29sdW1uRGF0YVR5cGUsIHZhbHVlOiBhbnkpOiBhbnkge1xuICAgICAgICBpZiAoZGF0YVR5cGUgPT09IEdyaWRDb2x1bW5EYXRhVHlwZS5OdW1iZXIgfHwgZGF0YVR5cGUgPT09IEdyaWRDb2x1bW5EYXRhVHlwZS5DdXJyZW5jeSB8fCBkYXRhVHlwZSA9PT0gR3JpZENvbHVtbkRhdGFUeXBlLlBlcmNlbnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmluZFBhcmVudEZyb21QYXRoKGRhdGE6IGFueVtdLCBwcmltYXJ5S2V5OiBhbnksIGNoaWxkRGF0YUtleTogYW55LCBwYXRoOiBhbnlbXSk6IGFueSB7XG4gICAgICAgIGxldCBjb2xsZWN0aW9uOiBhbnlbXSA9IGRhdGE7XG4gICAgICAgIGxldCByZXN1bHQ6IGFueTtcblxuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIHBhdGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5maW5kKHggPT4geFtwcmltYXJ5S2V5XSA9PT0gaWQpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sbGVjdGlvbiA9IHJlc3VsdFtjaGlsZERhdGFLZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iXX0=