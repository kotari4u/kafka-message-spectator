import { isHorizontalAnimation, isVerticalAnimation, reverseAnimationResolver } from '../../../core/utils';
import { HorizontalAlignment, VerticalAlignment } from './../utilities';
import { BaseFitPositionStrategy } from './base-fit-position-strategy';
/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
export class AutoPositionStrategy extends BaseFitPositionStrategy {
    /**
     * Fits the element into viewport according to the position settings
     *
     * @param element element to fit in viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     */
    fitInViewport(element, connectedFit) {
        const transformString = [];
        if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
            if (this.canFlipHorizontal(connectedFit)) {
                this.flipHorizontal();
                this.flipAnimation(FlipDirection.Horizontal);
            }
            else {
                const horizontalPush = this.horizontalPush(connectedFit);
                transformString.push(`translateX(${horizontalPush}px)`);
            }
        }
        if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
            if (this.canFlipVertical(connectedFit)) {
                this.flipVertical();
                this.flipAnimation(FlipDirection.Vertical);
            }
            else {
                const verticalPush = this.verticalPush(connectedFit);
                transformString.push(`translateY(${verticalPush}px)`);
            }
        }
        element.style.transform = transformString.join(' ').trim();
    }
    /**
     * Checks if element can be flipped without get off the viewport
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    canFlipHorizontal(connectedFit) {
        //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
        //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
        //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
        //  this way:
        //  (-1) * (Left + 1) = 0 = Right
        //  (-1) * (Center + 1) = -0.5 = Center
        //  (-1) * (Right + 1) = -1 = Left
        const flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
        const flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
        const leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        const rightBorder = leftBorder + connectedFit.contentElementRect.width;
        return 0 < leftBorder && rightBorder < connectedFit.viewPortRect.width;
    }
    /**
     * Checks if element can be flipped without get off the viewport
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    canFlipVertical(connectedFit) {
        const flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
        const flippedDirection = (-1) * (this.settings.verticalDirection + 1);
        const topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        const bottomBorder = topBorder + connectedFit.contentElementRect.height;
        return 0 < topBorder && bottomBorder < connectedFit.viewPortRect.height;
    }
    /**
     * Flips direction and start point of the position settings
     */
    flipHorizontal() {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                this.settings.horizontalDirection = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalDirection = HorizontalAlignment.Left;
                break;
        }
        switch (this.settings.horizontalStartPoint) {
            case HorizontalAlignment.Left:
                this.settings.horizontalStartPoint = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalStartPoint = HorizontalAlignment.Left;
                break;
        }
    }
    /**
     * Flips direction and start point of the position settings
     */
    flipVertical() {
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                this.settings.verticalDirection = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalDirection = VerticalAlignment.Top;
                break;
        }
        switch (this.settings.verticalStartPoint) {
            case VerticalAlignment.Top:
                this.settings.verticalStartPoint = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalStartPoint = VerticalAlignment.Top;
                break;
        }
    }
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    horizontalPush(connectedFit) {
        const leftExtend = connectedFit.left;
        const rightExtend = connectedFit.right - connectedFit.viewPortRect.width;
        //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
        //  as much as it is beyond the screen.
        //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
        //  extend but with amount not bigger than what left between left border of screen and left border of
        //  overlay, e.g. leftExtend
        if (leftExtend < 0) {
            return Math.abs(leftExtend);
        }
        else if (rightExtend > 0) {
            return -Math.min(rightExtend, leftExtend);
        }
        else {
            return 0;
        }
    }
    /**
     * Calculates necessary vertical push according to provided connectedFit
     *
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    verticalPush(connectedFit) {
        const topExtend = connectedFit.top;
        const bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.height;
        if (topExtend < 0) {
            return Math.abs(topExtend);
        }
        else if (bottomExtend > 0) {
            return -Math.min(bottomExtend, topExtend);
        }
        else {
            return 0;
        }
    }
    /**
     * Changes open and close animation with reverse animation if one exists
     *
     * @param flipDirection direction for which to change the animations
     */
    flipAnimation(flipDirection) {
        if (this.settings.openAnimation) {
            this.settings.openAnimation = this.updateAnimation(this.settings.openAnimation, flipDirection);
        }
        if (this.settings.closeAnimation) {
            this.settings.closeAnimation = this.updateAnimation(this.settings.closeAnimation, flipDirection);
        }
    }
    /**
     * Tries to find the reverse animation according to provided direction
     *
     * @param animation animation to update
     * @param direction required animation direction
     * @returns reverse animation in given direction if one exists
     */
    updateAnimation(animation, direction) {
        switch (direction) {
            case FlipDirection.Horizontal:
                if (isHorizontalAnimation(animation)) {
                    return reverseAnimationResolver(animation);
                }
                break;
            case FlipDirection.Vertical:
                if (isVerticalAnimation(animation)) {
                    return reverseAnimationResolver(animation);
                }
                break;
        }
        return animation;
    }
}
var FlipDirection;
(function (FlipDirection) {
    FlipDirection[FlipDirection["Horizontal"] = 0] = "Horizontal";
    FlipDirection[FlipDirection["Vertical"] = 1] = "Vertical";
})(FlipDirection || (FlipDirection = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1wb3NpdGlvbi1zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zZXJ2aWNlcy9vdmVybGF5L3Bvc2l0aW9uL2F1dG8tcG9zaXRpb24tc3RyYXRlZ3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLHFCQUFxQixFQUFFLG1CQUFtQixFQUFFLHdCQUF3QixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDM0csT0FBTyxFQUFnQixtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3RGLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBRXZFOzs7R0FHRztBQUNILE1BQU0sT0FBTyxvQkFBcUIsU0FBUSx1QkFBdUI7SUFFN0Q7Ozs7O09BS0c7SUFDTyxhQUFhLENBQUMsT0FBb0IsRUFBRSxZQUEwQjtRQUNwRSxNQUFNLGVBQWUsR0FBYSxFQUFFLENBQUM7UUFDckMsSUFBSSxZQUFZLENBQUMsYUFBYSxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksWUFBWSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxFQUFFO1lBQy9FLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUN0QyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBQ3RCLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQ2hEO2lCQUFNO2dCQUNILE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQ3pELGVBQWUsQ0FBQyxJQUFJLENBQUMsY0FBYyxjQUFjLEtBQUssQ0FBQyxDQUFDO2FBQzNEO1NBQ0o7UUFFRCxJQUFJLFlBQVksQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHLENB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QUMsY0FBYyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLEVBQUUsYUFBYSxDQUFDLENBQUM7U0FDcEc7SUFDTCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ssZUFBZSxDQUFDLFNBQXFDLEVBQUUsU0FBd0I7UUFDbkYsUUFBUSxTQUFTLEVBQUU7WUFDZixLQUFLLGFBQWEsQ0FBQyxVQUFVO2dCQUN6QixJQUFJLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxFQUFFO29CQUNsQyxPQUFPLHdCQUF3QixDQUFDLFNBQVMsQ0FBQyxDQUFDO2lCQUM5QztnQkFDRCxNQUFNO1lBQ1YsS0FBSyxhQUFhLENBQUMsUUFBUTtnQkFDdkIsSUFBSSxtQkFBbUIsQ0FBQyxTQUFTLENBQUMsRUFBRTtvQkFDaEMsT0FBTyx3QkFBd0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztpQkFDOUM7Z0JBQ0QsTUFBTTtTQUNiO1FBRUQsT0FBTyxTQUFTLENBQUM7SUFDckIsQ0FBQztDQUNKO0FBRUQsSUFBSyxhQUdKO0FBSEQsV0FBSyxhQUFhO0lBQ2QsNkRBQVUsQ0FBQTtJQUNWLHlEQUFRLENBQUE7QUFDWixDQUFDLEVBSEksYUFBYSxLQUFiLGFBQWEsUUFHakIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbmltYXRpb25SZWZlcmVuY2VNZXRhZGF0YSB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgaXNIb3Jpem9udGFsQW5pbWF0aW9uLCBpc1ZlcnRpY2FsQW5pbWF0aW9uLCByZXZlcnNlQW5pbWF0aW9uUmVzb2x2ZXIgfSBmcm9tICcuLi8uLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IENvbm5lY3RlZEZpdCwgSG9yaXpvbnRhbEFsaWdubWVudCwgVmVydGljYWxBbGlnbm1lbnQgfSBmcm9tICcuLy4uL3V0aWxpdGllcyc7XG5pbXBvcnQgeyBCYXNlRml0UG9zaXRpb25TdHJhdGVneSB9IGZyb20gJy4vYmFzZS1maXQtcG9zaXRpb24tc3RyYXRlZ3knO1xuXG4vKipcbiAqIFBvc2l0aW9ucyB0aGUgZWxlbWVudCBhcyBpbiAqKkNvbm5lY3RlZCoqIHBvc2l0aW9uaW5nIHN0cmF0ZWd5IGFuZCByZS1wb3NpdGlvbnMgdGhlIGVsZW1lbnQgaW5cbiAqIHRoZSB2aWV3IHBvcnQgKGNhbGN1bGF0aW5nIGEgZGlmZmVyZW50IHN0YXJ0IHBvaW50KSBpbiBjYXNlIHRoZSBlbGVtZW50IGlzIHBhcnRpYWxseSBnZXR0aW5nIG91dCBvZiB2aWV3XG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRvUG9zaXRpb25TdHJhdGVneSBleHRlbmRzIEJhc2VGaXRQb3NpdGlvblN0cmF0ZWd5IHtcblxuICAgIC8qKlxuICAgICAqIEZpdHMgdGhlIGVsZW1lbnQgaW50byB2aWV3cG9ydCBhY2NvcmRpbmcgdG8gdGhlIHBvc2l0aW9uIHNldHRpbmdzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBlbGVtZW50IHRvIGZpdCBpbiB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBmaXRJblZpZXdwb3J0KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb25uZWN0ZWRGaXQ6IENvbm5lY3RlZEZpdCkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1TdHJpbmc6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGlmIChjb25uZWN0ZWRGaXQuZml0SG9yaXpvbnRhbC5iYWNrIDwgMCB8fCBjb25uZWN0ZWRGaXQuZml0SG9yaXpvbnRhbC5mb3J3YXJkIDwgMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuRmxpcEhvcml6b250YWwoY29ubmVjdGVkRml0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmxpcEhvcml6b250YWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsaXBBbmltYXRpb24oRmxpcERpcmVjdGlvbi5Ib3Jpem9udGFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9yaXpvbnRhbFB1c2ggPSB0aGlzLmhvcml6b250YWxQdXNoKGNvbm5lY3RlZEZpdCk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtU3RyaW5nLnB1c2goYHRyYW5zbGF0ZVgoJHtob3Jpem9udGFsUHVzaH1weClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25uZWN0ZWRGaXQuZml0VmVydGljYWwuYmFjayA8IDAgfHwgY29ubmVjdGVkRml0LmZpdFZlcnRpY2FsLmZvcndhcmQgPCAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5GbGlwVmVydGljYWwoY29ubmVjdGVkRml0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmxpcFZlcnRpY2FsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGlwQW5pbWF0aW9uKEZsaXBEaXJlY3Rpb24uVmVydGljYWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0aWNhbFB1c2ggPSB0aGlzLnZlcnRpY2FsUHVzaChjb25uZWN0ZWRGaXQpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVN0cmluZy5wdXNoKGB0cmFuc2xhdGVZKCR7dmVydGljYWxQdXNofXB4KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1TdHJpbmcuam9pbignICcpLnRyaW0oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgZWxlbWVudCBjYW4gYmUgZmxpcHBlZCB3aXRob3V0IGdldCBvZmYgdGhlIHZpZXdwb3J0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29ubmVjdGVkRml0IGNvbm5lY3RlZEZpdCBvYmplY3QgY29udGFpbmluZyBhbGwgbmVjZXNzYXJ5IHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGVsZW1lbnQgY2FuIGJlIGZsaXBwZWQgYW5kIHN0YWluIGluIHZpZXdwb3J0XG4gICAgICovXG4gICAgcHJpdmF0ZSBjYW5GbGlwSG9yaXpvbnRhbChjb25uZWN0ZWRGaXQ6IENvbm5lY3RlZEZpdCk6IGJvb2xlYW4ge1xuICAgICAgICAvLyAgSG9yaXpvbnRhbEFsaWdubWVudCBjYW4gYmUgTGVmdCA9IC0xOyBDZW50ZXIgPSAtMC41IG9yIFJpZ2h0ID0gMC5cbiAgICAgICAgLy8gIFRvIHZpcnR1YWxseSBmbGlwIGRpcmVjdGlvbiBhbmQgc3RhcnQgcG9pbnQgKGJvdGggYXJlIEhvcml6b250YWxBbGlnbm1lbnQpIHdlIGNhbiBkbyB0aGlzOlxuICAgICAgICAvLyAgZmxpcHBlZEFsaWdubWVudCA9ICgtMSkgKiAoSG9yaXpvbnRhbEFsaWdubWVudCArIDEpXG4gICAgICAgIC8vICB0aGlzIHdheTpcbiAgICAgICAgLy8gICgtMSkgKiAoTGVmdCArIDEpID0gMCA9IFJpZ2h0XG4gICAgICAgIC8vICAoLTEpICogKENlbnRlciArIDEpID0gLTAuNSA9IENlbnRlclxuICAgICAgICAvLyAgKC0xKSAqIChSaWdodCArIDEpID0gLTEgPSBMZWZ0XG4gICAgICAgIGNvbnN0IGZsaXBwZWRTdGFydFBvaW50ID0gKC0xKSAqICh0aGlzLnNldHRpbmdzLmhvcml6b250YWxTdGFydFBvaW50ICsgMSk7XG4gICAgICAgIGNvbnN0IGZsaXBwZWREaXJlY3Rpb24gPSAoLTEpICogKHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbERpcmVjdGlvbiArIDEpO1xuXG4gICAgICAgIGNvbnN0IGxlZnRCb3JkZXIgPSB0aGlzLmNhbGN1bGF0ZUxlZnQoXG4gICAgICAgICAgICBjb25uZWN0ZWRGaXQudGFyZ2V0UmVjdCwgY29ubmVjdGVkRml0LmNvbnRlbnRFbGVtZW50UmVjdCwgZmxpcHBlZFN0YXJ0UG9pbnQsIGZsaXBwZWREaXJlY3Rpb24sIDApO1xuICAgICAgICBjb25zdCByaWdodEJvcmRlciA9IGxlZnRCb3JkZXIgKyBjb25uZWN0ZWRGaXQuY29udGVudEVsZW1lbnRSZWN0LndpZHRoO1xuICAgICAgICByZXR1cm4gMCA8IGxlZnRCb3JkZXIgJiYgcmlnaHRCb3JkZXIgPCBjb25uZWN0ZWRGaXQudmlld1BvcnRSZWN0LndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBlbGVtZW50IGNhbiBiZSBmbGlwcGVkIHdpdGhvdXQgZ2V0IG9mZiB0aGUgdmlld3BvcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZWxlbWVudCBjYW4gYmUgZmxpcHBlZCBhbmQgc3RhaW4gaW4gdmlld3BvcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbkZsaXBWZXJ0aWNhbChjb25uZWN0ZWRGaXQ6IENvbm5lY3RlZEZpdCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBmbGlwcGVkU3RhcnRQb2ludCA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQgKyAxKTtcbiAgICAgICAgY29uc3QgZmxpcHBlZERpcmVjdGlvbiA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbiArIDEpO1xuXG4gICAgICAgIGNvbnN0IHRvcEJvcmRlciA9IHRoaXMuY2FsY3VsYXRlVG9wKFxuICAgICAgICAgICAgY29ubmVjdGVkRml0LnRhcmdldFJlY3QsIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3QsIGZsaXBwZWRTdGFydFBvaW50LCBmbGlwcGVkRGlyZWN0aW9uLCAwKTtcbiAgICAgICAgY29uc3QgYm90dG9tQm9yZGVyID0gdG9wQm9yZGVyICsgY29ubmVjdGVkRml0LmNvbnRlbnRFbGVtZW50UmVjdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiAwIDwgdG9wQm9yZGVyICYmIGJvdHRvbUJvcmRlciA8IGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3QuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsaXBzIGRpcmVjdGlvbiBhbmQgc3RhcnQgcG9pbnQgb2YgdGhlIHBvc2l0aW9uIHNldHRpbmdzXG4gICAgICovXG4gICAgcHJpdmF0ZSBmbGlwSG9yaXpvbnRhbCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLmhvcml6b250YWxEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgSG9yaXpvbnRhbEFsaWdubWVudC5MZWZ0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbERpcmVjdGlvbiA9IEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uID0gSG9yaXpvbnRhbEFsaWdubWVudC5MZWZ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsU3RhcnRQb2ludCkge1xuICAgICAgICAgICAgY2FzZSBIb3Jpem9udGFsQWxpZ25tZW50LkxlZnQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsU3RhcnRQb2ludCA9IEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsU3RhcnRQb2ludCA9IEhvcml6b250YWxBbGlnbm1lbnQuTGVmdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsaXBzIGRpcmVjdGlvbiBhbmQgc3RhcnQgcG9pbnQgb2YgdGhlIHBvc2l0aW9uIHNldHRpbmdzXG4gICAgICovXG4gICAgcHJpdmF0ZSBmbGlwVmVydGljYWwoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbiA9IFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuQm90dG9tOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmVydGljYWxEaXJlY3Rpb24gPSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLnZlcnRpY2FsU3RhcnRQb2ludCkge1xuICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQgPSBWZXJ0aWNhbEFsaWdubWVudC5Cb3R0b207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbTpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnZlcnRpY2FsU3RhcnRQb2ludCA9IFZlcnRpY2FsQWxpZ25tZW50LlRvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgbmVjZXNzYXJ5IGhvcml6b250YWwgcHVzaCBhY2NvcmRpbmcgdG8gcHJvdmlkZWQgY29ubmVjdGVkRml0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29ubmVjdGVkRml0IGNvbm5lY3RlZEZpdCBvYmplY3QgY29udGFpbmluZyBhbGwgbmVjZXNzYXJ5IHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyBhbW91bnQgb2YgbmVjZXNzYXJ5IHRyYW5zbGF0aW9uIHdoaWNoIHdpbGwgcHVzaCB0aGUgZWxlbWVudCBpbnRvIHZpZXdwb3J0XG4gICAgICovXG4gICAgcHJpdmF0ZSBob3Jpem9udGFsUHVzaChjb25uZWN0ZWRGaXQ6IENvbm5lY3RlZEZpdCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGxlZnRFeHRlbmQgPSBjb25uZWN0ZWRGaXQubGVmdDtcbiAgICAgICAgY29uc3QgcmlnaHRFeHRlbmQgPSBjb25uZWN0ZWRGaXQucmlnaHQgLSBjb25uZWN0ZWRGaXQudmlld1BvcnRSZWN0LndpZHRoO1xuICAgICAgICAvLyAgaWYgbGVmdEV4dGVuZCA8IDAgb3ZlcmxheSBnb2VzIGJleW9uZCBsZWZ0IGVuZCBvZiB0aGUgc2NyZWVuLiBXZSBzaG91bGQgcHVzaCBpdCBiYWNrIHdpdGggZXhhY3RseVxuICAgICAgICAvLyAgYXMgbXVjaCBhcyBpdCBpcyBiZXlvbmQgdGhlIHNjcmVlbi5cbiAgICAgICAgLy8gIGlmIHJpZ2h0RXh0ZW5kID4gMCBvdmVybGF5IGdvZXMgYmV5b25kIHJpZ2h0IGVuZCBvZiB0aGUgc2NyZWVuLiBXZSBzaG91bGQgcHVzaCBpdCBiYWNrIHdpdGggdGhlXG4gICAgICAgIC8vICBleHRlbmQgYnV0IHdpdGggYW1vdW50IG5vdCBiaWdnZXIgdGhhbiB3aGF0IGxlZnQgYmV0d2VlbiBsZWZ0IGJvcmRlciBvZiBzY3JlZW4gYW5kIGxlZnQgYm9yZGVyIG9mXG4gICAgICAgIC8vICBvdmVybGF5LCBlLmcuIGxlZnRFeHRlbmRcbiAgICAgICAgaWYgKGxlZnRFeHRlbmQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMobGVmdEV4dGVuZCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmlnaHRFeHRlbmQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLSBNYXRoLm1pbihyaWdodEV4dGVuZCwgbGVmdEV4dGVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgbmVjZXNzYXJ5IHZlcnRpY2FsIHB1c2ggYWNjb3JkaW5nIHRvIHByb3ZpZGVkIGNvbm5lY3RlZEZpdFxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbm5lY3RlZEZpdCBjb25uZWN0ZWRGaXQgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgYW1vdW50IG9mIG5lY2Vzc2FyeSB0cmFuc2xhdGlvbiB3aGljaCB3aWxsIHB1c2ggdGhlIGVsZW1lbnQgaW50byB2aWV3cG9ydFxuICAgICAqL1xuICAgIHByaXZhdGUgdmVydGljYWxQdXNoKGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgdG9wRXh0ZW5kID0gY29ubmVjdGVkRml0LnRvcDtcbiAgICAgICAgY29uc3QgYm90dG9tRXh0ZW5kID0gY29ubmVjdGVkRml0LmJvdHRvbSAtIGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3QuaGVpZ2h0O1xuICAgICAgICBpZiAodG9wRXh0ZW5kIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRvcEV4dGVuZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYm90dG9tRXh0ZW5kID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0gTWF0aC5taW4oYm90dG9tRXh0ZW5kLCB0b3BFeHRlbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIG9wZW4gYW5kIGNsb3NlIGFuaW1hdGlvbiB3aXRoIHJldmVyc2UgYW5pbWF0aW9uIGlmIG9uZSBleGlzdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbGlwRGlyZWN0aW9uIGRpcmVjdGlvbiBmb3Igd2hpY2ggdG8gY2hhbmdlIHRoZSBhbmltYXRpb25zXG4gICAgICovXG4gICAgcHJpdmF0ZSBmbGlwQW5pbWF0aW9uKGZsaXBEaXJlY3Rpb246IEZsaXBEaXJlY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mub3BlbkFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5vcGVuQW5pbWF0aW9uID0gdGhpcy51cGRhdGVBbmltYXRpb24odGhpcy5zZXR0aW5ncy5vcGVuQW5pbWF0aW9uLCBmbGlwRGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jbG9zZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5jbG9zZUFuaW1hdGlvbiA9IHRoaXMudXBkYXRlQW5pbWF0aW9uKHRoaXMuc2V0dGluZ3MuY2xvc2VBbmltYXRpb24sIGZsaXBEaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZXMgdG8gZmluZCB0aGUgcmV2ZXJzZSBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHByb3ZpZGVkIGRpcmVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiBhbmltYXRpb24gdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIGRpcmVjdGlvbiByZXF1aXJlZCBhbmltYXRpb24gZGlyZWN0aW9uXG4gICAgICogQHJldHVybnMgcmV2ZXJzZSBhbmltYXRpb24gaW4gZ2l2ZW4gZGlyZWN0aW9uIGlmIG9uZSBleGlzdHNcbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZUFuaW1hdGlvbihhbmltYXRpb246IEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhLCBkaXJlY3Rpb246IEZsaXBEaXJlY3Rpb24pOiBBbmltYXRpb25SZWZlcmVuY2VNZXRhZGF0YSB7XG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIEZsaXBEaXJlY3Rpb24uSG9yaXpvbnRhbDpcbiAgICAgICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsQW5pbWF0aW9uKGFuaW1hdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldmVyc2VBbmltYXRpb25SZXNvbHZlcihhbmltYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRmxpcERpcmVjdGlvbi5WZXJ0aWNhbDpcbiAgICAgICAgICAgICAgICBpZiAoaXNWZXJ0aWNhbEFuaW1hdGlvbihhbmltYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXZlcnNlQW5pbWF0aW9uUmVzb2x2ZXIoYW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uO1xuICAgIH1cbn1cblxuZW51bSBGbGlwRGlyZWN0aW9uIHtcbiAgICBIb3Jpem9udGFsLFxuICAgIFZlcnRpY2FsXG59XG4iXX0=