import { Directive, Input } from '@angular/core';
import { fromEvent, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../../core/utils";
export class IgxFocusTrapDirective {
    /** @hidden */
    get element() {
        return this.elementRef.nativeElement;
    }
    /** @hidden */
    constructor(elementRef, platformUtil) {
        this.elementRef = elementRef;
        this.platformUtil = platformUtil;
        this.destroy$ = new Subject();
        this._focusTrap = true;
    }
    /**
     * Sets whether the Tab key focus is trapped within the element.
     *
     * @example
     * ```html
     * <div igxFocusTrap="true"></div>
     * ```
     */
    set focusTrap(focusTrap) {
        this._focusTrap = focusTrap;
    }
    /** @hidden */
    get focusTrap() {
        return this._focusTrap;
    }
    /** @hidden */
    ngAfterViewInit() {
        fromEvent(this.element, 'keydown')
            .pipe(takeUntil(this.destroy$))
            .subscribe((event) => {
            if (this._focusTrap && event.key === this.platformUtil.KEYMAP.TAB) {
                this.handleTab(event);
            }
        });
    }
    /** @hidden */
    ngOnDestroy() {
        this.destroy$.complete();
    }
    handleTab(event) {
        const elements = this.getFocusableElements(this.element);
        if (elements.length > 0) {
            const focusedElement = this.getFocusedElement();
            const focusedElementIndex = elements.findIndex((element) => element === focusedElement);
            const direction = event.shiftKey ? -1 : 1;
            let nextFocusableElementIndex = focusedElementIndex + direction;
            if (nextFocusableElementIndex < 0) {
                nextFocusableElementIndex = elements.length - 1;
            }
            if (nextFocusableElementIndex >= elements.length) {
                nextFocusableElementIndex = 0;
            }
            elements[nextFocusableElementIndex].focus();
        }
        else {
            this.element.focus();
        }
        event.preventDefault();
    }
    getFocusableElements(element) {
        return Array.from(element.querySelectorAll('a[href], button, input, textarea, select, details,[tabindex]:not([tabindex="-1"])')).filter(el => !el.hasAttribute('disabled') && !el.getAttribute('aria-hidden'));
    }
    getFocusedElement() {
        let activeElement = typeof document !== 'undefined' && document
            ? document.activeElement
            : null;
        while (activeElement && activeElement.shadowRoot) {
            const newActiveElement = activeElement.shadowRoot.activeElement;
            if (newActiveElement === activeElement) {
                break;
            }
            else {
                activeElement = newActiveElement;
            }
        }
        return activeElement;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxFocusTrapDirective, deps: [{ token: i0.ElementRef }, { token: i1.PlatformUtil }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: IgxFocusTrapDirective, isStandalone: true, selector: "[igxFocusTrap]", inputs: { focusTrap: ["igxFocusTrap", "focusTrap"] }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxFocusTrapDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxFocusTrap]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.PlatformUtil }]; }, propDecorators: { focusTrap: [{
                type: Input,
                args: ['igxFocusTrap']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9jdXMtdHJhcC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvZGlyZWN0aXZlcy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBaUIsU0FBUyxFQUFjLEtBQUssRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUN2RixPQUFPLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMxQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQU8zQyxNQUFNLE9BQU8scUJBQXFCO0lBQzlCLGNBQWM7SUFDZCxJQUFXLE9BQU87UUFDZCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO0lBQ3pDLENBQUM7SUFLRCxjQUFjO0lBQ2QsWUFDWSxVQUFzQixFQUNwQixZQUEwQjtRQUQ1QixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3BCLGlCQUFZLEdBQVosWUFBWSxDQUFjO1FBTmhDLGFBQVEsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQ3pCLGVBQVUsR0FBRyxJQUFJLENBQUM7SUFNMUIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxJQUNXLFNBQVMsQ0FBQyxTQUFrQjtRQUNuQyxJQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztJQUNoQyxDQUFDO0lBRUQsY0FBYztJQUNkLElBQVcsU0FBUztRQUNoQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDM0IsQ0FBQztJQUVELGNBQWM7SUFDUCxlQUFlO1FBQ2QsU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDO2FBQzdCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQzlCLFNBQVMsQ0FBQyxDQUFDLEtBQW9CLEVBQUUsRUFBRTtZQUNoQyxJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksS0FBSyxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUU7Z0JBQy9ELElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDekI7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNmLENBQUM7SUFFRCxjQUFjO0lBQ1AsV0FBVztRQUNkLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDN0IsQ0FBQztJQUVPLFNBQVMsQ0FBQyxLQUFLO1FBQ25CLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekQsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNyQixNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztZQUNoRCxNQUFNLG1CQUFtQixHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQXNCLEtBQUssY0FBYyxDQUFDLENBQUM7WUFDdkcsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMxQyxJQUFJLHlCQUF5QixHQUFHLG1CQUFtQixHQUFHLFNBQVMsQ0FBQztZQUNoRSxJQUFJLHlCQUF5QixHQUFHLENBQUMsRUFBRTtnQkFDL0IseUJBQXlCLEdBQUcsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7YUFDbkQ7WUFDRCxJQUFJLHlCQUF5QixJQUFJLFFBQVEsQ0FBQyxNQUFNLEVBQUU7Z0JBQzlDLHlCQUF5QixHQUFHLENBQUMsQ0FBQzthQUNqQztZQUNBLFFBQVEsQ0FBQyx5QkFBeUIsQ0FBaUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUNoRTthQUFNO1lBQ0gsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUN4QjtRQUVELEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUMzQixDQUFDO0lBRU8sb0JBQW9CLENBQUMsT0FBZ0I7UUFDekMsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FDdEMsbUZBQW1GLENBQ3RGLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFDckYsQ0FBQztJQUVPLGlCQUFpQjtRQUNyQixJQUFJLGFBQWEsR0FDYixPQUFPLFFBQVEsS0FBSyxXQUFXLElBQUksUUFBUTtZQUN2QyxDQUFDLENBQUUsUUFBUSxDQUFDLGFBQW9DO1lBQ2hELENBQUMsQ0FBQyxJQUFJLENBQUM7UUFFZixPQUFPLGFBQWEsSUFBSSxhQUFhLENBQUMsVUFBVSxFQUFFO1lBQzlDLE1BQU0sZ0JBQWdCLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxhQUFtQyxDQUFDO1lBQ3RGLElBQUksZ0JBQWdCLEtBQUssYUFBYSxFQUFFO2dCQUNwQyxNQUFNO2FBQ1Q7aUJBQU07Z0JBQ0gsYUFBYSxHQUFHLGdCQUFnQixDQUFDO2FBQ3BDO1NBQ0o7UUFFRCxPQUFPLGFBQWEsQ0FBQztJQUN6QixDQUFDOzhHQTVGUSxxQkFBcUI7a0dBQXJCLHFCQUFxQjs7MkZBQXJCLHFCQUFxQjtrQkFKakMsU0FBUzttQkFBQztvQkFDUCxRQUFRLEVBQUUsZ0JBQWdCO29CQUMxQixVQUFVLEVBQUUsSUFBSTtpQkFDbkI7NEhBeUJjLFNBQVM7c0JBRG5CLEtBQUs7dUJBQUMsY0FBYyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFmdGVyVmlld0luaXQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBQbGF0Zm9ybVV0aWwgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4Rm9jdXNUcmFwXScsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hGb2N1c1RyYXBEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGdldCBlbGVtZW50KCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICBwcml2YXRlIF9mb2N1c1RyYXAgPSB0cnVlO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcm90ZWN0ZWQgcGxhdGZvcm1VdGlsOiBQbGF0Zm9ybVV0aWwpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdGhlIFRhYiBrZXkgZm9jdXMgaXMgdHJhcHBlZCB3aXRoaW4gdGhlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneEZvY3VzVHJhcD1cInRydWVcIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneEZvY3VzVHJhcCcpXG4gICAgcHVibGljIHNldCBmb2N1c1RyYXAoZm9jdXNUcmFwOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IGZvY3VzVHJhcDtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBnZXQgZm9jdXNUcmFwKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9jdXNUcmFwO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQsICdrZXlkb3duJylcbiAgICAgICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZvY3VzVHJhcCAmJiBldmVudC5rZXkgPT09IHRoaXMucGxhdGZvcm1VdGlsLktFWU1BUC5UQUIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVGFiKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVUYWIoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmdldEZvY3VzYWJsZUVsZW1lbnRzKHRoaXMuZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkRWxlbWVudCA9IHRoaXMuZ2V0Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50SW5kZXggPSBlbGVtZW50cy5maW5kSW5kZXgoKGVsZW1lbnQpID0+IGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQgPT09IGZvY3VzZWRFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGV2ZW50LnNoaWZ0S2V5ID8gLTEgOiAxO1xuICAgICAgICAgICAgbGV0IG5leHRGb2N1c2FibGVFbGVtZW50SW5kZXggPSBmb2N1c2VkRWxlbWVudEluZGV4ICsgZGlyZWN0aW9uO1xuICAgICAgICAgICAgaWYgKG5leHRGb2N1c2FibGVFbGVtZW50SW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgbmV4dEZvY3VzYWJsZUVsZW1lbnRJbmRleCA9IGVsZW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dEZvY3VzYWJsZUVsZW1lbnRJbmRleCA+PSBlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBuZXh0Rm9jdXNhYmxlRWxlbWVudEluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChlbGVtZW50c1tuZXh0Rm9jdXNhYmxlRWxlbWVudEluZGV4XSBhcyBIVE1MRWxlbWVudCkuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEZvY3VzYWJsZUVsZW1lbnRzKGVsZW1lbnQ6IEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgJ2FbaHJlZl0sIGJ1dHRvbiwgaW5wdXQsIHRleHRhcmVhLCBzZWxlY3QsIGRldGFpbHMsW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJ1xuICAgICAgICApKS5maWx0ZXIoZWwgPT4gIWVsLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSAmJiAhZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEZvY3VzZWRFbGVtZW50KCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIGxldCBhY3RpdmVFbGVtZW50ID1cbiAgICAgICAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICA/IChkb2N1bWVudC5hY3RpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50IHwgbnVsbClcbiAgICAgICAgICAgICAgICA6IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdBY3RpdmVFbGVtZW50ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuICAgICAgICAgICAgaWYgKG5ld0FjdGl2ZUVsZW1lbnQgPT09IGFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IG5ld0FjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbiAgICB9XG59XG4iXX0=