import { Directive, EventEmitter, HostBinding, HostListener, Input, Output, ContentChildren } from '@angular/core';
import { animationFrameScheduler, fromEvent, interval, Subject } from 'rxjs';
import { takeUntil, throttle } from 'rxjs/operators';
import { IgxDefaultDropStrategy } from './drag-drop.strategy';
import * as i0 from "@angular/core";
import * as i1 from "../../core/utils";
var DragScrollDirection;
(function (DragScrollDirection) {
    DragScrollDirection[DragScrollDirection["UP"] = 0] = "UP";
    DragScrollDirection[DragScrollDirection["DOWN"] = 1] = "DOWN";
    DragScrollDirection[DragScrollDirection["LEFT"] = 2] = "LEFT";
    DragScrollDirection[DragScrollDirection["RIGHT"] = 3] = "RIGHT";
})(DragScrollDirection || (DragScrollDirection = {}));
export var DragDirection;
(function (DragDirection) {
    DragDirection[DragDirection["VERTICAL"] = 0] = "VERTICAL";
    DragDirection[DragDirection["HORIZONTAL"] = 1] = "HORIZONTAL";
    DragDirection[DragDirection["BOTH"] = 2] = "BOTH";
})(DragDirection || (DragDirection = {}));
export class IgxDragLocation {
    constructor(_pageX, _pageY) {
        this._pageX = _pageX;
        this._pageY = _pageY;
        this.pageX = parseFloat(_pageX);
        this.pageY = parseFloat(_pageY);
    }
}
export class IgxDragHandleDirective {
    constructor(element) {
        this.element = element;
        this.baseClass = true;
        /**
         * @hidden
         */
        this.parentDragElement = null;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxDragHandleDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: IgxDragHandleDirective, isStandalone: true, selector: "[igxDragHandle]", host: { properties: { "class.igx-drag__handle": "this.baseClass" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxDragHandleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxDragHandle]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { baseClass: [{
                type: HostBinding,
                args: ['class.igx-drag__handle']
            }] } });
export class IgxDragIgnoreDirective {
    constructor(element) {
        this.element = element;
        this.baseClass = true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxDragIgnoreDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: IgxDragIgnoreDirective, isStandalone: true, selector: "[igxDragIgnore]", host: { properties: { "class.igx-drag__ignore": "this.baseClass" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxDragIgnoreDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxDragIgnore]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { baseClass: [{
                type: HostBinding,
                args: ['class.igx-drag__ignore']
            }] } });
export class IgxDragDirective {
    /**
     * - Save data inside the `igxDrag` directive. This can be set when instancing `igxDrag` on an element.
     * ```html
     * <div [igxDrag]="{ source: myElement }"></div>
     * ```
     *
     * @memberof IgxDragDirective
     */
    set data(value) {
        this._data = value;
    }
    get data() {
        return this._data;
    }
    /**
     * Gets the current location of the element relative to the page.
     */
    get location() {
        return new IgxDragLocation(this.pageX, this.pageY);
    }
    /**
     * Gets the original location of the element before dragging started.
     */
    get originLocation() {
        return new IgxDragLocation(this.baseOriginLeft, this.baseOriginTop);
    }
    /**
     * @hidden
     */
    get pointerEventsEnabled() {
        return typeof PointerEvent !== 'undefined';
    }
    /**
     * @hidden
     */
    get touchEventsEnabled() {
        return 'ontouchstart' in window;
    }
    /**
     * @hidden
     */
    get pageX() {
        if (this.ghost && this.ghostElement) {
            return this.ghostLeft;
        }
        return this.baseLeft + this.windowScrollLeft;
    }
    /**
     * @hidden
     */
    get pageY() {
        if (this.ghost && this.ghostElement) {
            return this.ghostTop;
        }
        return this.baseTop + this.windowScrollTop;
    }
    get baseLeft() {
        return this.element.nativeElement.getBoundingClientRect().left;
    }
    get baseTop() {
        return this.element.nativeElement.getBoundingClientRect().top;
    }
    get baseOriginLeft() {
        return this.baseLeft - this.getTransformX(this.element.nativeElement);
    }
    get baseOriginTop() {
        return this.baseTop - this.getTransformY(this.element.nativeElement);
    }
    set ghostLeft(pageX) {
        if (this.ghostElement) {
            // We need to take into account marginLeft, since top style does not include margin, but pageX includes the margin.
            const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
            // If ghost host is defined it needs to be taken into account.
            this.ghostElement.style.left = (pageX - ghostMarginLeft - this._ghostHostX) + 'px';
        }
    }
    get ghostLeft() {
        if (this.ghostElement) {
            return parseInt(this.ghostElement.style.left, 10) + this._ghostHostX;
        }
    }
    set ghostTop(pageY) {
        if (this.ghostElement) {
            // We need to take into account marginTop, since top style does not include margin, but pageY includes the margin.
            const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
            // If ghost host is defined it needs to be taken into account.
            this.ghostElement.style.top = (pageY - ghostMarginTop - this._ghostHostY) + 'px';
        }
    }
    get ghostTop() {
        if (this.ghostElement) {
            return parseInt(this.ghostElement.style.top, 10) + this._ghostHostY;
        }
    }
    get windowScrollTop() {
        return document.documentElement.scrollTop || window.scrollY;
    }
    get windowScrollLeft() {
        return document.documentElement.scrollLeft || window.scrollX;
    }
    get windowScrollHeight() {
        return document.documentElement.scrollHeight;
    }
    get windowScrollWidth() {
        return document.documentElement.scrollWidth;
    }
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetX]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     *
     * @memberof IgxDragDirective
     */
    set ghostOffsetX(value) {
        this._offsetX = parseInt(value, 10);
    }
    get ghostOffsetX() {
        return this._offsetX !== undefined ? this._offsetX : this._defaultOffsetX;
    }
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetY]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     *
     * @memberof IgxDragDirective
     */
    set ghostOffsetY(value) {
        this._offsetY = parseInt(value, 10);
    }
    get ghostOffsetY() {
        return this._offsetY !== undefined ? this._offsetY : this._defaultOffsetY;
    }
    constructor(cdr, element, viewContainer, zone, renderer, platformUtil) {
        this.cdr = cdr;
        this.element = element;
        this.viewContainer = viewContainer;
        this.zone = zone;
        this.renderer = renderer;
        this.platformUtil = platformUtil;
        /**
         * An @Input property that indicates when the drag should start.
         * By default the drag starts after the draggable element is moved by 5px.
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragTolerance = 5;
        /**
         * An @Input property that indicates the directions that the element can be dragged.
         * By default it is set to both horizontal and vertical directions.
         * ```html
         * <div igxDrag [dragDirection]="dragDir">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public dragDir = DragDirection.HORIZONTAL;
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragDirection = DragDirection.BOTH;
        /**
         * An @Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
         * By default it is set to `true`.
         * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
         * ```html
         * <div igxDrag [ghost]="false">
         *      <span>Drag Me!</span>
         * </div>
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.ghost = true;
        /**
         * Sets a custom class that will be added to the `ghostElement` element.
         * ```html
         * <div igxDrag [ghostClass]="'ghostElement'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.ghostClass = '';
        /**
         * An @Input assigning a scroll container to the dragged element. By default its the window.
         */
        this.scrollContainer = null;
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragStart = new EventEmitter();
        /**
         * Event triggered when the draggable element has been moved.
         * ```html
         * <div igxDrag  (dragMove)="onDragMove()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragMove(){
         *      alert("The element has moved!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragMove = new EventEmitter();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragEnd = new EventEmitter();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag (dragClick)="onDragClick()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragClick(){
         *      alert("The element has been clicked!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.dragClick = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostCreate)="ghostCreated()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostCreated(){
         *      alert("The ghost has been created!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.ghostCreate = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostDestroy)="ghostDestroyed()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostDestroyed(){
         *      alert("The ghost has been destroyed!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.ghostDestroy = new EventEmitter();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag (transitioned)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         *
         * @memberof IgxDragDirective
         */
        this.transitioned = new EventEmitter();
        /**
         * @hidden
         */
        this.baseClass = true;
        /**
         * @hidden
         */
        this.selectDisabled = false;
        /**
         * @hidden
         */
        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */
        this.animInProgress = false;
        this.ghostContext = null;
        this._startX = 0;
        this._startY = 0;
        this._lastX = 0;
        this._lastY = 0;
        this._dragStarted = false;
        this._ghostHostX = 0;
        this._ghostHostY = 0;
        this._pointerDownId = null;
        this._clicked = false;
        this._lastDropArea = null;
        this._destroy = new Subject();
        this._removeOnDestroy = true;
        this._scrollContainer = null;
        this._originalScrollContainerWidth = 0;
        this._originalScrollContainerHeight = 0;
        this._scrollContainerStep = 5;
        this._scrollContainerStepMs = 10;
        this._scrollContainerThreshold = 25;
        this._containerScrollIntervalId = null;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (!this.dragHandles || !this.dragHandles.length) {
            // Set user select none to the whole draggable element if no drag handles are defined.
            this.selectDisabled = true;
        }
        // Bind events
        this.zone.runOutsideAngular(() => {
            if (!this.platformUtil.isBrowser) {
                return;
            }
            const targetElements = this.dragHandles && this.dragHandles.length
                ? this.dragHandles
                    .filter(item => item.parentDragElement === null)
                    .map(item => {
                    item.parentDragElement = this.element.nativeElement;
                    return item.element.nativeElement;
                })
                : [this.element.nativeElement];
            targetElements.forEach((element) => {
                if (this.pointerEventsEnabled) {
                    fromEvent(element, 'pointerdown').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                    fromEvent(element, 'pointermove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                    fromEvent(element, 'pointerup').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerUp(res));
                    if (!this.ghost) {
                        // Do not bind `lostpointercapture` to the target, because we will bind it on the ghost later.
                        fromEvent(element, 'lostpointercapture').pipe(takeUntil(this._destroy))
                            .subscribe((res) => this.onPointerLost(res));
                    }
                }
                else if (this.touchEventsEnabled) {
                    fromEvent(element, 'touchstart').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
                else {
                    // We don't have pointer events and touch events. Use then mouse events.
                    fromEvent(element, 'mousedown').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
            });
            // We should bind to document events only once when there are no pointer events.
            if (!this.pointerEventsEnabled && this.touchEventsEnabled) {
                fromEvent(document.defaultView, 'touchmove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'touchend').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            else if (!this.pointerEventsEnabled) {
                fromEvent(document.defaultView, 'mousemove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'mouseup').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            this.element.nativeElement.addEventListener('transitionend', (args) => {
                this.onTransitionEnd(args);
            });
        });
        // Set transition duration to 0s. This also helps with setting `visibility: hidden` to the base to not lag.
        this.element.nativeElement.style.transitionDuration = '0.0s';
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
        if (this.ghost && this.ghostElement && this._removeOnDestroy) {
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
            if (this._dynamicGhostRef) {
                this._dynamicGhostRef.destroy();
                this._dynamicGhostRef = null;
            }
        }
        if (this._containerScrollIntervalId) {
            clearInterval(this._containerScrollIntervalId);
            this._containerScrollIntervalId = null;
        }
    }
    /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     *
     * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     */
    setLocation(newLocation) {
        // We do not subtract marginLeft and marginTop here because here we calculate deltas.
        if (this.ghost && this.ghostElement) {
            this.ghostLeft = newLocation.pageX + this.windowScrollLeft;
            this.ghostTop = newLocation.pageY + this.windowScrollTop;
        }
        else if (!this.ghost) {
            const deltaX = newLocation.pageX - this.pageX;
            const deltaY = newLocation.pageY - this.pageY;
            const transformX = this.getTransformX(this.element.nativeElement);
            const transformY = this.getTransformY(this.element.nativeElement);
            this.setTransformXY(transformX + deltaX, transformY + deltaY);
        }
        this._startX = this.baseLeft;
        this._startY = this.baseTop;
    }
    /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     *
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionToOrigin(customAnimArgs, startLocation) {
        if ((!!startLocation && startLocation.pageX === this.baseOriginLeft && startLocation.pageY === this.baseOriginLeft) ||
            (!startLocation && this.ghost && !this.ghostElement)) {
            return;
        }
        if (!!startLocation && startLocation.pageX !== this.pageX && startLocation.pageY !== this.pageY) {
            if (this.ghost && !this.ghostElement) {
                this._startX = startLocation.pageX;
                this._startY = startLocation.pageY;
                this._ghostStartX = this._startX;
                this._ghostStartY = this._startY;
                this.createGhost(this._startX, this._startY);
            }
            this.setLocation(startLocation);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            if (this.ghost) {
                this.ghostElement.style.transitionProperty = 'top, left';
                this.ghostElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.ghostElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.ghostElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this.setLocation(new IgxDragLocation(this.baseLeft, this.baseTop));
            }
            else if (!this.ghost) {
                this.element.nativeElement.style.transitionProperty = 'transform';
                this.element.nativeElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.element.nativeElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.element.nativeElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this._startX = this.baseLeft;
                this._startY = this.baseTop;
                this.setTransformXY(0, 0);
            }
        }, 0);
    }
    /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     *
     * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionTo(target, customAnimArgs, startLocation) {
        if (!!startLocation && this.ghost && !this.ghostElement) {
            this._startX = startLocation.pageX;
            this._startY = startLocation.pageY;
            this._ghostStartX = this._startX;
            this._ghostStartY = this._startY;
        }
        else if (!!startLocation && (!this.ghost || this.ghostElement)) {
            this.setLocation(startLocation);
        }
        else if (this.ghost && !this.ghostElement) {
            this._startX = this.baseLeft;
            this._startY = this.baseTop;
            this._ghostStartX = this._startX + this.windowScrollLeft;
            this._ghostStartY = this._startY + this.windowScrollTop;
        }
        if (this.ghost && !this.ghostElement) {
            this.createGhost(this._startX, this._startY);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            const movedElem = this.ghost ? this.ghostElement : this.element.nativeElement;
            movedElem.style.transitionProperty = this.ghost && this.ghostElement ? 'left, top' : 'transform';
            movedElem.style.transitionDuration =
                customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
            movedElem.style.transitionTimingFunction =
                customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
            movedElem.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
            if (target instanceof IgxDragLocation) {
                this.setLocation(new IgxDragLocation(target.pageX, target.pageY));
            }
            else {
                const targetRects = target.nativeElement.getBoundingClientRect();
                this.setLocation(new IgxDragLocation(targetRects.left - this.windowScrollLeft, targetRects.top - this.windowScrollTop));
            }
        }, 0);
    }
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param event PointerDown event captured
     */
    onPointerDown(event) {
        const ignoredElement = this.dragIgnoredElems.find(elem => elem.element.nativeElement === event.target);
        if (ignoredElement) {
            return;
        }
        this._clicked = true;
        this._pointerDownId = event.pointerId;
        // Set pointer capture so we detect pointermove even if mouse is out of bounds until ghostElement is created.
        const handleFound = this.dragHandles.find(handle => handle.element.nativeElement === event.target);
        const targetElement = handleFound ? handleFound.element.nativeElement : event.target || this.element.nativeElement;
        if (this.pointerEventsEnabled) {
            targetElement.setPointerCapture(this._pointerDownId);
        }
        else {
            targetElement.focus();
            event.preventDefault();
        }
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
        }
        this._defaultOffsetX = this.baseLeft - this._startX + this.windowScrollLeft;
        this._defaultOffsetY = this.baseTop - this._startY + this.windowScrollTop;
        this._ghostStartX = this._startX + this.ghostOffsetX;
        this._ghostStartY = this._startY + this.ghostOffsetY;
        this._lastX = this._startX;
        this._lastY = this._startY;
    }
    /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param event PointerMove event captured
     */
    onPointerMove(event) {
        if (this._clicked) {
            let pageX;
            let pageY;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            const totalMovedX = pageX - this._startX;
            const totalMovedY = pageY - this._startY;
            if (!this._dragStarted &&
                (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                const dragStartArgs = {
                    originalEvent: event,
                    owner: this,
                    startX: pageX - totalMovedX,
                    startY: pageY - totalMovedY,
                    pageX,
                    pageY,
                    cancel: false
                };
                this.zone.run(() => {
                    this.dragStart.emit(dragStartArgs);
                });
                if (!dragStartArgs.cancel) {
                    this._dragStarted = true;
                    if (this.ghost) {
                        // We moved enough so ghostElement can be rendered and actual dragging to start.
                        // When creating it will take into account any offset set by the user by default.
                        this.createGhost(pageX, pageY);
                    }
                    else if (this._offsetX !== undefined || this._offsetY !== undefined) {
                        // There is no need for ghost, but we will need to position initially the base element to reflect any offset.
                        const transformX = (this._offsetX !== undefined ? this._offsetX - this._defaultOffsetX : 0) +
                            this.getTransformX(this.element.nativeElement);
                        const transformY = (this._offsetY !== undefined ? this._offsetY - this._defaultOffsetY : 0) +
                            this.getTransformY(this.element.nativeElement);
                        this.setTransformXY(transformX, transformY);
                    }
                }
                else {
                    return;
                }
            }
            else if (!this._dragStarted) {
                return;
            }
            const moveArgs = {
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._lastX,
                pageY: this._lastY,
                nextPageX: pageX,
                nextPageY: pageY,
                cancel: false
            };
            this.dragMove.emit(moveArgs);
            const setPageX = moveArgs.nextPageX;
            const setPageY = moveArgs.nextPageY;
            if (!moveArgs.cancel) {
                // Scroll root container if the user reaches its boundaries.
                this.onScrollContainer();
                // Move the actual element around
                if (this.ghost) {
                    const updatedTotalMovedX = this.dragDirection === DragDirection.VERTICAL ? 0 : setPageX - this._startX;
                    const updatedTotalMovedY = this.dragDirection === DragDirection.HORIZONTAL ? 0 : setPageY - this._startY;
                    this.ghostLeft = this._ghostStartX + updatedTotalMovedX;
                    this.ghostTop = this._ghostStartY + updatedTotalMovedY;
                }
                else {
                    const lastMovedX = this.dragDirection === DragDirection.VERTICAL ? 0 : setPageX - this._lastX;
                    const lastMovedY = this.dragDirection === DragDirection.HORIZONTAL ? 0 : setPageY - this._lastY;
                    const translateX = this.getTransformX(this.element.nativeElement) + lastMovedX;
                    const translateY = this.getTransformY(this.element.nativeElement) + lastMovedY;
                    this.setTransformXY(translateX, translateY);
                }
                this.dispatchDragEvents(pageX, pageY, event);
            }
            this._lastX = setPageX;
            this._lastY = setPageY;
        }
    }
    /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param event PointerUp event captured
     */
    onPointerUp(event) {
        if (!this._clicked) {
            return;
        }
        let pageX;
        let pageY;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            pageX = event.pageX;
            pageY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            pageX = event.touches[0].pageX;
            pageY = event.touches[0].pageY;
            // Prevent scrolling on touch while dragging
            event.preventDefault();
        }
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX,
            pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                this.dispatchDropEvent(event.pageX, event.pageY, event);
            }
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
        else {
            // Trigger our own click event because when there is no ghost, native click cannot be prevented when dragging.
            this.zone.run(() => {
                this.dragClick.emit(eventArgs);
            });
        }
        if (this._containerScrollIntervalId) {
            clearInterval(this._containerScrollIntervalId);
            this._containerScrollIntervalId = null;
        }
    }
    /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param event Event captured
     */
    onPointerLost(event) {
        if (!this._clicked) {
            return;
        }
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: event.pageX,
            pageY: event.pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
    }
    /**
     * @hidden
     */
    onTransitionEnd(event) {
        if ((!this._dragStarted && !this.animInProgress) || this._clicked) {
            // Return if no dragging started and there is no animation in progress.
            return;
        }
        if (this.ghost && this.ghostElement) {
            this._ghostStartX = this.baseLeft + this.windowScrollLeft;
            this._ghostStartY = this.baseTop + this.windowScrollTop;
            const ghostDestroyArgs = {
                owner: this,
                ghostElement: this.ghostElement,
                cancel: false
            };
            this.ghostDestroy.emit(ghostDestroyArgs);
            if (ghostDestroyArgs.cancel) {
                return;
            }
            this.ghostElement.remove();
            this.ghostElement = null;
            if (this._dynamicGhostRef) {
                this._dynamicGhostRef.destroy();
                this._dynamicGhostRef = null;
            }
        }
        else if (!this.ghost) {
            this.element.nativeElement.style.transitionProperty = '';
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this.element.nativeElement.style.transitionTimingFunction = '';
            this.element.nativeElement.style.transitionDelay = '';
        }
        this.animInProgress = false;
        this._dragStarted = false;
        // Execute transitioned after everything is reset so if the user sets new location on the base now it would work as expected.
        this.zone.run(() => {
            this.transitioned.emit({
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._startX,
                pageY: this._startY
            });
        });
    }
    /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @param pageX Latest pointer position on the X axis relative to the page.
     * @param pageY Latest pointer position on the Y axis relative to the page.
     * @param node The Node object to be cloned.
     */
    createGhost(pageX, pageY, node = null) {
        if (!this.ghost) {
            return;
        }
        if (this.ghostTemplate) {
            this.zone.run(() => {
                // Create template in zone, so it gets updated by it automatically.
                this._dynamicGhostRef = this.viewContainer.createEmbeddedView(this.ghostTemplate, this.ghostContext);
            });
            if (this._dynamicGhostRef.rootNodes[0].style.display === 'contents') {
                // Change the display to default since display contents does not position the element absolutely.
                this._dynamicGhostRef.rootNodes[0].style.display = 'block';
            }
            this.ghostElement = this._dynamicGhostRef.rootNodes[0];
        }
        else {
            this.ghostElement = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
        }
        const totalMovedX = pageX - this._startX;
        const totalMovedY = pageY - this._startY;
        this._ghostHostX = this.getGhostHostBaseOffsetX();
        this._ghostHostY = this.getGhostHostBaseOffsetY();
        this.ghostElement.style.transitionDuration = '0.0s';
        this.ghostElement.style.position = 'absolute';
        if (this.ghostClass) {
            this.renderer.addClass(this.ghostElement, this.ghostClass);
        }
        const createEventArgs = {
            owner: this,
            ghostElement: this.ghostElement,
            cancel: false
        };
        this.ghostCreate.emit(createEventArgs);
        if (createEventArgs.cancel) {
            this.ghostElement = null;
            if (this.ghostTemplate && this._dynamicGhostRef) {
                this._dynamicGhostRef.destroy();
            }
            return;
        }
        if (this.ghostHost) {
            this.ghostHost.appendChild(this.ghostElement);
        }
        else {
            document.body.appendChild(this.ghostElement);
        }
        const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
        const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
        this.ghostElement.style.left = (this._ghostStartX - ghostMarginLeft + totalMovedX - this._ghostHostX) + 'px';
        this.ghostElement.style.top = (this._ghostStartY - ghostMarginTop + totalMovedY - this._ghostHostY) + 'px';
        if (this.pointerEventsEnabled) {
            // The ghostElement takes control for moving and dragging after it has been rendered.
            if (this._pointerDownId !== null) {
                this.ghostElement.setPointerCapture(this._pointerDownId);
            }
            this.ghostElement.addEventListener('pointermove', (args) => {
                this.onPointerMove(args);
            });
            this.ghostElement.addEventListener('pointerup', (args) => {
                this.onPointerUp(args);
            });
            this.ghostElement.addEventListener('lostpointercapture', (args) => {
                this.onPointerLost(args);
            });
        }
        // Transition animation when the ghostElement is released and it returns to it's original position.
        this.ghostElement.addEventListener('transitionend', (args) => {
            this.onTransitionEnd(args);
        });
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    dispatchDragEvents(pageX, pageY, originalEvent) {
        let topDropArea;
        const customEventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX,
            pageY,
            owner: this,
            originalEvent
        };
        const elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
        let targetElements = [];
        // Check for shadowRoot instance and use it if present
        for (const elFromPoint of elementsFromPoint) {
            if (elFromPoint?.shadowRoot) {
                targetElements = targetElements.concat(this.getFromShadowRoot(elFromPoint, pageX, pageY, elementsFromPoint));
            }
            else if (targetElements.indexOf(elFromPoint) === -1) {
                targetElements.push(elFromPoint);
            }
        }
        for (const element of targetElements) {
            if (element.getAttribute('droppable') === 'true' &&
                element !== this.ghostElement && element !== this.element.nativeElement) {
                topDropArea = element;
                break;
            }
        }
        if (topDropArea &&
            (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
            if (this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            }
            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', customEventArgs);
        }
        else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            this._lastDropArea = null;
            return;
        }
        if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', customEventArgs);
        }
    }
    /**
     * @hidden
     * Traverse shadow dom in depth.
     */
    getFromShadowRoot(elem, pageX, pageY, parentDomElems) {
        const elementsFromPoint = elem.shadowRoot.elementsFromPoint(pageX, pageY);
        const shadowElements = elementsFromPoint.filter(cur => parentDomElems.indexOf(cur) === -1);
        let res = [];
        for (const elFromPoint of shadowElements) {
            if (!!elFromPoint?.shadowRoot && elFromPoint.shadowRoot !== elem.shadowRoot) {
                res = res.concat(this.getFromShadowRoot(elFromPoint, pageX, pageY, elementsFromPoint));
            }
            res.push(elFromPoint);
        }
        return res;
    }
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    dispatchDropEvent(pageX, pageY, originalEvent) {
        const eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX,
            pageY,
            owner: this,
            originalEvent
        };
        this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
        this._lastDropArea = null;
    }
    /**
     * @hidden
     */
    getElementsAtPoint(pageX, pageY) {
        // correct the coordinates with the current scroll position, because
        // document.elementsFromPoint consider position within the current viewport
        // window.pageXOffset == window.scrollX; // always true
        // using window.pageXOffset for IE9 compatibility
        const viewPortX = pageX - window.pageXOffset;
        const viewPortY = pageY - window.pageYOffset;
        if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes
            const elements = document['msElementsFromPoint'](viewPortX, viewPortY);
            return elements === null ? [] : elements;
        }
        else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
        }
    }
    /**
     * @hidden
     */
    dispatchEvent(target, eventName, eventArgs) {
        // This way is IE11 compatible.
        const dragLeaveEvent = document.createEvent('CustomEvent');
        dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
        target.dispatchEvent(dragLeaveEvent);
        // Otherwise can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
    }
    getTransformX(elem) {
        let posX = 0;
        if (elem.style.transform) {
            const matrix = elem.style.transform;
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posX = values ? Number(values[1]) : 0;
        }
        return posX;
    }
    getTransformY(elem) {
        let posY = 0;
        if (elem.style.transform) {
            const matrix = elem.style.transform;
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posY = values ? Number(values[2]) : 0;
        }
        return posY;
    }
    /** Method setting transformation to the base draggable element. */
    setTransformXY(x, y) {
        this.element.nativeElement.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';
    }
    /**
     * Since we are using absolute position to move the ghost, the ghost host might not have position: relative.
     * Combined with position static, this means that the absolute position in the browser is relative to the offsetParent.
     * The offsetParent is pretty much the closes parent that has position: relative, or if no such until it reaches the body.
     * That's why if this is the case, we need to know how much we should compensate for the ghostHost being offset from
     * its offsetParent.
     *
     * OffsetParent can be null in the case of position: fixed applied to the ghost host or display: none. In that case
     * just get the clientRects of the ghost host.
     */
    getGhostHostBaseOffsetX() {
        if (!this.ghostHost)
            return 0;
        const ghostPosition = document.defaultView.getComputedStyle(this.ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && this.ghostHost.offsetParent && this.ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && this.ghostHost.offsetParent) {
            return this.ghostHost.offsetParent.getBoundingClientRect().left + this.windowScrollLeft;
        }
        return this.ghostHost.getBoundingClientRect().left + this.windowScrollLeft;
    }
    getGhostHostBaseOffsetY() {
        if (!this.ghostHost)
            return 0;
        const ghostPosition = document.defaultView.getComputedStyle(this.ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && this.ghostHost.offsetParent && this.ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && this.ghostHost.offsetParent) {
            return this.ghostHost.offsetParent.getBoundingClientRect().top + this.windowScrollTop;
        }
        return this.ghostHost.getBoundingClientRect().top + this.windowScrollTop;
    }
    getContainerScrollDirection() {
        const containerBounds = this.scrollContainer ? this.scrollContainer.getBoundingClientRect() : null;
        const scrolledX = !this.scrollContainer ? this.windowScrollLeft > 0 : this.scrollContainer.scrollLeft > 0;
        const scrolledY = !this.scrollContainer ? this.windowScrollTop > 0 : this.scrollContainer.scrollTop > 0;
        // Take into account window scroll top because we do not use fixed positioning to the window.
        const topBorder = (!this.scrollContainer ? 0 : containerBounds.top) + this.windowScrollTop + this._scrollContainerThreshold;
        // Subtract the element height because we position it from top left corner.
        const elementHeight = this.ghost && this.ghostElement ? this.ghostElement.offsetHeight : this.element.nativeElement.offsetHeight;
        const bottomBorder = (!this.scrollContainer ? window.innerHeight : containerBounds.bottom) +
            this.windowScrollTop - this._scrollContainerThreshold - elementHeight;
        // Same for window scroll left
        const leftBorder = (!this.scrollContainer ? 0 : containerBounds.left) + this.windowScrollLeft + this._scrollContainerThreshold;
        // Subtract the element width again because we position it from top left corner.
        const elementWidth = this.ghost && this.ghostElement ? this.ghostElement.offsetWidth : this.element.nativeElement.offsetWidth;
        const rightBorder = (!this.scrollContainer ? window.innerWidth : containerBounds.right) +
            this.windowScrollLeft - this._scrollContainerThreshold - elementWidth;
        if (this.pageY <= topBorder && scrolledY) {
            return DragScrollDirection.UP;
        }
        else if (this.pageY > bottomBorder) {
            return DragScrollDirection.DOWN;
        }
        else if (this.pageX < leftBorder && scrolledX) {
            return DragScrollDirection.LEFT;
        }
        else if (this.pageX > rightBorder) {
            return DragScrollDirection.RIGHT;
        }
        return null;
    }
    onScrollContainerStep(scrollDir) {
        animationFrameScheduler.schedule(() => {
            let xDir = scrollDir == DragScrollDirection.LEFT ? -1 : (scrollDir == DragScrollDirection.RIGHT ? 1 : 0);
            let yDir = scrollDir == DragScrollDirection.UP ? -1 : (scrollDir == DragScrollDirection.DOWN ? 1 : 0);
            if (!this.scrollContainer) {
                // Cap scrolling so we don't scroll past the window max scroll position.
                const maxScrollX = this._originalScrollContainerWidth - document.documentElement.clientWidth;
                const maxScrollY = this._originalScrollContainerHeight - document.documentElement.clientHeight;
                xDir = (this.windowScrollLeft <= 0 && xDir < 0) || (this.windowScrollLeft >= maxScrollX && xDir > 0) ? 0 : xDir;
                yDir = (this.windowScrollTop <= 0 && yDir < 0) || (this.windowScrollTop >= maxScrollY && yDir > 0) ? 0 : yDir;
            }
            else {
                // Cap scrolling so we don't scroll past the container max scroll position.
                const maxScrollX = this._originalScrollContainerWidth - this.scrollContainer.clientWidth;
                const maxScrollY = this._originalScrollContainerHeight - this.scrollContainer.clientHeight;
                xDir = (this.scrollContainer.scrollLeft <= 0 && xDir < 0) || (this.scrollContainer.scrollLeft >= maxScrollX && xDir > 0) ? 0 : xDir;
                yDir = (this.scrollContainer.scrollTop <= 0 && yDir < 0) || (this.scrollContainer.scrollTop >= maxScrollY && yDir > 0) ? 0 : yDir;
            }
            const scrollByX = xDir * this._scrollContainerStep;
            const scrollByY = yDir * this._scrollContainerStep;
            // Scroll the corresponding window or container.
            if (!this.scrollContainer) {
                window.scrollBy(scrollByX, scrollByY);
            }
            else {
                this.scrollContainer.scrollLeft += scrollByX;
                this.scrollContainer.scrollTop += scrollByY;
            }
            if (this.ghost && !this.scrollContainer) {
                // Scroll the ghost only when there is no container specifies.
                // If it has container the ghost pretty much stays in the same position while the container is scrolled since e use top/left position.
                // Otherwise increase the position the same amount we have scrolled the window
                this.ghostLeft += scrollByX;
                this.ghostTop += scrollByY;
            }
            else if (!this.ghost) {
                // Move the base element the same amount we moved the window/container because we use transformations.
                const translateX = this.getTransformX(this.element.nativeElement) + scrollByX;
                const translateY = this.getTransformY(this.element.nativeElement) + scrollByY;
                this.setTransformXY(translateX, translateY);
                if (!this.scrollContainer) {
                    this._lastX += scrollByX;
                    this._lastY += scrollByY;
                }
            }
        });
    }
    onScrollContainer() {
        const scrollDir = this.getContainerScrollDirection();
        if (scrollDir !== null && scrollDir !== undefined && !this._containerScrollIntervalId) {
            // Save original container sizes to ensure that we don't increase scroll sizes infinitely when out of bounds.
            this._originalScrollContainerWidth = this.scrollContainer ? this.scrollContainer.scrollWidth : this.windowScrollWidth;
            this._originalScrollContainerHeight = this.scrollContainer ? this.scrollContainer.scrollHeight : this.windowScrollHeight;
            this._containerScrollIntervalId = setInterval(() => this.onScrollContainerStep(scrollDir), this._scrollContainerStepMs);
        }
        else if ((scrollDir === null || scrollDir === undefined) && this._containerScrollIntervalId) {
            // We moved out of end bounds and there is interval started
            clearInterval(this._containerScrollIntervalId);
            this._containerScrollIntervalId = null;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxDragDirective, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i1.PlatformUtil }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: IgxDragDirective, isStandalone: true, selector: "[igxDrag]", inputs: { data: ["igxDrag", "data"], dragTolerance: "dragTolerance", dragDirection: "dragDirection", dragChannel: "dragChannel", ghost: "ghost", ghostClass: "ghostClass", ghostTemplate: "ghostTemplate", ghostHost: "ghostHost", scrollContainer: "scrollContainer", ghostOffsetX: "ghostOffsetX", ghostOffsetY: "ghostOffsetY" }, outputs: { dragStart: "dragStart", dragMove: "dragMove", dragEnd: "dragEnd", dragClick: "dragClick", ghostCreate: "ghostCreate", ghostDestroy: "ghostDestroy", transitioned: "transitioned" }, host: { properties: { "class.igx-drag": "this.baseClass", "class.igx-drag--select-disabled": "this.selectDisabled" } }, queries: [{ propertyName: "dragHandles", predicate: IgxDragHandleDirective, descendants: true }, { propertyName: "dragIgnoredElems", predicate: IgxDragIgnoreDirective, descendants: true }], exportAs: ["drag"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxDragDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'drag',
                    selector: '[igxDrag]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i1.PlatformUtil }]; }, propDecorators: { data: [{
                type: Input,
                args: ['igxDrag']
            }], dragTolerance: [{
                type: Input
            }], dragDirection: [{
                type: Input
            }], dragChannel: [{
                type: Input
            }], ghost: [{
                type: Input
            }], ghostClass: [{
                type: Input
            }], ghostTemplate: [{
                type: Input
            }], ghostHost: [{
                type: Input
            }], scrollContainer: [{
                type: Input
            }], dragStart: [{
                type: Output
            }], dragMove: [{
                type: Output
            }], dragEnd: [{
                type: Output
            }], dragClick: [{
                type: Output
            }], ghostCreate: [{
                type: Output
            }], ghostDestroy: [{
                type: Output
            }], transitioned: [{
                type: Output
            }], dragHandles: [{
                type: ContentChildren,
                args: [IgxDragHandleDirective, { descendants: true }]
            }], dragIgnoredElems: [{
                type: ContentChildren,
                args: [IgxDragIgnoreDirective, { descendants: true }]
            }], baseClass: [{
                type: HostBinding,
                args: ['class.igx-drag']
            }], selectDisabled: [{
                type: HostBinding,
                args: ['class.igx-drag--select-disabled']
            }], ghostOffsetX: [{
                type: Input
            }], ghostOffsetY: [{
                type: Input
            }] } });
export class IgxDropDirective {
    /**
     * - Save data inside the `igxDrop` directive. This can be set when instancing `igxDrop` on an element.
     * ```html
     * <div [igxDrop]="{ source: myElement }"></div>
     * ```
     *
     * @memberof IgxDropDirective
     */
    set data(v) {
        this._data = v;
    }
    get data() {
        return this._data;
    }
    /**
     * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
     *  the current drop area. The provided strategies are:
     *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
     *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
     *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
     *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
     *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
     * ```html
     * <div igxDrag>
     *      <span>DragMe</span>
     * </div>
     * <div igxDrop [dropStrategy]="myDropStrategy">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * ```typescript
     * import { IgxAppendDropStrategy } from 'igniteui-angular';
     *
     * export class App {
     *      public myDropStrategy = IgxAppendDropStrategy;
     * }
     * ```
     *
     * @memberof IgxDropDirective
     */
    set dropStrategy(classRef) {
        this._dropStrategy = new classRef(this._renderer);
    }
    get dropStrategy() {
        return this._dropStrategy;
    }
    constructor(element, _renderer, _zone) {
        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         *
         * @memberof IgxDropDirective
         */
        this.enter = new EventEmitter();
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         *
         * @memberof IgxDropDirective
         */
        this.over = new EventEmitter();
        /**
         * Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable element has left the chip area!");
         * }
         * ```
         *
         * @memberof IgxDropDirective
         */
        this.leave = new EventEmitter();
        /**
         * Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable element has been dropped in the chip area!");
         * }
         * ```
         *
         * @memberof IgxDropDirective
         */
        this.dropped = new EventEmitter();
        /**
         * @hidden
         */
        this.droppable = true;
        /**
         * @hidden
         */
        this.dragover = false;
        /**
         * @hidden
         */
        this._destroy = new Subject();
        this._dropStrategy = new IgxDefaultDropStrategy();
    }
    /**
     * @hidden
     */
    onDragDrop(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const args = {
            owner: this,
            originalEvent: event.detail.originalEvent,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX,
            offsetY,
            cancel: false
        };
        this._zone.run(() => {
            this.dropped.emit(args);
        });
        if (this._dropStrategy && !args.cancel) {
            const elementsAtPoint = event.detail.owner.getElementsAtPoint(event.detail.pageX, event.detail.pageY);
            const insertIndex = this.getInsertIndexAt(event.detail.owner, elementsAtPoint);
            this._dropStrategy.dropAction(event.detail.owner, this, insertIndex);
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            fromEvent(this.element.nativeElement, 'igxDragEnter').pipe(takeUntil(this._destroy))
                .subscribe((res) => this.onDragEnter(res));
            fromEvent(this.element.nativeElement, 'igxDragLeave').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragLeave(res));
            fromEvent(this.element.nativeElement, 'igxDragOver').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragOver(res));
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
    }
    /**
     * @hidden
     */
    onDragOver(event) {
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX,
            offsetY
        };
        this.over.emit(eventArgs);
    }
    /**
     * @hidden
     */
    onDragEnter(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = true;
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX,
            offsetY
        };
        this._zone.run(() => {
            this.enter.emit(eventArgs);
        });
    }
    /**
     * @hidden
     */
    onDragLeave(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = false;
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX,
            offsetY
        };
        this._zone.run(() => {
            this.leave.emit(eventArgs);
        });
    }
    getWindowScrollTop() {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    }
    getWindowScrollLeft() {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    }
    isDragLinked(drag) {
        const dragLinkArray = drag.dragChannel instanceof Array;
        const dropLinkArray = this.dropChannel instanceof Array;
        if (!dragLinkArray && !dropLinkArray) {
            return this.dropChannel === drag.dragChannel;
        }
        else if (!dragLinkArray && dropLinkArray) {
            const dropLinks = this.dropChannel;
            for (const link of dropLinks) {
                if (link === drag.dragChannel) {
                    return true;
                }
            }
        }
        else if (dragLinkArray && !dropLinkArray) {
            const dragLinks = drag.dragChannel;
            for (const link of dragLinks) {
                if (link === this.dropChannel) {
                    return true;
                }
            }
        }
        else {
            const dragLinks = drag.dragChannel;
            const dropLinks = this.dropChannel;
            for (const draglink of dragLinks) {
                for (const droplink of dropLinks) {
                    if (draglink === droplink) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    getInsertIndexAt(draggedDir, elementsAtPoint) {
        let insertIndex = -1;
        const dropChildren = Array.prototype.slice.call(this.element.nativeElement.children);
        if (!dropChildren.length) {
            return insertIndex;
        }
        let i = 0;
        let childUnder = null;
        while (!childUnder && i < elementsAtPoint.length) {
            if (elementsAtPoint[i].parentElement === this.element.nativeElement) {
                childUnder = elementsAtPoint[i];
            }
            i++;
        }
        const draggedElemIndex = dropChildren.indexOf(draggedDir.element.nativeElement);
        insertIndex = dropChildren.indexOf(childUnder);
        if (draggedElemIndex !== -1 && draggedElemIndex < insertIndex) {
            insertIndex++;
        }
        return insertIndex;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxDropDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.1.2", type: IgxDropDirective, isStandalone: true, selector: "[igxDrop]", inputs: { data: ["igxDrop", "data"], dropChannel: "dropChannel", dropStrategy: "dropStrategy" }, outputs: { enter: "enter", over: "over", leave: "leave", dropped: "dropped" }, host: { listeners: { "igxDrop": "onDragDrop($event)" }, properties: { "attr.droppable": "this.droppable", "class.dragOver": "this.dragover" } }, exportAs: ["drop"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxDropDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'drop',
                    selector: '[igxDrop]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }]; }, propDecorators: { data: [{
                type: Input,
                args: ['igxDrop']
            }], dropChannel: [{
                type: Input
            }], dropStrategy: [{
                type: Input
            }], enter: [{
                type: Output
            }], over: [{
                type: Output
            }], leave: [{
                type: Output
            }], dropped: [{
                type: Output
            }], droppable: [{
                type: HostBinding,
                args: ['attr.droppable']
            }], dragover: [{
                type: HostBinding,
                args: ['class.dragOver']
            }], onDragDrop: [{
                type: HostListener,
                args: ['igxDrop', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZy1kcm9wLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9kaXJlY3RpdmVzL2RyYWctZHJvcC9kcmFnLWRyb3AuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCxTQUFTLEVBRVQsWUFBWSxFQUNaLFdBQVcsRUFDWCxZQUFZLEVBQ1osS0FBSyxFQUlMLE1BQU0sRUFNTixlQUFlLEVBRWxCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUM3RSxPQUFPLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXJELE9BQU8sRUFBaUIsc0JBQXNCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQzs7O0FBRTdFLElBQUssbUJBS0o7QUFMRCxXQUFLLG1CQUFtQjtJQUN0Qix5REFBRSxDQUFBO0lBQ0YsNkRBQUksQ0FBQTtJQUNKLDZEQUFJLENBQUE7SUFDSiwrREFBSyxDQUFBO0FBQ1AsQ0FBQyxFQUxJLG1CQUFtQixLQUFuQixtQkFBbUIsUUFLdkI7QUFFRCxNQUFNLENBQU4sSUFBWSxhQUlYO0FBSkQsV0FBWSxhQUFhO0lBQ3JCLHlEQUFRLENBQUE7SUFDUiw2REFBVSxDQUFBO0lBQ1YsaURBQUksQ0FBQTtBQUNSLENBQUMsRUFKVyxhQUFhLEtBQWIsYUFBYSxRQUl4QjtBQTBHRCxNQUFNLE9BQU8sZUFBZTtJQUl4QixZQUFvQixNQUFNLEVBQVUsTUFBTTtRQUF0QixXQUFNLEdBQU4sTUFBTSxDQUFBO1FBQVUsV0FBTSxHQUFOLE1BQU0sQ0FBQTtRQUN0QyxJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNoQyxJQUFJLENBQUMs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UyxFQUFFLENBQUMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSG9zdExpc3RlbmVyLFxuICAgIElucHV0LFxuICAgIE5nWm9uZSxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE91dHB1dCxcbiAgICBSZW5kZXJlcjIsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgVmlld0NvbnRhaW5lclJlZixcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBRdWVyeUxpc3Rcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBhbmltYXRpb25GcmFtZVNjaGVkdWxlciwgZnJvbUV2ZW50LCBpbnRlcnZhbCwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsLCB0aHJvdHRsZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElCYXNlRXZlbnRBcmdzLCBQbGF0Zm9ybVV0aWwgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IElEcm9wU3RyYXRlZ3ksIElneERlZmF1bHREcm9wU3RyYXRlZ3kgfSBmcm9tICcuL2RyYWctZHJvcC5zdHJhdGVneSc7XG5cbmVudW0gRHJhZ1Njcm9sbERpcmVjdGlvbiB7XG4gIFVQLFxuICBET1dOLFxuICBMRUZULFxuICBSSUdIVFxufVxuXG5leHBvcnQgZW51bSBEcmFnRGlyZWN0aW9uIHtcbiAgICBWRVJUSUNBTCxcbiAgICBIT1JJWk9OVEFMLFxuICAgIEJPVEhcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzIHtcbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICBwYWdlWDogbnVtYmVyO1xuICAgIHBhZ2VZOiBudW1iZXI7XG4gICAgb3duZXI6IElneERyYWdEaXJlY3RpdmU7XG4gICAgb3JpZ2luYWxFdmVudDogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcm9wQmFzZUV2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBkcmFnZ2FibGUgZWxlbWVudCB0byBlbnRlciB0aGUgaWd4RHJvcCBlbGVtZW50LlxuICAgICAqIENhbiBiZSBQb2ludGVyRXZlbnQsIFRvdWNoRXZlbnQgb3IgTW91c2VFdmVudC5cbiAgICAgKi9cbiAgICBvcmlnaW5hbEV2ZW50OiBhbnk7XG4gICAgLyoqIFRoZSBvd25lciBpZ3hEcm9wIGRpcmVjdGl2ZSB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LiAqL1xuICAgIG93bmVyOiBJZ3hEcm9wRGlyZWN0aXZlO1xuICAgIC8qKiBUaGUgaWd4RHJhZyBkaXJlY3RpdmUgaW5zdGFuY2VkIG9uIGFuIGVsZW1lbnQgdGhhdCBlbnRlcmVkIHRoZSBhcmVhIG9mIHRoZSBpZ3hEcm9wIGVsZW1lbnQgKi9cbiAgICBkcmFnOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgIC8qKiBUaGUgZGF0YSBjb250YWluZWQgZm9yIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpbiBpZ3hEcmFnIGRpcmVjdGl2ZS4gKi9cbiAgICBkcmFnRGF0YTogYW55O1xuICAgIC8qKiBUaGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgd2hlbiB0aGUgZHJhZ2dlZCBlbGVtZW50IGJlZ2FuIG1vdmluZyAqL1xuICAgIHN0YXJ0WDogbnVtYmVyO1xuICAgIC8qKiBUaGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgd2hlbiB0aGUgZHJhZ2dlZCBlbGVtZW50IGJlZ2FuIG1vdmluZyAqL1xuICAgIHN0YXJ0WTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBwYWdlWDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBwYWdlWTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGlneERyb3AuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIG9mZnNldFg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciB0aGF0IGluaXRpYWxpemVzIHRoZSBpZ3hEcm9wLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBvZmZzZXRZOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURyb3BEcm9wcGVkRXZlbnRBcmdzIGV4dGVuZHMgSURyb3BCYXNlRXZlbnRBcmdzIHtcbiAgICAvKiogU3BlY2lmaWVzIGlmIHRoZSBkZWZhdWx0IGRyb3AgbG9naWMgcmVsYXRlZCB0byB0aGUgZXZlbnQgc2hvdWxkIGJlIGNhbmNlbGVkLiAqL1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ0Jhc2VFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBldmVudCB0aGF0IGNhdXNlZCB0aGUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgZWxlbWVudC5cbiAgICAgKiBDYW4gYmUgUG9pbnRlckV2ZW50LCBUb3VjaEV2ZW50IG9yIE1vdXNlRXZlbnQuXG4gICAgICovXG4gICAgb3JpZ2luYWxFdmVudDogUG9pbnRlckV2ZW50IHwgTW91c2VFdmVudCB8IFRvdWNoRXZlbnQ7XG4gICAgLyoqIFRoZSBvd25lciBpZ3hEcmFnIGRpcmVjdGl2ZSB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LiAqL1xuICAgIG93bmVyOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgIC8qKiBUaGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgd2hlbiB0aGUgZHJhZ2dlZCBlbGVtZW50IGJlZ2FuIG1vdmluZyAqL1xuICAgIHN0YXJ0WDogbnVtYmVyO1xuICAgIC8qKiBUaGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgd2hlbiB0aGUgZHJhZ2dlZCBlbGVtZW50IGJlZ2FuIG1vdmluZyAqL1xuICAgIHN0YXJ0WTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBwYWdlWDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyB3aGVuIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBwYWdlWTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcmFnU3RhcnRFdmVudEFyZ3MgZXh0ZW5kcyBJRHJhZ0Jhc2VFdmVudEFyZ3Mge1xuICAgIC8qKiBTZXQgaWYgdGhlIHRoZSBkcmFnZ2luZyBzaG91bGQgYmUgY2FuY2VsZWQuICovXG4gICAgY2FuY2VsOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcmFnTW92ZUV2ZW50QXJncyBleHRlbmRzIElEcmFnU3RhcnRFdmVudEFyZ3Mge1xuICAgIC8qKiBUaGUgbmV3IHBhZ2VYIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIHRoYXQgdGhlIGlneERyYWcgd2lsbCB1c2UuIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIGxpbWl0IGRyYWdnZWQgZWxlbWVudCBYIG1vdmVtZW50LiAqL1xuICAgIG5leHRQYWdlWDogbnVtYmVyO1xuICAgIC8qKiBUaGUgbmV3IHBhZ2VYIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIHRoYXQgdGhlIGlneERyYWcgd2lsbCB1c2UuIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIGxpbWl0IGRyYWdnZWQgZWxlbWVudCBZIG1vdmVtZW50LiAqL1xuICAgIG5leHRQYWdlWTogbnVtYmVyO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgSURyYWdHaG9zdEJhc2VFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqIFRoZSBvd25lciBpZ3hEcmFnIGRpcmVjdGl2ZSB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LiAqL1xuICAgIG93bmVyOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgIC8qKiBJbnN0YW5jZSB0byB0aGUgZ2hvc3QgZWxlbWVudCB0aGF0IGlzIGNyZWF0ZWQgd2hlbiBkcmFnZ2luZyBzdGFydHMuICovXG4gICAgZ2hvc3RFbGVtZW50OiBhbnk7XG4gICAgLyoqIFNldCBpZiB0aGUgZ2hvc3QgY3JlYXRpb24vZGVzdHJ1Y3Rpb24gc2hvdWxkIGJlIGNhbmNlbGVkLiAqL1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ0N1c3RvbVRyYW5zaXRpb25BcmdzIHtcbiAgICBkdXJhdGlvbj86IG51bWJlcjtcbiAgICB0aW1pbmdGdW5jdGlvbj86IHN0cmluZztcbiAgICBkZWxheT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIElneERyYWdMb2NhdGlvbiB7XG4gICAgcHVibGljIHBhZ2VYOiBudW1iZXI7XG4gICAgcHVibGljIHBhZ2VZOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYWdlWCwgcHJpdmF0ZSBfcGFnZVkpIHtcbiAgICAgICAgdGhpcy5wYWdlWCA9IHBhcnNlRmxvYXQoX3BhZ2VYKTtcbiAgICAgICAgdGhpcy5wYWdlWSA9IHBhcnNlRmxvYXQoX3BhZ2VZKTtcbiAgICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneERyYWdIYW5kbGVdJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneERyYWdIYW5kbGVEaXJlY3RpdmUge1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZHJhZ19faGFuZGxlJylcbiAgICBwdWJsaWMgYmFzZUNsYXNzID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgcGFyZW50RHJhZ0VsZW1lbnQ6IEhUTUxFbGVtZW50ID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50OiBFbGVtZW50UmVmPGFueT4pIHt9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneERyYWdJZ25vcmVdJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneERyYWdJZ25vcmVEaXJlY3RpdmUge1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtZHJhZ19faWdub3JlJylcbiAgICBwdWJsaWMgYmFzZUNsYXNzID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50OiBFbGVtZW50UmVmPGFueT4pIHt9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAnZHJhZycsXG4gICAgc2VsZWN0b3I6ICdbaWd4RHJhZ10nLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4RHJhZ0RpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogLSBTYXZlIGRhdGEgaW5zaWRlIHRoZSBgaWd4RHJhZ2AgZGlyZWN0aXZlLiBUaGlzIGNhbiBiZSBzZXQgd2hlbiBpbnN0YW5jaW5nIGBpZ3hEcmFnYCBvbiBhbiBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IFtpZ3hEcmFnXT1cInsgc291cmNlOiBteUVsZW1lbnQgfVwiPjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneERyYWcnKVxuICAgIHB1YmxpYyBzZXQgZGF0YSh2YWx1ZTogYW55KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGRhdGEoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgaW5kaWNhdGVzIHdoZW4gdGhlIGRyYWcgc2hvdWxkIHN0YXJ0LlxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIGRyYWcgc3RhcnRzIGFmdGVyIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyBtb3ZlZCBieSA1cHguXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZHJhZ1RvbGVyYW5jZV09XCIxMDBcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkcmFnVG9sZXJhbmNlID0gNTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGluZGljYXRlcyB0aGUgZGlyZWN0aW9ucyB0aGF0IHRoZSBlbGVtZW50IGNhbiBiZSBkcmFnZ2VkLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGJvdGggaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGlyZWN0aW9ucy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtkcmFnRGlyZWN0aW9uXT1cImRyYWdEaXJcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0RpciA9IERyYWdEaXJlY3Rpb24uSE9SSVpPTlRBTDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZHJhZ0RpcmVjdGlvbiA9IERyYWdEaXJlY3Rpb24uQk9USDtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHByb3ZpZGUgYSB3YXkgZm9yIGlneERyYWcgYW5kIGlneERyb3AgdG8gYmUgbGlua2VkIHRocm91Z2ggY2hhbm5lbHMuXG4gICAgICogSXQgYWNjZXB0cyBzaW5nbGUgdmFsdWUgb3IgYW4gYXJyYXkgb2YgdmFsdWVzIGFuZCBldmFsdWF0ZXMgdGhlbiB1c2luZyBzdHJpY3QgZXF1YWxpdHkuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZHJhZ0NoYW5uZWxdPVwiJ29kZCdcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPjk1PC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIDxkaXYgaWd4RHJvcCBbZHJvcENoYW5uZWxdPVwiWydvZGQnLCAnaXJyYXRpb25hbCddXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5OdW1iZXJzIGRyb3AgYXJlYSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRyYWdDaGFubmVsOiBudW1iZXIgfCBzdHJpbmcgfCBudW1iZXJbXSB8IHN0cmluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBiYXNlIGVsZW1lbnQgc2hvdWxkIG5vdCBiZSBtb3ZlZCBhbmQgYSBnaG9zdCBlbGVtZW50IHNob3VsZCBiZSByZW5kZXJlZCB0aGF0IHJlcHJlc2VudHMgaXQuXG4gICAgICogQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gYHRydWVgLlxuICAgICAqIElmIGl0IGlzIHNldCB0byBgZmFsc2VgIHdoZW4gZHJhZ2dpbmcgdGhlIGJhc2UgZWxlbWVudCBpcyBtb3ZlZCBpbnN0ZWFkIGFuZCBubyBnaG9zdCBlbGVtZW50cyBhcmUgcmVuZGVyZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RdPVwiZmFsc2VcIj5cbiAgICAgKiAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnaG9zdCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY3VzdG9tIGNsYXNzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgYGdob3N0RWxlbWVudGAgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdENsYXNzXT1cIidnaG9zdEVsZW1lbnQnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2hvc3RDbGFzcyA9ICcnO1xuXG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgYSB0ZW1wbGF0ZSBmb3IgdGhlIGdob3N0IGVsZW1lbnQgY3JlYXRlZCB3aGVuIGRyYWdnaW5nIHN0YXJ0cyBhbmQgYGdob3N0YCBpcyB0cnVlLlxuICAgICAqIEJ5IGRlZmF1bHQgYSBjbG9uZSBvZiB0aGUgYmFzZSBlbGVtZW50IHRoZSBpZ3hEcmFnIGlzIGluc3RhbmNlZCBpcyBjcmVhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0VGVtcGxhdGVdPVwiY3VzdG9tR2hvc3RcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIDxuZy10ZW1wbGF0ZSAjY3VzdG9tR2hvc3Q+XG4gICAgICogICAgICA8ZGl2IGNsYXNzPVwiY3VzdG9tR2hvc3RTdHlsZVwiPlxuICAgICAqICAgICAgICAgIDxzcGFuPkkgYW0gYmVpbmcgZHJhZ2dlZCE8L3NwYW4+XG4gICAgICogICAgICA8L2Rpdj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnaG9zdFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpbGwgYmUgYXBwZW5kZWQuXG4gICAgICogQnkgZGVmYXVsdCBpdCdzIHNldCB0byBudWxsIGFuZCB0aGUgZHJhZ2dlZCBlbGVtZW50IGlzIGFwcGVuZGVkIHRvIHRoZSBib2R5LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2ICNob3N0RGl2PjwvZGl2PlxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RIb3N0XT1cImhvc3REaXZcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnaG9zdEhvc3Q7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgYXNzaWduaW5nIGEgc2Nyb2xsIGNvbnRhaW5lciB0byB0aGUgZHJhZ2dlZCBlbGVtZW50LiBCeSBkZWZhdWx0IGl0cyB0aGUgd2luZG93LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNjcm9sbENvbnRhaW5lcjogSFRNTEVsZW1lbnQgPW51bGxcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBkcmFnIHN0YXJ0cy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChkcmFnU3RhcnQpPVwib25EcmFnU3RhcnQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdTdGFydCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZHJhZyBoYXMgc3RhcmVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcmFnU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnU3RhcnRFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaGFzIGJlZW4gbW92ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAgKGRyYWdNb3ZlKT1cIm9uRHJhZ01vdmUoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdNb3ZlKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBlbGVtZW50IGhhcyBtb3ZlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZHJhZ01vdmUgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnTW92ZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyByZWxlYXNlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChkcmFnRW5kKT1cIm9uRHJhZ0VuZCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uRHJhZ0VuZCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZHJhZyBoYXMgZW5kZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGRyYWdFbmQgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnQmFzZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyBjbGlja2VkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgKGRyYWdDbGljayk9XCJvbkRyYWdDbGljaygpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uRHJhZ0NsaWNrKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBlbGVtZW50IGhhcyBiZWVuIGNsaWNrZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGRyYWdDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8SURyYWdCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdGhlIGRyYWcgZ2hvc3QgZWxlbWVudCBpcyBjcmVhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgKGdob3N0Q3JlYXRlKT1cImdob3N0Q3JlYXRlZCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGdob3N0Q3JlYXRlZCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZ2hvc3QgaGFzIGJlZW4gY3JlYXRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZ2hvc3RDcmVhdGUgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnR2hvc3RCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdGhlIGRyYWcgZ2hvc3QgZWxlbWVudCBpcyBjcmVhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgKGdob3N0RGVzdHJveSk9XCJnaG9zdERlc3Ryb3llZCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGdob3N0RGVzdHJveWVkKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBnaG9zdCBoYXMgYmVlbiBkZXN0cm95ZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGdob3N0RGVzdHJveSA9IG5ldyBFdmVudEVtaXR0ZXI8SURyYWdHaG9zdEJhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGlzIHJlbGVhc2VkIGFuZCBhZnRlciBpdHMgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnICh0cmFuc2l0aW9uZWQpPVwib25Nb3ZlRW5kKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25Nb3ZlRW5kKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBtb3ZlIGhhcyBlbmRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgdHJhbnNpdGlvbmVkID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJhZ0Jhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJZ3hEcmFnSGFuZGxlRGlyZWN0aXZlLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pXG4gICAgcHVibGljIGRyYWdIYW5kbGVzOiBRdWVyeUxpc3Q8SWd4RHJhZ0hhbmRsZURpcmVjdGl2ZT47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJZ3hEcmFnSWdub3JlRGlyZWN0aXZlLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pXG4gICAgcHVibGljIGRyYWdJZ25vcmVkRWxlbXM6IFF1ZXJ5TGlzdDxJZ3hEcmFnSWdub3JlRGlyZWN0aXZlPjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kcmFnJylcbiAgICBwdWJsaWMgYmFzZUNsYXNzID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kcmFnLS1zZWxlY3QtZGlzYWJsZWQnKVxuICAgIHB1YmxpYyBzZWxlY3REaXNhYmxlZCA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIG9mIHRoZSBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBwYWdlLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbG9jYXRpb24oKTogSWd4RHJhZ0xvY2F0aW9uIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJZ3hEcmFnTG9jYXRpb24odGhpcy5wYWdlWCwgdGhpcy5wYWdlWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhlIGVsZW1lbnQgYmVmb3JlIGRyYWdnaW5nIHN0YXJ0ZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldCBvcmlnaW5Mb2NhdGlvbigpOiBJZ3hEcmFnTG9jYXRpb24ge1xuICAgICAgICByZXR1cm4gbmV3IElneERyYWdMb2NhdGlvbih0aGlzLmJhc2VPcmlnaW5MZWZ0LCB0aGlzLmJhc2VPcmlnaW5Ub3ApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBvaW50ZXJFdmVudHNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdG91Y2hFdmVudHNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBhZ2VYKCkge1xuICAgICAgICBpZiAodGhpcy5naG9zdCAmJiB0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2hvc3RMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VMZWZ0ICsgdGhpcy53aW5kb3dTY3JvbGxMZWZ0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBhZ2VZKCkge1xuICAgICAgICBpZiAodGhpcy5naG9zdCAmJiB0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2hvc3RUb3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVRvcCArIHRoaXMud2luZG93U2Nyb2xsVG9wO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgYmFzZUxlZnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBiYXNlVG9wKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBiYXNlT3JpZ2luTGVmdCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlTGVmdCAtIHRoaXMuZ2V0VHJhbnNmb3JtWCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBiYXNlT3JpZ2luVG9wKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VUb3AgLSB0aGlzLmdldFRyYW5zZm9ybVkodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzZXQgZ2hvc3RMZWZ0KHBhZ2VYOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IG1hcmdpbkxlZnQsIHNpbmNlIHRvcCBzdHlsZSBkb2VzIG5vdCBpbmNsdWRlIG1hcmdpbiwgYnV0IHBhZ2VYIGluY2x1ZGVzIHRoZSBtYXJnaW4uXG4gICAgICAgICAgICBjb25zdCBnaG9zdE1hcmdpbkxlZnQgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZ2hvc3RFbGVtZW50KVsnbWFyZ2luLWxlZnQnXSwgMTApO1xuICAgICAgICAgICAgLy8gSWYgZ2hvc3QgaG9zdCBpcyBkZWZpbmVkIGl0IG5lZWRzIHRvIGJlIHRha2VuIGludG8gYWNjb3VudC5cbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLmxlZnQgPSAocGFnZVggLSBnaG9zdE1hcmdpbkxlZnQgLSB0aGlzLl9naG9zdEhvc3RYKSArICdweCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGdob3N0TGVmdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5naG9zdEVsZW1lbnQuc3R5bGUubGVmdCwgMTApICsgdGhpcy5fZ2hvc3RIb3N0WDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBzZXQgZ2hvc3RUb3AocGFnZVk6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgbWFyZ2luVG9wLCBzaW5jZSB0b3Agc3R5bGUgZG9lcyBub3QgaW5jbHVkZSBtYXJnaW4sIGJ1dCBwYWdlWSBpbmNsdWRlcyB0aGUgbWFyZ2luLlxuICAgICAgICAgICAgY29uc3QgZ2hvc3RNYXJnaW5Ub3AgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZ2hvc3RFbGVtZW50KVsnbWFyZ2luLXRvcCddLCAxMCk7XG4gICAgICAgICAgICAvLyBJZiBnaG9zdCBob3N0IGlzIGRlZmluZWQgaXQgbmVlZHMgdG8gYmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudG9wID0gKHBhZ2VZIC0gZ2hvc3RNYXJnaW5Ub3AgLSB0aGlzLl9naG9zdEhvc3RZKSArICdweCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGdob3N0VG9wKCkge1xuICAgICAgICBpZiAodGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdob3N0RWxlbWVudC5zdHlsZS50b3AsIDEwKSArIHRoaXMuX2dob3N0SG9zdFk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IHdpbmRvd1Njcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgd2luZG93LnNjcm9sbFk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCB3aW5kb3dTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgd2luZG93LnNjcm9sbFg7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCB3aW5kb3dTY3JvbGxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgd2luZG93U2Nyb2xsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBkZWZhdWx0UmV0dXJuRHVyYXRpb24gPSAnMC41cyc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdob3N0RWxlbWVudDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgYW5pbUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIHByb3RlY3RlZCBnaG9zdENvbnRleHQ6IGFueSA9IG51bGw7XG4gICAgcHJvdGVjdGVkIF9zdGFydFggPSAwO1xuICAgIHByb3RlY3RlZCBfc3RhcnRZID0gMDtcbiAgICBwcm90ZWN0ZWQgX2xhc3RYID0gMDtcbiAgICBwcm90ZWN0ZWQgX2xhc3RZID0gMDtcbiAgICBwcm90ZWN0ZWQgX2RyYWdTdGFydGVkID0gZmFsc2U7XG5cbiAgICAvKiogRHJhZyBnaG9zdCByZWxhdGVkIHByb3BlcnRpZXMgKi9cbiAgICBwcm90ZWN0ZWQgX2RlZmF1bHRPZmZzZXRYO1xuICAgIHByb3RlY3RlZCBfZGVmYXVsdE9mZnNldFk7XG4gICAgcHJvdGVjdGVkIF9vZmZzZXRYO1xuICAgIHByb3RlY3RlZCBfb2Zmc2V0WTtcbiAgICBwcm90ZWN0ZWQgX2dob3N0U3RhcnRYO1xuICAgIHByb3RlY3RlZCBfZ2hvc3RTdGFydFk7XG4gICAgcHJvdGVjdGVkIF9naG9zdEhvc3RYID0gMDtcbiAgICBwcm90ZWN0ZWQgX2dob3N0SG9zdFkgPSAwO1xuICAgIHByb3RlY3RlZCBfZHluYW1pY0dob3N0UmVmO1xuXG4gICAgcHJvdGVjdGVkIF9wb2ludGVyRG93bklkID0gbnVsbDtcbiAgICBwcm90ZWN0ZWQgX2NsaWNrZWQgPSBmYWxzZTtcbiAgICBwcm90ZWN0ZWQgX2xhc3REcm9wQXJlYSA9IG51bGw7XG5cbiAgICBwcm90ZWN0ZWQgX2Rlc3Ryb3kgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICAgIHByb3RlY3RlZCBfcmVtb3ZlT25EZXN0cm95ID0gdHJ1ZTtcbiAgICBwcm90ZWN0ZWQgX2RhdGE6IGFueTtcbiAgICBwcm90ZWN0ZWQgX3Njcm9sbENvbnRhaW5lciA9IG51bGw7XG4gICAgcHJvdGVjdGVkIF9vcmlnaW5hbFNjcm9sbENvbnRhaW5lcldpZHRoID0gMDtcbiAgICBwcm90ZWN0ZWQgX29yaWdpbmFsU2Nyb2xsQ29udGFpbmVySGVpZ2h0ID0gMDtcbiAgICBwcm90ZWN0ZWQgX3Njcm9sbENvbnRhaW5lclN0ZXAgPSA1O1xuICAgIHByb3RlY3RlZCBfc2Nyb2xsQ29udGFpbmVyU3RlcE1zID0gMTA7XG4gICAgcHJvdGVjdGVkIF9zY3JvbGxDb250YWluZXJUaHJlc2hvbGQgPSAyNTtcbiAgICBwcm90ZWN0ZWQgX2NvbnRhaW5lclNjcm9sbEludGVydmFsSWQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIHRoZSBvZmZzZXQgb2YgdGhlIGRyYWdnZWQgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgbW91c2UgaW4gcGl4ZWxzLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyB0YWtpbmcgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSBtb3VzZSB3aGVuIHRoZSBkcmFnIHN0YXJ0ZWQgYW5kIGtlZXBzIGl0IHRoZSBzYW1lLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2ICNob3N0RGl2PjwvZGl2PlxuICAgICAqIDxkaXYgaWd4RHJhZyBbZ2hvc3RPZmZzZXRYXT1cIjBcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgZ2hvc3RPZmZzZXRYKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX29mZnNldFggPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZ2hvc3RPZmZzZXRYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0WCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb2Zmc2V0WCA6IHRoaXMuX2RlZmF1bHRPZmZzZXRYO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyB0aGUgb2Zmc2V0IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIG1vdXNlIGluIHBpeGVscy5cbiAgICAgKiBCeSBkZWZhdWx0IGl0J3MgdGFraW5nIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiB0byB0aGUgbW91c2Ugd2hlbiB0aGUgZHJhZyBzdGFydGVkIGFuZCBrZWVwcyBpdCB0aGUgc2FtZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiAjaG9zdERpdj48L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0T2Zmc2V0WV09XCIwXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IGdob3N0T2Zmc2V0WSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vZmZzZXRZID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGdob3N0T2Zmc2V0WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldFkgIT09IHVuZGVmaW5lZCA/IHRoaXMuX29mZnNldFkgOiB0aGlzLl9kZWZhdWx0T2Zmc2V0WSA7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgcHVibGljIHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHB1YmxpYyB6b25lOiBOZ1pvbmUsXG4gICAgICAgIHB1YmxpYyByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICBwcm90ZWN0ZWQgcGxhdGZvcm1VdGlsOiBQbGF0Zm9ybVV0aWwsXG4gICAgKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5kcmFnSGFuZGxlcyB8fCAhdGhpcy5kcmFnSGFuZGxlcy5sZW5ndGggKSB7XG4gICAgICAgICAgICAvLyBTZXQgdXNlciBzZWxlY3Qgbm9uZSB0byB0aGUgd2hvbGUgZHJhZ2dhYmxlIGVsZW1lbnQgaWYgbm8gZHJhZyBoYW5kbGVzIGFyZSBkZWZpbmVkLlxuICAgICAgICAgICAgdGhpcy5zZWxlY3REaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCaW5kIGV2ZW50c1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBsYXRmb3JtVXRpbC5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50cyA9IHRoaXMuZHJhZ0hhbmRsZXMgJiYgdGhpcy5kcmFnSGFuZGxlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IHRoaXMuZHJhZ0hhbmRsZXNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0ucGFyZW50RHJhZ0VsZW1lbnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnBhcmVudERyYWdFbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBbdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnRdO1xuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21FdmVudChlbGVtZW50LCAncG9pbnRlcmRvd24nKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlckRvd24ocmVzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZnJvbUV2ZW50KGVsZW1lbnQsICdwb2ludGVybW92ZScpLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZSgoKSA9PiBpbnRlcnZhbCgwLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlcikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpXG4gICAgICAgICAgICAgICAgICAgICkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyTW92ZShyZXMpKTtcblxuICAgICAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZWxlbWVudCwgJ3BvaW50ZXJ1cCcpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlclVwKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5naG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGJpbmQgYGxvc3Rwb2ludGVyY2FwdHVyZWAgdG8gdGhlIHRhcmdldCwgYmVjYXVzZSB3ZSB3aWxsIGJpbmQgaXQgb24gdGhlIGdob3N0IGxhdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUV2ZW50KGVsZW1lbnQsICdsb3N0cG9pbnRlcmNhcHR1cmUnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJMb3N0KHJlcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZWxlbWVudCwgJ3RvdWNoc3RhcnQnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlckRvd24ocmVzKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBwb2ludGVyIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLiBVc2UgdGhlbiBtb3VzZSBldmVudHMuXG4gICAgICAgICAgICAgICAgICAgIGZyb21FdmVudChlbGVtZW50LCAnbW91c2Vkb3duJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJEb3duKHJlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgYmluZCB0byBkb2N1bWVudCBldmVudHMgb25seSBvbmNlIHdoZW4gdGhlcmUgYXJlIG5vIHBvaW50ZXIgZXZlbnRzLlxuICAgICAgICAgICAgaWYgKCF0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkICYmIHRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LCAndG91Y2htb3ZlJykucGlwZShcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoKCkgPT4gaW50ZXJ2YWwoMCwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIpKSxcbiAgICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpXG4gICAgICAgICAgICAgICAgKS5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJNb3ZlKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LCAndG91Y2hlbmQnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlclVwKHJlcykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGZyb21FdmVudChkb2N1bWVudC5kZWZhdWx0VmlldywgJ21vdXNlbW92ZScpLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlKCgpID0+IGludGVydmFsKDAsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKSksXG4gICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KVxuICAgICAgICAgICAgICAgICkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyTW92ZShyZXMpKTtcblxuICAgICAgICAgICAgICAgIGZyb21FdmVudChkb2N1bWVudC5kZWZhdWx0VmlldywgJ21vdXNldXAnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlclVwKHJlcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTZXQgdHJhbnNpdGlvbiBkdXJhdGlvbiB0byAwcy4gVGhpcyBhbHNvIGhlbHBzIHdpdGggc2V0dGluZyBgdmlzaWJpbGl0eTogaGlkZGVuYCB0byB0aGUgYmFzZSB0byBub3QgbGFnLlxuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMC4wcyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveS5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLl9kZXN0cm95LmNvbXBsZXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2hvc3QgJiYgdGhpcy5naG9zdEVsZW1lbnQgJiYgdGhpcy5fcmVtb3ZlT25EZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZ2hvc3RFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2R5bmFtaWNHaG9zdFJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNHaG9zdFJlZi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0dob3N0UmVmID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXJTY3JvbGxJbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2NvbnRhaW5lclNjcm9sbEludGVydmFsSWQpO1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyU2Nyb2xsSW50ZXJ2YWxJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGRlc2lyZWQgbG9jYXRpb24gb2YgdGhlIGJhc2UgZWxlbWVudCBvciBnaG9zdCBlbGVtZW50IGlmIHJlbmRlZCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3TG9jYXRpb24gTmV3IGxvY2F0aW9uIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQuIEl0IGlzIGFkdmlzZWQgdG8gZ2V0IG5ldyBsb2NhdGlvbiB1c2luZyBnZXRCb3VuZGluZ0NsaWVudFJlY3RzKCkgKyBzY3JvbGwuXG4gICAgICovXG4gICAgcHVibGljIHNldExvY2F0aW9uKG5ld0xvY2F0aW9uOiBJZ3hEcmFnTG9jYXRpb24pIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IHN1YnRyYWN0IG1hcmdpbkxlZnQgYW5kIG1hcmdpblRvcCBoZXJlIGJlY2F1c2UgaGVyZSB3ZSBjYWxjdWxhdGUgZGVsdGFzLlxuICAgICAgICBpZiAodGhpcy5naG9zdCAmJiB0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5naG9zdExlZnQgPSBuZXdMb2NhdGlvbi5wYWdlWCArIHRoaXMud2luZG93U2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RUb3AgPSBuZXdMb2NhdGlvbi5wYWdlWSArIHRoaXMud2luZG93U2Nyb2xsVG9wO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YVggPSBuZXdMb2NhdGlvbi5wYWdlWCAtIHRoaXMucGFnZVg7XG4gICAgICAgICAgICBjb25zdCBkZWx0YVkgPSBuZXdMb2NhdGlvbi5wYWdlWSAtIHRoaXMucGFnZVk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1YID0gdGhpcy5nZXRUcmFuc2Zvcm1YKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVkgPSB0aGlzLmdldFRyYW5zZm9ybVkodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1YWSh0cmFuc2Zvcm1YICsgZGVsdGFYLCB0cmFuc2Zvcm1ZICsgZGVsdGFZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuYmFzZUxlZnQ7XG4gICAgICAgIHRoaXMuX3N0YXJ0WSA9IHRoaXMuYmFzZVRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRlcyB0aGUgYmFzZSBvciBnaG9zdCBlbGVtZW50IGRlcGVuZGluZyBvbiB0aGUgYGdob3N0YCBpbnB1dCB0byBpdHMgaW5pdGlhbCBsb2NhdGlvbi5cbiAgICAgKiBJZiBgZ2hvc3RgIGlzIHRydWUgYnV0IHRoZXJlIGlzIG5vdCBnaG9zdCByZW5kZXJlZCwgaXQgd2lsbCBiZSBjcmVhdGVkIGFuZCBhbmltYXRlZC5cbiAgICAgKiBJZiB0aGUgYmFzZSBlbGVtZW50IGhhcyBjaGFuZ2VkIGl0cyBET00gcG9zaXRpb24gaXRzIGluaXRpYWwgbG9jYXRpb24gd2lsbCBiZSBjaGFuZ2VkIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGN1c3RvbUFuaW1BcmdzIEN1c3RvbSB0cmFuc2l0aW9uIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgd2hlbiBwZXJmb3JtaW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSBzdGFydExvY2F0aW9uIFN0YXJ0IGxvY2F0aW9uIGZyb20gd2hlcmUgdGhlIHRyYW5zaXRpb24gc2hvdWxkIHN0YXJ0LlxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFuc2l0aW9uVG9PcmlnaW4oY3VzdG9tQW5pbUFyZ3M/OiBJRHJhZ0N1c3RvbVRyYW5zaXRpb25BcmdzLCBzdGFydExvY2F0aW9uPzogSWd4RHJhZ0xvY2F0aW9uKSB7XG4gICAgICAgIGlmICgoISFzdGFydExvY2F0aW9uICYmIHN0YXJ0TG9jYXRpb24ucGFnZVggPT09IHRoaXMuYmFzZU9yaWdpbkxlZnQgJiYgc3RhcnRMb2NhdGlvbi5wYWdlWSA9PT0gdGhpcy5iYXNlT3JpZ2luTGVmdCkgfHxcbiAgICAgICAgICAgICghc3RhcnRMb2NhdGlvbiAmJiB0aGlzLmdob3N0ICYmICF0aGlzLmdob3N0RWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghIXN0YXJ0TG9jYXRpb24gJiYgc3RhcnRMb2NhdGlvbi5wYWdlWCAhPT0gdGhpcy5wYWdlWCAmJiBzdGFydExvY2F0aW9uLnBhZ2VZICE9PSB0aGlzLnBhZ2VZKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5naG9zdCAmJiAhdGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFggPSBzdGFydExvY2F0aW9uLnBhZ2VYO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IHN0YXJ0TG9jYXRpb24ucGFnZVk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFggPSB0aGlzLl9zdGFydFg7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFkgPSB0aGlzLl9zdGFydFk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVHaG9zdCh0aGlzLl9zdGFydFgsIHRoaXMuX3N0YXJ0WSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0TG9jYXRpb24oc3RhcnRMb2NhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFuaW1JblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgLy8gVXNlIHNldFRpbWVvdXQgYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIHN1cmUgdGhhdCB0aGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkIGZpcnN0IGNvcnJlY3RseSBpZiB0aGVyZSBpcyBzdGFydCBsb2NhdGlvbi5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5naG9zdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9ICd0b3AsIGxlZnQnO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUFuaW1BcmdzICYmIGN1c3RvbUFuaW1BcmdzLmR1cmF0aW9uID8gY3VzdG9tQW5pbUFyZ3MuZHVyYXRpb24gKyAncycgOiB0aGlzLmRlZmF1bHRSZXR1cm5EdXJhdGlvbiA7XG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQW5pbUFyZ3MgJiYgY3VzdG9tQW5pbUFyZ3MudGltaW5nRnVuY3Rpb24gPyBjdXN0b21BbmltQXJncy50aW1pbmdGdW5jdGlvbiA6ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EZWxheSA9IGN1c3RvbUFuaW1BcmdzICYmIGN1c3RvbUFuaW1BcmdzLmRlbGF5ID8gY3VzdG9tQW5pbUFyZ3MuZGVsYXkgKyAncycgOiAnJztcbiAgICAgICAgICAgICAgICB0aGlzLnNldExvY2F0aW9uKG5ldyBJZ3hEcmFnTG9jYXRpb24odGhpcy5iYXNlTGVmdCwgdGhpcy5iYXNlVG9wKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJ3RyYW5zZm9ybSc7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQW5pbUFyZ3MgJiYgY3VzdG9tQW5pbUFyZ3MuZHVyYXRpb24gPyBjdXN0b21BbmltQXJncy5kdXJhdGlvbiArICdzJyA6IHRoaXMuZGVmYXVsdFJldHVybkR1cmF0aW9uIDtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPVxuICAgICAgICAgICAgICAgICAgICBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy50aW1pbmdGdW5jdGlvbiA/IGN1c3RvbUFuaW1BcmdzLnRpbWluZ0Z1bmN0aW9uIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gY3VzdG9tQW5pbUFyZ3MgJiYgY3VzdG9tQW5pbUFyZ3MuZGVsYXkgPyBjdXN0b21BbmltQXJncy5kZWxheSArICdzJyA6ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuYmFzZUxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gdGhpcy5iYXNlVG9wO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtWFkoMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGVzIHRoZSBiYXNlIG9yIGdob3N0IGVsZW1lbnQgdG8gYSBzcGVjaWZpYyB0YXJnZXQgbG9jYXRpb24gb3Igb3RoZXIgZWxlbWVudCB1c2luZyB0cmFuc2l0aW9uLlxuICAgICAqIElmIGBnaG9zdGAgaXMgdHJ1ZSBidXQgdGhlcmUgaXMgbm90IGdob3N0IHJlbmRlcmVkLCBpdCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGFuaW1hdGVkLlxuICAgICAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0cygpICsgcGFnZVNjcm9sbCcgd2hlbiBkZXRlcm1pbmluZyBkZXNpcmVkIGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgdGhhdCB0aGUgYmFzZSBvciBnaG9zdCB3aWxsIHRyYW5zaXRpb24gdG8uIEl0IGNhbiBiZSBlaXRoZXIgbG9jYXRpb24gaW4gdGhlIHBhZ2Ugb3IgYW5vdGhlciBIVE1MIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGN1c3RvbUFuaW1BcmdzIEN1c3RvbSB0cmFuc2l0aW9uIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgd2hlbiBwZXJmb3JtaW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSBzdGFydExvY2F0aW9uIFN0YXJ0IGxvY2F0aW9uIGZyb20gd2hlcmUgdGhlIHRyYW5zaXRpb24gc2hvdWxkIHN0YXJ0LlxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFuc2l0aW9uVG8odGFyZ2V0OiBJZ3hEcmFnTG9jYXRpb24gfCBFbGVtZW50UmVmLCBjdXN0b21BbmltQXJncz86IElEcmFnQ3VzdG9tVHJhbnNpdGlvbkFyZ3MsIHN0YXJ0TG9jYXRpb24/OiBJZ3hEcmFnTG9jYXRpb24pIHtcbiAgICAgICAgaWYgKCEhc3RhcnRMb2NhdGlvbiAmJiB0aGlzLmdob3N0ICYmICF0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gc3RhcnRMb2NhdGlvbi5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IHN0YXJ0TG9jYXRpb24ucGFnZVk7XG4gICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WCA9IHRoaXMuX3N0YXJ0WDtcbiAgICAgICAgICAgIHRoaXMuX2dob3N0U3RhcnRZID0gdGhpcy5fc3RhcnRZO1xuICAgICAgICB9IGVsc2UgaWYgKCEhc3RhcnRMb2NhdGlvbiAmJiAoIXRoaXMuZ2hvc3QgfHwgdGhpcy5naG9zdEVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLnNldExvY2F0aW9uKHN0YXJ0TG9jYXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2hvc3QgJiYgIXRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFggPSB0aGlzLmJhc2VMZWZ0O1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gdGhpcy5iYXNlVG9wO1xuICAgICAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFggPSB0aGlzLl9zdGFydFggKyB0aGlzLndpbmRvd1Njcm9sbExlZnQ7XG4gICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WSA9IHRoaXMuX3N0YXJ0WSArIHRoaXMud2luZG93U2Nyb2xsVG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ2hvc3QgJiYgIXRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUdob3N0KHRoaXMuX3N0YXJ0WCwgdGhpcy5fc3RhcnRZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYW5pbUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAvLyBVc2Ugc2V0VGltZW91dCBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgc3VyZSB0aGF0IHRoZSBlbGVtZW50IGlzIHBvc2l0aW9uZWQgZmlyc3QgY29ycmVjdGx5IGlmIHRoZXJlIGlzIHN0YXJ0IGxvY2F0aW9uLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVkRWxlbSA9IHRoaXMuZ2hvc3QgPyB0aGlzLmdob3N0RWxlbWVudCA6IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgbW92ZWRFbGVtLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IHRoaXMuZ2hvc3QgJiYgdGhpcy5naG9zdEVsZW1lbnQgPyAnbGVmdCwgdG9wJyA6ICd0cmFuc2Zvcm0nO1xuICAgICAgICAgICAgbW92ZWRFbGVtLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9XG4gICAgICAgICAgICAgICAgY3VzdG9tQW5pbUFyZ3MgJiYgY3VzdG9tQW5pbUFyZ3MuZHVyYXRpb24gPyBjdXN0b21BbmltQXJncy5kdXJhdGlvbiArICdzJyA6IHRoaXMuZGVmYXVsdFJldHVybkR1cmF0aW9uIDtcbiAgICAgICAgICAgIG1vdmVkRWxlbS5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPVxuICAgICAgICAgICAgICAgIGN1c3RvbUFuaW1BcmdzICYmIGN1c3RvbUFuaW1BcmdzLnRpbWluZ0Z1bmN0aW9uID8gY3VzdG9tQW5pbUFyZ3MudGltaW5nRnVuY3Rpb24gOiAnJztcbiAgICAgICAgICAgIG1vdmVkRWxlbS5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy5kZWxheSA/IGN1c3RvbUFuaW1BcmdzLmRlbGF5ICsgJ3MnIDogJyc7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJZ3hEcmFnTG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldExvY2F0aW9uKG5ldyBJZ3hEcmFnTG9jYXRpb24gKHRhcmdldC5wYWdlWCwgdGFyZ2V0LnBhZ2VZKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFJlY3RzID0gdGFyZ2V0Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMb2NhdGlvbihuZXcgSWd4RHJhZ0xvY2F0aW9uKFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRSZWN0cy5sZWZ0IC0gIHRoaXMud2luZG93U2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UmVjdHMudG9wIC0gdGhpcy53aW5kb3dTY3JvbGxUb3BcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIE1ldGhvZCBib3VuZCB0byB0aGUgUG9pbnRlckRvd24gZXZlbnQgb2YgdGhlIGJhc2UgZWxlbWVudCBpZ3hEcmFnIGlzIGluaXRpYWxpemVkLlxuICAgICAqIEBwYXJhbSBldmVudCBQb2ludGVyRG93biBldmVudCBjYXB0dXJlZFxuICAgICAqL1xuICAgIHB1YmxpYyBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGlnbm9yZWRFbGVtZW50ID0gdGhpcy5kcmFnSWdub3JlZEVsZW1zLmZpbmQoZWxlbSA9PiBlbGVtLmVsZW1lbnQubmF0aXZlRWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKGlnbm9yZWRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jbGlja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcG9pbnRlckRvd25JZCA9IGV2ZW50LnBvaW50ZXJJZDtcblxuICAgICAgICAvLyBTZXQgcG9pbnRlciBjYXB0dXJlIHNvIHdlIGRldGVjdCBwb2ludGVybW92ZSBldmVuIGlmIG1vdXNlIGlzIG91dCBvZiBib3VuZHMgdW50aWwgZ2hvc3RFbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAgICAgIGNvbnN0IGhhbmRsZUZvdW5kID0gdGhpcy5kcmFnSGFuZGxlcy5maW5kKGhhbmRsZSA9PiBoYW5kbGUuZWxlbWVudC5uYXRpdmVFbGVtZW50ID09PSBldmVudC50YXJnZXQpO1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gaGFuZGxlRm91bmQgPyBoYW5kbGVGb3VuZC5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgOiBldmVudC50YXJnZXQgfHwgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50LnNldFBvaW50ZXJDYXB0dXJlKHRoaXMuX3BvaW50ZXJEb3duSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkIHx8ICF0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZmlyc3QgZm9yIHBvaW50ZXIgZXZlbnRzIG9yIG5vbiB0b3VjaCwgYmVjYXVzZSB3ZSBjYW4gaGF2ZSBwb2ludGVyIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzIGF0IG9uY2UuXG4gICAgICAgICAgICB0aGlzLl9zdGFydFggPSBldmVudC5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RlZmF1bHRPZmZzZXRYID0gdGhpcy5iYXNlTGVmdCAtIHRoaXMuX3N0YXJ0WCArIHRoaXMud2luZG93U2Nyb2xsTGVmdDtcbiAgICAgICAgdGhpcy5fZGVmYXVsdE9mZnNldFkgPSB0aGlzLmJhc2VUb3AgLSB0aGlzLl9zdGFydFkgKyB0aGlzLndpbmRvd1Njcm9sbFRvcDtcbiAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFggPSB0aGlzLl9zdGFydFggKyB0aGlzLmdob3N0T2Zmc2V0WDtcbiAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFkgPSB0aGlzLl9zdGFydFkgKyB0aGlzLmdob3N0T2Zmc2V0WTtcbiAgICAgICAgdGhpcy5fbGFzdFggPSB0aGlzLl9zdGFydFg7XG4gICAgICAgIHRoaXMuX2xhc3RZID0gdGhpcy5fc3RhcnRZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBQZXJmb3JtIGRyYWcgbW92ZSBsb2dpYyB3aGVuIGRyYWdnaW5nIGFuZCBkaXNwYXRjaGluZyBldmVudHMgaWYgdGhlcmUgaXMgaWd4RHJvcCB1bmRlciB0aGUgcG9pbnRlci5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBib3VuZCBhdCBmaXJzdCBhdCB0aGUgYmFzZSBlbGVtZW50LlxuICAgICAqIElmIGRyYWdnaW5nIHN0YXJ0cyBhbmQgYWZ0ZXIgdGhlIGdob3N0RWxlbWVudCBpcyByZW5kZXJlZCB0aGUgcG9pbnRlcklkIGlzIHJlYXNzaWduZWQgaXQuIFRoZW4gdGhpcyBtZXRob2QgaXMgYm91bmQgdG8gaXQuXG4gICAgICogQHBhcmFtIGV2ZW50IFBvaW50ZXJNb3ZlIGV2ZW50IGNhcHR1cmVkXG4gICAgICovXG4gICAgcHVibGljIG9uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NsaWNrZWQpIHtcbiAgICAgICAgICAgIGxldCBwYWdlWDsgbGV0IHBhZ2VZO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQgfHwgIXRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZmlyc3QgZm9yIHBvaW50ZXIgZXZlbnRzIG9yIG5vbiB0b3VjaCwgYmVjYXVzZSB3ZSBjYW4gaGF2ZSBwb2ludGVyIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzIGF0IG9uY2UuXG4gICAgICAgICAgICAgICAgcGFnZVggPSBldmVudC5wYWdlWDtcbiAgICAgICAgICAgICAgICBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHBhZ2VYID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgICAgICBwYWdlWSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiB0b3VjaCB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRvdGFsTW92ZWRYID0gcGFnZVggLSB0aGlzLl9zdGFydFg7XG4gICAgICAgICAgICBjb25zdCB0b3RhbE1vdmVkWSA9IHBhZ2VZIC0gdGhpcy5fc3RhcnRZO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmFnU3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgIChNYXRoLmFicyh0b3RhbE1vdmVkWCkgPiB0aGlzLmRyYWdUb2xlcmFuY2UgfHwgTWF0aC5hYnModG90YWxNb3ZlZFkpID4gdGhpcy5kcmFnVG9sZXJhbmNlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRyYWdTdGFydEFyZ3M6IElEcmFnU3RhcnRFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRYOiBwYWdlWCAtIHRvdGFsTW92ZWRYLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFk6IHBhZ2VZIC0gdG90YWxNb3ZlZFksXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICBwYWdlWSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0LmVtaXQoZHJhZ1N0YXJ0QXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRyYWdTdGFydEFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2hvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1vdmVkIGVub3VnaCBzbyBnaG9zdEVsZW1lbnQgY2FuIGJlIHJlbmRlcmVkIGFuZCBhY3R1YWwgZHJhZ2dpbmcgdG8gc3RhcnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGNyZWF0aW5nIGl0IHdpbGwgdGFrZSBpbnRvIGFjY291bnQgYW55IG9mZnNldCBzZXQgYnkgdGhlIHVzZXIgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlR2hvc3QocGFnZVgsIHBhZ2VZKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9vZmZzZXRYICE9PSB1bmRlZmluZWQgfHwgdGhpcy5fb2Zmc2V0WSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIGZvciBnaG9zdCwgYnV0IHdlIHdpbGwgbmVlZCB0byBwb3NpdGlvbiBpbml0aWFsbHkgdGhlIGJhc2UgZWxlbWVudCB0byByZWZsZWN0IGFueSBvZmZzZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1YID0gKHRoaXMuX29mZnNldFggIT09IHVuZGVmaW5lZCA/IHRoaXMuX29mZnNldFggLSB0aGlzLl9kZWZhdWx0T2Zmc2V0WCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFRyYW5zZm9ybVgodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtWSA9ICh0aGlzLl9vZmZzZXRZICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vZmZzZXRZIC0gdGhpcy5fZGVmYXVsdE9mZnNldFkgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUcmFuc2Zvcm1ZKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtWFkodHJhbnNmb3JtWCwgdHJhbnNmb3JtWSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1vdmVBcmdzOiBJRHJhZ01vdmVFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICAgICAgc3RhcnRZOiB0aGlzLl9zdGFydFksXG4gICAgICAgICAgICAgICAgcGFnZVg6IHRoaXMuX2xhc3RYLFxuICAgICAgICAgICAgICAgIHBhZ2VZOiB0aGlzLl9sYXN0WSxcbiAgICAgICAgICAgICAgICBuZXh0UGFnZVg6IHBhZ2VYLFxuICAgICAgICAgICAgICAgIG5leHRQYWdlWTogcGFnZVksXG4gICAgICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ01vdmUuZW1pdChtb3ZlQXJncyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNldFBhZ2VYID0gbW92ZUFyZ3MubmV4dFBhZ2VYO1xuICAgICAgICAgICAgY29uc3Qgc2V0UGFnZVkgPSBtb3ZlQXJncy5uZXh0UGFnZVk7XG4gICAgICAgICAgICBpZiAoIW1vdmVBcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgICAgIC8vIFNjcm9sbCByb290IGNvbnRhaW5lciBpZiB0aGUgdXNlciByZWFjaGVzIGl0cyBib3VuZGFyaWVzLlxuICAgICAgICAgICAgICAgIHRoaXMub25TY3JvbGxDb250YWluZXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIGFjdHVhbCBlbGVtZW50IGFyb3VuZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUb3RhbE1vdmVkWCA9IHRoaXMuZHJhZ0RpcmVjdGlvbiA9PT0gRHJhZ0RpcmVjdGlvbi5WRVJUSUNBTCA/IDAgOiBzZXRQYWdlWCAtIHRoaXMuX3N0YXJ0WDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFRvdGFsTW92ZWRZID0gdGhpcy5kcmFnRGlyZWN0aW9uID09PSBEcmFnRGlyZWN0aW9uLkhPUklaT05UQUwgPyAwIDogc2V0UGFnZVkgLSB0aGlzLl9zdGFydFk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RMZWZ0ID0gdGhpcy5fZ2hvc3RTdGFydFggKyB1cGRhdGVkVG90YWxNb3ZlZFg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RUb3AgPSB0aGlzLl9naG9zdFN0YXJ0WSArIHVwZGF0ZWRUb3RhbE1vdmVkWTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0TW92ZWRYID0gdGhpcy5kcmFnRGlyZWN0aW9uID09PSBEcmFnRGlyZWN0aW9uLlZFUlRJQ0FMID8gMCA6IHNldFBhZ2VYIC0gdGhpcy5fbGFzdFg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RNb3ZlZFkgPSB0aGlzLmRyYWdEaXJlY3Rpb24gPT09IERyYWdEaXJlY3Rpb24uSE9SSVpPTlRBTCA/IDAgOiBzZXRQYWdlWSAtIHRoaXMuX2xhc3RZO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVYID0gdGhpcy5nZXRUcmFuc2Zvcm1YKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSArIGxhc3RNb3ZlZFg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZVkgPSB0aGlzLmdldFRyYW5zZm9ybVkodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpICsgbGFzdE1vdmVkWTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1YWSh0cmFuc2xhdGVYLCB0cmFuc2xhdGVZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaERyYWdFdmVudHMocGFnZVgsIHBhZ2VZLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RYID0gc2V0UGFnZVg7XG4gICAgICAgICAgICB0aGlzLl9sYXN0WSA9IHNldFBhZ2VZO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFBlcmZvcm0gZHJhZyBlbmQgbG9naWMgd2hlbiByZWxlYXNpbmcgdGhlIGdob3N0RWxlbWVudCBhbmQgZGlzcGF0Y2hpbmcgZHJvcCBldmVudCBpZiBpZ3hEcm9wIGlzIHVuZGVyIHRoZSBwb2ludGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGJvdW5kIGF0IGZpcnN0IGF0IHRoZSBiYXNlIGVsZW1lbnQuXG4gICAgICogSWYgZHJhZ2dpbmcgc3RhcnRzIGFuZCBhZnRlciB0aGUgZ2hvc3RFbGVtZW50IGlzIHJlbmRlcmVkIHRoZSBwb2ludGVySWQgaXMgcmVhc3NpZ25lZCB0byBpdC4gVGhlbiB0aGlzIG1ldGhvZCBpcyBib3VuZCB0byBpdC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlclVwIGV2ZW50IGNhcHR1cmVkXG4gICAgICovXG4gICAgcHVibGljIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBhZ2VYOyBsZXQgcGFnZVk7XG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkIHx8ICF0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZmlyc3QgZm9yIHBvaW50ZXIgZXZlbnRzIG9yIG5vbiB0b3VjaCwgYmVjYXVzZSB3ZSBjYW4gaGF2ZSBwb2ludGVyIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzIGF0IG9uY2UuXG4gICAgICAgICAgICBwYWdlWCA9IGV2ZW50LnBhZ2VYO1xuICAgICAgICAgICAgcGFnZVkgPSBldmVudC5wYWdlWTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgcGFnZVggPSBldmVudC50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgcGFnZVkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiB0b3VjaCB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSURyYWdCYXNlRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0WDogdGhpcy5fc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZOiB0aGlzLl9zdGFydFksXG4gICAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BvaW50ZXJEb3duSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jbGlja2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9kcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3REcm9wQXJlYSAmJiB0aGlzLl9sYXN0RHJvcEFyZWEgIT09IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50ICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hEcm9wRXZlbnQoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0VuZC5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmFuaW1JblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIG91ciBvd24gY2xpY2sgZXZlbnQgYmVjYXVzZSB3aGVuIHRoZXJlIGlzIG5vIGdob3N0LCBuYXRpdmUgY2xpY2sgY2Fubm90IGJlIHByZXZlbnRlZCB3aGVuIGRyYWdnaW5nLlxuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnQ2xpY2suZW1pdChldmVudEFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY29udGFpbmVyU2Nyb2xsSW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jb250YWluZXJTY3JvbGxJbnRlcnZhbElkKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lclNjcm9sbEludGVydmFsSWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEV4ZWN1dGUgdGhpcyBtZXRob2Qgd2hlIHRoZSBwb2ludGVyIGNhcHR1cmUgaGFzIGJlZW4gbG9zdC5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgZHVyaW5nIGRyYWdnaW5nIHRoZSB1c2VyIGhhcyBwZXJmb3JtZWQgb3RoZXIgYWN0aW9uIGxpa2UgcmlnaHQgY2xpY2tpbmcgYW5kIHRoZW4gY2xpY2tpbmcgc29tZXdoZXJlIGVsc2UuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBlbnN1cmUgdGhhdCB0aGUgZHJhZyBzdGF0ZSBpcyBiZWluZyByZXNldCBpbiB0aGlzIGNhc2UgYXMgaWYgdGhlIHVzZXIgcmVsZWFzZWQgdGhlIGRyYWdnZWQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Qb2ludGVyTG9zdChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NsaWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBzdGFydFg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogdGhpcy5fc3RhcnRZLFxuICAgICAgICAgICAgcGFnZVg6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LnBhZ2VZXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BvaW50ZXJEb3duSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jbGlja2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9kcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnRW5kLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFuaW1JblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uVHJhbnNpdGlvbkVuZChldmVudCkge1xuICAgICAgICBpZiAoKCF0aGlzLl9kcmFnU3RhcnRlZCAmJiAhdGhpcy5hbmltSW5Qcm9ncmVzcykgfHwgdGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGlmIG5vIGRyYWdnaW5nIHN0YXJ0ZWQgYW5kIHRoZXJlIGlzIG5vIGFuaW1hdGlvbiBpbiBwcm9ncmVzcy5cbiAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5naG9zdCAmJiB0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFggPSB0aGlzLmJhc2VMZWZ0ICsgdGhpcy53aW5kb3dTY3JvbGxMZWZ0O1xuICAgICAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFkgPSB0aGlzLmJhc2VUb3AgKyB0aGlzLndpbmRvd1Njcm9sbFRvcDtcblxuICAgICAgICAgICAgY29uc3QgZ2hvc3REZXN0cm95QXJnczogSURyYWdHaG9zdEJhc2VFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgZ2hvc3RFbGVtZW50OiB0aGlzLmdob3N0RWxlbWVudCxcbiAgICAgICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5naG9zdERlc3Ryb3kuZW1pdChnaG9zdERlc3Ryb3lBcmdzKTtcbiAgICAgICAgICAgIGlmIChnaG9zdERlc3Ryb3lBcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2R5bmFtaWNHaG9zdFJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNHaG9zdFJlZi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0dob3N0UmVmID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5naG9zdCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJyc7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMC4wcyc7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSAnJztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EZWxheSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5pbUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBFeGVjdXRlIHRyYW5zaXRpb25lZCBhZnRlciBldmVyeXRoaW5nIGlzIHJlc2V0IHNvIGlmIHRoZSB1c2VyIHNldHMgbmV3IGxvY2F0aW9uIG9uIHRoZSBiYXNlIG5vdyBpdCB3b3VsZCB3b3JrIGFzIGV4cGVjdGVkLlxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbmVkLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgICAgIHN0YXJ0WDogdGhpcy5fc3RhcnRYLFxuICAgICAgICAgICAgICAgIHN0YXJ0WTogdGhpcy5fc3RhcnRZLFxuICAgICAgICAgICAgICAgIHBhZ2VYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICAgICAgcGFnZVk6IHRoaXMuX3N0YXJ0WVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBDcmVhdGUgZ2hvc3QgZWxlbWVudCAtIGlmIGEgTm9kZSBvYmplY3QgaXMgcHJvdmlkZWQgaXQgY3JlYXRlcyBhIGNsb25lIG9mIHRoYXQgbm9kZSxcbiAgICAgKiBvdGhlcndpc2UgaXQgY2xvbmVzIHRoZSBob3N0IGVsZW1lbnQuXG4gICAgICogQmluZCBhbGwgbmVlZGVkIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0gcGFnZVggTGF0ZXN0IHBvaW50ZXIgcG9zaXRpb24gb24gdGhlIFggYXhpcyByZWxhdGl2ZSB0byB0aGUgcGFnZS5cbiAgICAgKiBAcGFyYW0gcGFnZVkgTGF0ZXN0IHBvaW50ZXIgcG9zaXRpb24gb24gdGhlIFkgYXhpcyByZWxhdGl2ZSB0byB0aGUgcGFnZS5cbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgTm9kZSBvYmplY3QgdG8gYmUgY2xvbmVkLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVHaG9zdChwYWdlWCwgcGFnZVksIG5vZGU6IGFueSA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5naG9zdFRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGVtcGxhdGUgaW4gem9uZSwgc28gaXQgZ2V0cyB1cGRhdGVkIGJ5IGl0IGF1dG9tYXRpY2FsbHkuXG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0dob3N0UmVmID0gdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLmdob3N0VGVtcGxhdGUsIHRoaXMuZ2hvc3RDb250ZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2R5bmFtaWNHaG9zdFJlZi5yb290Tm9kZXNbMF0uc3R5bGUuZGlzcGxheSA9PT0gJ2NvbnRlbnRzJykge1xuICAgICAgICAgICAgICAgIC8vIENoYW5nZSB0aGUgZGlzcGxheSB0byBkZWZhdWx0IHNpbmNlIGRpc3BsYXkgY29udGVudHMgZG9lcyBub3QgcG9zaXRpb24gdGhlIGVsZW1lbnQgYWJzb2x1dGVseS5cbiAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljR2hvc3RSZWYucm9vdE5vZGVzWzBdLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQgPSB0aGlzLl9keW5hbWljR2hvc3RSZWYucm9vdE5vZGVzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQgPSBub2RlID8gbm9kZS5jbG9uZU5vZGUodHJ1ZSkgOiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b3RhbE1vdmVkWCA9IHBhZ2VYIC0gdGhpcy5fc3RhcnRYO1xuICAgICAgICBjb25zdCB0b3RhbE1vdmVkWSA9IHBhZ2VZIC0gdGhpcy5fc3RhcnRZO1xuICAgICAgICB0aGlzLl9naG9zdEhvc3RYID0gdGhpcy5nZXRHaG9zdEhvc3RCYXNlT2Zmc2V0WCgpO1xuICAgICAgICB0aGlzLl9naG9zdEhvc3RZID0gdGhpcy5nZXRHaG9zdEhvc3RCYXNlT2Zmc2V0WSgpO1xuXG4gICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwLjBzJztcbiAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXG4gICAgICAgIGlmICh0aGlzLmdob3N0Q2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5naG9zdEVsZW1lbnQsIHRoaXMuZ2hvc3RDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjcmVhdGVFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIGdob3N0RWxlbWVudDogdGhpcy5naG9zdEVsZW1lbnQsXG4gICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2hvc3RDcmVhdGUuZW1pdChjcmVhdGVFdmVudEFyZ3MpO1xuICAgICAgICBpZiAoY3JlYXRlRXZlbnRBcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2hvc3RUZW1wbGF0ZSAmJiB0aGlzLl9keW5hbWljR2hvc3RSZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljR2hvc3RSZWYuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ2hvc3RIb3N0KSB7XG4gICAgICAgICAgICB0aGlzLmdob3N0SG9zdC5hcHBlbmRDaGlsZCh0aGlzLmdob3N0RWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZ2hvc3RFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdob3N0TWFyZ2luTGVmdCA9IHBhcnNlSW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5naG9zdEVsZW1lbnQpWydtYXJnaW4tbGVmdCddLCAxMCk7XG4gICAgICAgIGNvbnN0IGdob3N0TWFyZ2luVG9wID0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmdob3N0RWxlbWVudClbJ21hcmdpbi10b3AnXSwgMTApO1xuICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5zdHlsZS5sZWZ0ID0gKHRoaXMuX2dob3N0U3RhcnRYIC0gZ2hvc3RNYXJnaW5MZWZ0ICsgdG90YWxNb3ZlZFggLSB0aGlzLl9naG9zdEhvc3RYKSArICdweCc7XG4gICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLnRvcCA9ICh0aGlzLl9naG9zdFN0YXJ0WSAtIGdob3N0TWFyZ2luVG9wICsgdG90YWxNb3ZlZFkgLSB0aGlzLl9naG9zdEhvc3RZKSArICdweCc7XG5cbiAgICAgICAgaWYgKHRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFRoZSBnaG9zdEVsZW1lbnQgdGFrZXMgY29udHJvbCBmb3IgbW92aW5nIGFuZCBkcmFnZ2luZyBhZnRlciBpdCBoYXMgYmVlbiByZW5kZXJlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wb2ludGVyRG93bklkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc2V0UG9pbnRlckNhcHR1cmUodGhpcy5fcG9pbnRlckRvd25JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJNb3ZlKGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyVXAoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvc3Rwb2ludGVyY2FwdHVyZScsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJMb3N0KGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFuc2l0aW9uIGFuaW1hdGlvbiB3aGVuIHRoZSBnaG9zdEVsZW1lbnQgaXMgcmVsZWFzZWQgYW5kIGl0IHJldHVybnMgdG8gaXQncyBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbkVuZChhcmdzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBEaXNwYXRjaCBjdXN0b20gaWd4RHJhZ0VudGVyL2lneERyYWdMZWF2ZSBldmVudHMgYmFzZWQgb24gY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGFuZCBpZiBkcm9wIGFyZWEgaXMgdW5kZXIuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpc3BhdGNoRHJhZ0V2ZW50cyhwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIGxldCB0b3BEcm9wQXJlYTtcbiAgICAgICAgY29uc3QgY3VzdG9tRXZlbnRBcmdzOiBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzID0ge1xuICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IHRoaXMuX3N0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVksXG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnRcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBlbGVtZW50c0Zyb21Qb2ludCA9IHRoaXMuZ2V0RWxlbWVudHNBdFBvaW50KHBhZ2VYLCBwYWdlWSk7XG4gICAgICAgIGxldCB0YXJnZXRFbGVtZW50cyA9IFtdO1xuICAgICAgICAvLyBDaGVjayBmb3Igc2hhZG93Um9vdCBpbnN0YW5jZSBhbmQgdXNlIGl0IGlmIHByZXNlbnRcbiAgICAgICAgZm9yIChjb25zdCBlbEZyb21Qb2ludCBvZiBlbGVtZW50c0Zyb21Qb2ludCkge1xuICAgICAgICAgICAgaWYgKGVsRnJvbVBvaW50Py5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudHMgPSB0YXJnZXRFbGVtZW50cy5jb25jYXQodGhpcy5nZXRGcm9tU2hhZG93Um9vdChlbEZyb21Qb2ludCwgcGFnZVgsIHBhZ2VZLCBlbGVtZW50c0Zyb21Qb2ludCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRFbGVtZW50cy5pbmRleE9mKGVsRnJvbVBvaW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50cy5wdXNoKGVsRnJvbVBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0YXJnZXRFbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkcm9wcGFibGUnKSA9PT0gJ3RydWUnICYmXG4gICAgICAgICAgICBlbGVtZW50ICE9PSB0aGlzLmdob3N0RWxlbWVudCAmJiBlbGVtZW50ICE9PSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRvcERyb3BBcmVhID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3BEcm9wQXJlYSAmJlxuICAgICAgICAgICAgKCF0aGlzLl9sYXN0RHJvcEFyZWEgfHwgKHRoaXMuX2xhc3REcm9wQXJlYSAmJiB0aGlzLl9sYXN0RHJvcEFyZWEgIT09IHRvcERyb3BBcmVhKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGFzdERyb3BBcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnTGVhdmUnLCBjdXN0b21FdmVudEFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3REcm9wQXJlYSA9IHRvcERyb3BBcmVhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnRW50ZXInLCBjdXN0b21FdmVudEFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdG9wRHJvcEFyZWEgJiYgdGhpcy5fbGFzdERyb3BBcmVhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX2xhc3REcm9wQXJlYSwgJ2lneERyYWdMZWF2ZScsIGN1c3RvbUV2ZW50QXJncyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdERyb3BBcmVhID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvcERyb3BBcmVhKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodG9wRHJvcEFyZWEsICdpZ3hEcmFnT3ZlcicsIGN1c3RvbUV2ZW50QXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVHJhdmVyc2Ugc2hhZG93IGRvbSBpbiBkZXB0aC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RnJvbVNoYWRvd1Jvb3QoZWxlbSwgcGFnZVgsIHBhZ2VZLCBwYXJlbnREb21FbGVtcykge1xuICAgICAgICBjb25zdCBlbGVtZW50c0Zyb21Qb2ludCA9IGVsZW0uc2hhZG93Um9vdC5lbGVtZW50c0Zyb21Qb2ludChwYWdlWCwgcGFnZVkpO1xuICAgICAgICBjb25zdCBzaGFkb3dFbGVtZW50cyA9IGVsZW1lbnRzRnJvbVBvaW50LmZpbHRlcihjdXIgPT4gcGFyZW50RG9tRWxlbXMuaW5kZXhPZihjdXIpID09PSAtMSk7XG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbEZyb21Qb2ludCBvZiBzaGFkb3dFbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKCEhZWxGcm9tUG9pbnQ/LnNoYWRvd1Jvb3QgJiYgZWxGcm9tUG9pbnQuc2hhZG93Um9vdCAhPT0gZWxlbS5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdCh0aGlzLmdldEZyb21TaGFkb3dSb290KGVsRnJvbVBvaW50LCBwYWdlWCwgcGFnZVksIGVsZW1lbnRzRnJvbVBvaW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChlbEZyb21Qb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRGlzcGF0Y2ggY3VzdG9tIGlneERyb3AgZXZlbnQgYmFzZWQgb24gY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGlmIHRoZXJlIGlzIGxhc3QgcmVjb3JkZXIgZHJvcCBhcmVhIHVuZGVyIHRoZSBwb2ludGVyLlxuICAgICAqIExhc3QgcmVjb3JkZXIgZHJvcCBhcmVhIGlzIHVwZGF0ZWQgaW4gQGRpc3BhdGNoRHJhZ0V2ZW50cyBtZXRob2QuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpc3BhdGNoRHJvcEV2ZW50KHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnRBcmdzOiBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzID0ge1xuICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IHRoaXMuX3N0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVksXG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnRcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5fbGFzdERyb3BBcmVhLCAnaWd4RHJvcCcsIGV2ZW50QXJncyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnTGVhdmUnLCBldmVudEFyZ3MpO1xuICAgICAgICB0aGlzLl9sYXN0RHJvcEFyZWEgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RWxlbWVudHNBdFBvaW50KHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIpIHtcbiAgICAgICAgLy8gY29ycmVjdCB0aGUgY29vcmRpbmF0ZXMgd2l0aCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24sIGJlY2F1c2VcbiAgICAgICAgLy8gZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQgY29uc2lkZXIgcG9zaXRpb24gd2l0aGluIHRoZSBjdXJyZW50IHZpZXdwb3J0XG4gICAgICAgIC8vIHdpbmRvdy5wYWdlWE9mZnNldCA9PSB3aW5kb3cuc2Nyb2xsWDsgLy8gYWx3YXlzIHRydWVcbiAgICAgICAgLy8gdXNpbmcgd2luZG93LnBhZ2VYT2Zmc2V0IGZvciBJRTkgY29tcGF0aWJpbGl0eVxuICAgICAgICBjb25zdCB2aWV3UG9ydFggPSBwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgICAgY29uc3Qgdmlld1BvcnRZID0gcGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIGlmIChkb2N1bWVudFsnbXNFbGVtZW50c0Zyb21Qb2ludCddKSB7XG4gICAgICAgICAgICAvLyBFZGdlIGFuZCBJRSBzcGVjaWFsIHNub3dmbGFrZXNcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnRbJ21zRWxlbWVudHNGcm9tUG9pbnQnXSh2aWV3UG9ydFgsIHZpZXdQb3J0WSk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHMgPT09IG51bGwgPyBbXSA6IGVsZW1lbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3RoZXIgYnJvd3NlcnMgbGlrZSBDaHJvbWUsIEZpcmVmb3gsIE9wZXJhXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQodmlld1BvcnRYLCB2aWV3UG9ydFkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkaXNwYXRjaEV2ZW50KHRhcmdldCwgZXZlbnROYW1lOiBzdHJpbmcsIGV2ZW50QXJnczogSWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscykge1xuICAgICAgICAvLyBUaGlzIHdheSBpcyBJRTExIGNvbXBhdGlibGUuXG4gICAgICAgIGNvbnN0IGRyYWdMZWF2ZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIGRyYWdMZWF2ZUV2ZW50LmluaXRDdXN0b21FdmVudChldmVudE5hbWUsIGZhbHNlLCBmYWxzZSwgZXZlbnRBcmdzKTtcbiAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZHJhZ0xlYXZlRXZlbnQpO1xuICAgICAgICAvLyBPdGhlcndpc2UgY2FuIGJlIHVzZWQgYHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIGV2ZW50QXJncykpO2BcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0VHJhbnNmb3JtWChlbGVtKSB7XG4gICAgICAgIGxldCBwb3NYID0gMDtcbiAgICAgICAgaWYgKGVsZW0uc3R5bGUudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSBlbGVtLnN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG1hdHJpeCA/IG1hdHJpeC5tYXRjaCgvLT9bXFxkXFwuXSsvZykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwb3NYID0gdmFsdWVzID8gTnVtYmVyKHZhbHVlc1sgMSBdKSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zWDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0VHJhbnNmb3JtWShlbGVtKSB7XG4gICAgICAgIGxldCBwb3NZID0gMDtcbiAgICAgICAgaWYgKGVsZW0uc3R5bGUudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRyaXggPSBlbGVtLnN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG1hdHJpeCA/IG1hdHJpeC5tYXRjaCgvLT9bXFxkXFwuXSsvZykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwb3NZID0gdmFsdWVzID8gTnVtYmVyKHZhbHVlc1sgMiBdKSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zWTtcbiAgICB9XG5cbiAgICAvKiogTWV0aG9kIHNldHRpbmcgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGJhc2UgZHJhZ2dhYmxlIGVsZW1lbnQuICovXG4gICAgcHJvdGVjdGVkIHNldFRyYW5zZm9ybVhZKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgeCArICdweCwgJyArIHkgKyAncHgsIDBweCknO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbmNlIHdlIGFyZSB1c2luZyBhYnNvbHV0ZSBwb3NpdGlvbiB0byBtb3ZlIHRoZSBnaG9zdCwgdGhlIGdob3N0IGhvc3QgbWlnaHQgbm90IGhhdmUgcG9zaXRpb246IHJlbGF0aXZlLlxuICAgICAqIENvbWJpbmVkIHdpdGggcG9zaXRpb24gc3RhdGljLCB0aGlzIG1lYW5zIHRoYXQgdGhlIGFic29sdXRlIHBvc2l0aW9uIGluIHRoZSBicm93c2VyIGlzIHJlbGF0aXZlIHRvIHRoZSBvZmZzZXRQYXJlbnQuXG4gICAgICogVGhlIG9mZnNldFBhcmVudCBpcyBwcmV0dHkgbXVjaCB0aGUgY2xvc2VzIHBhcmVudCB0aGF0IGhhcyBwb3NpdGlvbjogcmVsYXRpdmUsIG9yIGlmIG5vIHN1Y2ggdW50aWwgaXQgcmVhY2hlcyB0aGUgYm9keS5cbiAgICAgKiBUaGF0J3Mgd2h5IGlmIHRoaXMgaXMgdGhlIGNhc2UsIHdlIG5lZWQgdG8ga25vdyBob3cgbXVjaCB3ZSBzaG91bGQgY29tcGVuc2F0ZSBmb3IgdGhlIGdob3N0SG9zdCBiZWluZyBvZmZzZXQgZnJvbVxuICAgICAqIGl0cyBvZmZzZXRQYXJlbnQuXG4gICAgICpcbiAgICAgKiBPZmZzZXRQYXJlbnQgY2FuIGJlIG51bGwgaW4gdGhlIGNhc2Ugb2YgcG9zaXRpb246IGZpeGVkIGFwcGxpZWQgdG8gdGhlIGdob3N0IGhvc3Qgb3IgZGlzcGxheTogbm9uZS4gSW4gdGhhdCBjYXNlXG4gICAgICoganVzdCBnZXQgdGhlIGNsaWVudFJlY3RzIG9mIHRoZSBnaG9zdCBob3N0LlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRHaG9zdEhvc3RCYXNlT2Zmc2V0WCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdob3N0SG9zdCkgcmV0dXJuIDA7XG5cbiAgICAgICAgY29uc3QgZ2hvc3RQb3NpdGlvbiA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5naG9zdEhvc3QpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIGlmIChnaG9zdFBvc2l0aW9uID09PSAnc3RhdGljJyAmJiB0aGlzLmdob3N0SG9zdC5vZmZzZXRQYXJlbnQgJiYgdGhpcy5naG9zdEhvc3Qub2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIGlmIChnaG9zdFBvc2l0aW9uID09PSAnc3RhdGljJyAmJiB0aGlzLmdob3N0SG9zdC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdob3N0SG9zdC5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHRoaXMud2luZG93U2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5naG9zdEhvc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHRoaXMud2luZG93U2Nyb2xsTGVmdDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0R2hvc3RIb3N0QmFzZU9mZnNldFkoKSB7XG4gICAgICAgIGlmICghdGhpcy5naG9zdEhvc3QpIHJldHVybiAwO1xuXG4gICAgICAgIGNvbnN0IGdob3N0UG9zaXRpb24gPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZ2hvc3RIb3N0KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuICAgICAgICBpZiAoZ2hvc3RQb3NpdGlvbiA9PT0gJ3N0YXRpYycgJiYgdGhpcy5naG9zdEhvc3Qub2Zmc2V0UGFyZW50ICYmIHRoaXMuZ2hvc3RIb3N0Lm9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2hvc3RQb3NpdGlvbiA9PT0gJ3N0YXRpYycgJiYgdGhpcy5naG9zdEhvc3Qub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5naG9zdEhvc3Qub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMud2luZG93U2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdob3N0SG9zdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLndpbmRvd1Njcm9sbFRvcDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0Q29udGFpbmVyU2Nyb2xsRGlyZWN0aW9uKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXJCb3VuZHMgPSB0aGlzLnNjcm9sbENvbnRhaW5lciA/ICB0aGlzLnNjcm9sbENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHNjcm9sbGVkWCA9ICF0aGlzLnNjcm9sbENvbnRhaW5lciA/IHRoaXMud2luZG93U2Nyb2xsTGVmdCA+IDAgOiB0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ID4gMDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsZWRZID0gIXRoaXMuc2Nyb2xsQ29udGFpbmVyID8gdGhpcy53aW5kb3dTY3JvbGxUb3AgPiAwIDogdGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wID4gMDtcbiAgICAgICAgLy8gVGFrZSBpbnRvIGFjY291bnQgd2luZG93IHNjcm9sbCB0b3AgYmVjYXVzZSB3ZSBkbyBub3QgdXNlIGZpeGVkIHBvc2l0aW9uaW5nIHRvIHRoZSB3aW5kb3cuXG4gICAgICAgIGNvbnN0IHRvcEJvcmRlciA9ICghdGhpcy5zY3JvbGxDb250YWluZXIgPyAwIDogY29udGFpbmVyQm91bmRzLnRvcCkgKyB0aGlzLndpbmRvd1Njcm9sbFRvcCArIHRoaXMuX3Njcm9sbENvbnRhaW5lclRocmVzaG9sZDtcbiAgICAgICAgLy8gU3VidHJhY3QgdGhlIGVsZW1lbnQgaGVpZ2h0IGJlY2F1c2Ugd2UgcG9zaXRpb24gaXQgZnJvbSB0b3AgbGVmdCBjb3JuZXIuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRIZWlnaHQgPSB0aGlzLmdob3N0ICYmIHRoaXMuZ2hvc3RFbGVtZW50ID8gdGhpcy5naG9zdEVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBjb25zdCBib3R0b21Cb3JkZXIgPSAoIXRoaXMuc2Nyb2xsQ29udGFpbmVyID8gd2luZG93LmlubmVySGVpZ2h0IDogY29udGFpbmVyQm91bmRzLmJvdHRvbSApICtcbiAgICAgICAgICAgIHRoaXMud2luZG93U2Nyb2xsVG9wIC0gdGhpcy5fc2Nyb2xsQ29udGFpbmVyVGhyZXNob2xkICAtIGVsZW1lbnRIZWlnaHQ7XG4gICAgICAgIC8vIFNhbWUgZm9yIHdpbmRvdyBzY3JvbGwgbGVmdFxuICAgICAgICBjb25zdCBsZWZ0Qm9yZGVyID0gKCF0aGlzLnNjcm9sbENvbnRhaW5lciA/IDAgOiBjb250YWluZXJCb3VuZHMubGVmdCkgKyB0aGlzLndpbmRvd1Njcm9sbExlZnQgKyB0aGlzLl9zY3JvbGxDb250YWluZXJUaHJlc2hvbGQ7XG4gICAgICAgIC8vIFN1YnRyYWN0IHRoZSBlbGVtZW50IHdpZHRoIGFnYWluIGJlY2F1c2Ugd2UgcG9zaXRpb24gaXQgZnJvbSB0b3AgbGVmdCBjb3JuZXIuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRXaWR0aCA9IHRoaXMuZ2hvc3QgJiYgdGhpcy5naG9zdEVsZW1lbnQgPyB0aGlzLmdob3N0RWxlbWVudC5vZmZzZXRXaWR0aCA6ICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3QgcmlnaHRCb3JkZXIgPSAoIXRoaXMuc2Nyb2xsQ29udGFpbmVyID8gd2luZG93LmlubmVyV2lkdGggOiBjb250YWluZXJCb3VuZHMucmlnaHQpICtcbiAgICAgICAgICAgIHRoaXMud2luZG93U2Nyb2xsTGVmdCAtIHRoaXMuX3Njcm9sbENvbnRhaW5lclRocmVzaG9sZCAtIGVsZW1lbnRXaWR0aFxuXG4gICAgICAgIGlmICh0aGlzLnBhZ2VZIDw9IHRvcEJvcmRlciAmJiBzY3JvbGxlZFkpIHtcbiAgICAgICAgICAgIHJldHVybiBEcmFnU2Nyb2xsRGlyZWN0aW9uLlVQO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFnZVkgPiBib3R0b21Cb3JkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBEcmFnU2Nyb2xsRGlyZWN0aW9uLkRPV047XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wYWdlWCA8IGxlZnRCb3JkZXIgJiYgc2Nyb2xsZWRYKSB7XG4gICAgICAgICAgICByZXR1cm4gRHJhZ1Njcm9sbERpcmVjdGlvbi5MRUZUO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFnZVggPiByaWdodEJvcmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIERyYWdTY3JvbGxEaXJlY3Rpb24uUklHSFQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG9uU2Nyb2xsQ29udGFpbmVyU3RlcChzY3JvbGxEaXI6IERyYWdTY3JvbGxEaXJlY3Rpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIuc2NoZWR1bGUoKCkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgeERpciA9IHNjcm9sbERpciA9PSBEcmFnU2Nyb2xsRGlyZWN0aW9uLkxFRlQgPyAtMSA6IChzY3JvbGxEaXIgPT0gRHJhZ1Njcm9sbERpcmVjdGlvbi5SSUdIVCA/IDEgOiAwKTtcbiAgICAgICAgICAgIGxldCB5RGlyID0gc2Nyb2xsRGlyID09IERyYWdTY3JvbGxEaXJlY3Rpb24uVVAgPyAtMSA6IChzY3JvbGxEaXIgPT0gRHJhZ1Njcm9sbERpcmVjdGlvbi5ET1dOID8gMSA6IDApO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNjcm9sbENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIC8vIENhcCBzY3JvbGxpbmcgc28gd2UgZG9uJ3Qgc2Nyb2xsIHBhc3QgdGhlIHdpbmRvdyBtYXggc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IG1heFNjcm9sbFggPSB0aGlzLl9vcmlnaW5hbFNjcm9sbENvbnRhaW5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFNjcm9sbFkgPSB0aGlzLl9vcmlnaW5hbFNjcm9sbENvbnRhaW5lckhlaWdodCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgeERpciA9ICh0aGlzLndpbmRvd1Njcm9sbExlZnQgPD0gMCAmJiB4RGlyIDwgMCkgfHwgKHRoaXMud2luZG93U2Nyb2xsTGVmdCA+PSBtYXhTY3JvbGxYICYmIHhEaXIgPiAwKSA/IDAgOiB4RGlyO1xuICAgICAgICAgICAgICAgIHlEaXIgPSAodGhpcy53aW5kb3dTY3JvbGxUb3AgPD0gMCAmJiB5RGlyIDwgMCkgfHwgKHRoaXMud2luZG93U2Nyb2xsVG9wID49IG1heFNjcm9sbFkgJiYgeURpciA+IDApID8gMCA6IHlEaXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENhcCBzY3JvbGxpbmcgc28gd2UgZG9uJ3Qgc2Nyb2xsIHBhc3QgdGhlIGNvbnRhaW5lciBtYXggc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IG1heFNjcm9sbFggPSB0aGlzLl9vcmlnaW5hbFNjcm9sbENvbnRhaW5lcldpZHRoIC0gdGhpcy5zY3JvbGxDb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4U2Nyb2xsWSA9IHRoaXMuX29yaWdpbmFsU2Nyb2xsQ29udGFpbmVySGVpZ2h0IC0gdGhpcy5zY3JvbGxDb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHhEaXIgPSAodGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCA8PSAwICYmIHhEaXIgPCAwKSB8fCAodGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCA+PSBtYXhTY3JvbGxYICYmIHhEaXIgPiAwKSA/IDAgOiB4RGlyO1xuICAgICAgICAgICAgICAgIHlEaXIgPSAodGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wIDw9IDAgJiYgeURpciA8IDApIHx8ICh0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgPj0gbWF4U2Nyb2xsWSAmJiB5RGlyID4gMCkgPyAwIDogeURpcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQnlYID0geERpciAqIHRoaXMuX3Njcm9sbENvbnRhaW5lclN0ZXA7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxCeVkgPSB5RGlyICogdGhpcy5fc2Nyb2xsQ29udGFpbmVyU3RlcDtcblxuICAgICAgICAgICAgLy8gU2Nyb2xsIHRoZSBjb3JyZXNwb25kaW5nIHdpbmRvdyBvciBjb250YWluZXIuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbEJ5KHNjcm9sbEJ5WCwgc2Nyb2xsQnlZKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCArPSBzY3JvbGxCeVg7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wICs9IHNjcm9sbEJ5WTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2hvc3QgJiYgIXRoaXMuc2Nyb2xsQ29udGFpbmVyKSAge1xuICAgICAgICAgICAgICAgIC8vIFNjcm9sbCB0aGUgZ2hvc3Qgb25seSB3aGVuIHRoZXJlIGlzIG5vIGNvbnRhaW5lciBzcGVjaWZpZXMuXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgaGFzIGNvbnRhaW5lciB0aGUgZ2hvc3QgcHJldHR5IG11Y2ggc3RheXMgaW4gdGhlIHNhbWUgcG9zaXRpb24gd2hpbGUgdGhlIGNvbnRhaW5lciBpcyBzY3JvbGxlZCBzaW5jZSBlIHVzZSB0b3AvbGVmdCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVhc2UgdGhlIHBvc2l0aW9uIHRoZSBzYW1lIGFtb3VudCB3ZSBoYXZlIHNjcm9sbGVkIHRoZSB3aW5kb3dcbiAgICAgICAgICAgICAgICB0aGlzLmdob3N0TGVmdCArPSBzY3JvbGxCeVg7XG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdFRvcCArPSBzY3JvbGxCeVk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgYmFzZSBlbGVtZW50IHRoZSBzYW1lIGFtb3VudCB3ZSBtb3ZlZCB0aGUgd2luZG93L2NvbnRhaW5lciBiZWNhdXNlIHdlIHVzZSB0cmFuc2Zvcm1hdGlvbnMuXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlWCA9IHRoaXMuZ2V0VHJhbnNmb3JtWCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkgKyBzY3JvbGxCeVg7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlWSA9IHRoaXMuZ2V0VHJhbnNmb3JtWSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkgKyBzY3JvbGxCeVk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1YWSh0cmFuc2xhdGVYLCB0cmFuc2xhdGVZKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RYICs9IHNjcm9sbEJ5WDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFkgKz0gc2Nyb2xsQnlZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgb25TY3JvbGxDb250YWluZXIoKSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbERpciA9IHRoaXMuZ2V0Q29udGFpbmVyU2Nyb2xsRGlyZWN0aW9uKCk7XG4gICAgICAgIGlmIChzY3JvbGxEaXIgIT09IG51bGwgJiYgc2Nyb2xsRGlyICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuX2NvbnRhaW5lclNjcm9sbEludGVydmFsSWQpIHtcbiAgICAgICAgICAgIC8vIFNhdmUgb3JpZ2luYWwgY29udGFpbmVyIHNpemVzIHRvIGVuc3VyZSB0aGF0IHdlIGRvbid0IGluY3JlYXNlIHNjcm9sbCBzaXplcyBpbmZpbml0ZWx5IHdoZW4gb3V0IG9mIGJvdW5kcy5cbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsU2Nyb2xsQ29udGFpbmVyV2lkdGggPSB0aGlzLnNjcm9sbENvbnRhaW5lciA/IHRoaXMuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFdpZHRoIDogdGhpcy53aW5kb3dTY3JvbGxXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsU2Nyb2xsQ29udGFpbmVySGVpZ2h0ID0gdGhpcy5zY3JvbGxDb250YWluZXIgPyB0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxIZWlnaHQgOiB0aGlzLndpbmRvd1Njcm9sbEhlaWdodDtcblxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyU2Nyb2xsSW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IHRoaXMub25TY3JvbGxDb250YWluZXJTdGVwKHNjcm9sbERpciksIHRoaXMuX3Njcm9sbENvbnRhaW5lclN0ZXBNcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoKHNjcm9sbERpciA9PT0gbnVsbCB8fCBzY3JvbGxEaXIgPT09IHVuZGVmaW5lZCkgJiYgdGhpcy5fY29udGFpbmVyU2Nyb2xsSW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgLy8gV2UgbW92ZWQgb3V0IG9mIGVuZCBib3VuZHMgYW5kIHRoZXJlIGlzIGludGVydmFsIHN0YXJ0ZWRcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY29udGFpbmVyU2Nyb2xsSW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJTY3JvbGxJbnRlcnZhbElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgZXhwb3J0QXM6ICdkcm9wJyxcbiAgICBzZWxlY3RvcjogJ1tpZ3hEcm9wXScsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hEcm9wRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKlxuICAgICAqIC0gU2F2ZSBkYXRhIGluc2lkZSB0aGUgYGlneERyb3BgIGRpcmVjdGl2ZS4gVGhpcyBjYW4gYmUgc2V0IHdoZW4gaW5zdGFuY2luZyBgaWd4RHJvcGAgb24gYW4gZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBbaWd4RHJvcF09XCJ7IHNvdXJjZTogbXlFbGVtZW50IH1cIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hEcm9wJylcbiAgICBwdWJsaWMgc2V0IGRhdGEodjogYW55KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSB2O1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZGF0YSgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBwcm92aWRlIGEgd2F5IGZvciBpZ3hEcmFnIGFuZCBpZ3hEcm9wIHRvIGJlIGxpbmtlZCB0aHJvdWdoIGNoYW5uZWxzLlxuICAgICAqIEl0IGFjY2VwdHMgc2luZ2xlIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcyBhbmQgZXZhbHVhdGVzIHRoZW4gdXNpbmcgc3RyaWN0IGVxdWFsaXR5LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdDaGFubmVsXT1cIidvZGQnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj45NTwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyb3AgW2Ryb3BDaGFubmVsXT1cIlsnb2RkJywgJ2lycmF0aW9uYWwnXVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+TnVtYmVycyBkcm9wIGFyZWEhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkcm9wQ2hhbm5lbDogbnVtYmVyIHwgc3RyaW5nIHwgbnVtYmVyW10gfCBzdHJpbmdbXTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyBhIGRyb3Agc3RyYXRlZ3kgdHlwZSB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBhbiBgSWd4RHJhZ2AgZWxlbWVudCBpcyByZWxlYXNlZCBpbnNpZGVcbiAgICAgKiAgdGhlIGN1cnJlbnQgZHJvcCBhcmVhLiBUaGUgcHJvdmlkZWQgc3RyYXRlZ2llcyBhcmU6XG4gICAgICogIC0gSWd4RGVmYXVsdERyb3BTdHJhdGVneSAtIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmFzZSBzdHJhdGVneSBhbmQgaXQgZG9lc24ndCBwZXJmb3JtIGFueSBhY3Rpb25zLlxuICAgICAqICAtIElneEFwcGVuZERyb3BTdHJhdGVneSAtIEFwcGVuZHMgdGhlIGRyb3BwZWQgZWxlbWVudCB0byBsYXN0IHBvc2l0aW9uIGFzIGEgZGlyZWN0IGNoaWxkIHRvIHRoZSBgaWd4RHJvcGAuXG4gICAgICogIC0gSWd4UHJlcGVuZERyb3BTdHJhdGVneSAtIFByZXBlbmRzIHRoZSBkcm9wcGVkIGVsZW1lbnQgdG8gZmlyc3QgcG9zaXRpb24gYXMgYSBkaXJlY3QgY2hpbGQgdG8gdGhlIGBpZ3hEcm9wYC5cbiAgICAgKiAgLSBJZ3hJbnNlcnREcm9wU3RyYXRlZ3kgLSBJZiB0aGUgZHJvcHBlZCBlbGVtZW50IGlzIHJlbGVhc2VkIGFib3ZlIGEgY2hpbGQgZWxlbWVudCBvZiB0aGUgYGlneERyb3BgLCBpdCB3aWxsIGJlIGluc2VydGVkXG4gICAgICogICAgICBhdCB0aGF0IHBvc2l0aW9uLiBPdGhlcndpc2UgdGhlIGRyb3BwZWQgZWxlbWVudCB3aWxsIGJlIGFwcGVuZGVkIGlmIHJlbGVhc2VkIG91dHNpZGUgYW55IGNoaWxkIG9mIHRoZSBgaWd4RHJvcGAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZz5cbiAgICAgKiAgICAgIDxzcGFuPkRyYWdNZTwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyb3AgW2Ryb3BTdHJhdGVneV09XCJteURyb3BTdHJhdGVneVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+TnVtYmVycyBkcm9wIGFyZWEhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQgeyBJZ3hBcHBlbmREcm9wU3RyYXRlZ3kgfSBmcm9tICdpZ25pdGV1aS1hbmd1bGFyJztcbiAgICAgKlxuICAgICAqIGV4cG9ydCBjbGFzcyBBcHAge1xuICAgICAqICAgICAgcHVibGljIG15RHJvcFN0cmF0ZWd5ID0gSWd4QXBwZW5kRHJvcFN0cmF0ZWd5O1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IGRyb3BTdHJhdGVneShjbGFzc1JlZjogYW55KSB7XG4gICAgICAgIHRoaXMuX2Ryb3BTdHJhdGVneSA9IG5ldyBjbGFzc1JlZih0aGlzLl9yZW5kZXJlcik7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBkcm9wU3RyYXRlZ3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU3RyYXRlZ3k7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGVudGVycyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZW50ZXIpPVwiZHJhZ0VudGVyKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0VudGVyKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBlbnRlciA9IG5ldyBFdmVudEVtaXR0ZXI8SURyb3BCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGVudGVycyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZW50ZXIpPVwiZHJhZ0VudGVyKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0VudGVyKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvdmVyID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJvcEJhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiBkcmFnZ2VkIGVsZW1lbnQgbGVhdmVzIHRoZSBhcmVhIG9mIHRoZSBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGNsYXNzPVwiY2FnZUFyZWFcIiBpZ3hEcm9wIChsZWF2ZSk9XCJkcmFnTGVhdmUoKVwiIChpZ3hEcmFnRW50ZXIpPVwib25EcmFnQ2FnZUVudGVyKClcIiAoaWd4RHJhZ0xlYXZlKT1cIm9uRHJhZ0NhZ2VMZWF2ZSgpXCI+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBkcmFnTGVhdmUoKXtcbiAgICAgKiAgICAgYWxlcnQoXCJBIGRyYWdnYWJsZSBlbGVtZW50IGhhcyBsZWZ0IHRoZSBjaGlwIGFyZWEhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGxlYXZlID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJvcEJhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiBkcmFnZ2VkIGVsZW1lbnQgaXMgZHJvcHBlZCBpbiB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBTaW5jZSB0aGUgYGlneERyb3BgIGhhcyBkZWZhdWx0IGxvZ2ljIHRoYXQgYXBwZW5kcyB0aGUgZHJvcHBlZCBlbGVtZW50IGFzIGEgY2hpbGQsIGl0IGNhbiBiZSBjYW5jZWxlZCBoZXJlLlxuICAgICAqIFRvIGNhbmNlbCB0aGUgZGVmYXVsdCBsb2dpYyB0aGUgYGNhbmNlbGAgcHJvcGVydHkgb2YgdGhlIGV2ZW50IG5lZWRzIHRvIGJlIHNldCB0byB0cnVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGNsYXNzPVwiY2FnZUFyZWFcIiBpZ3hEcm9wIChkcm9wcGVkKT1cImRyYWdEcm9wKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0Ryb3AoKXtcbiAgICAgKiAgICAgYWxlcnQoXCJBIGRyYWdnYWJsZSBlbGVtZW50IGhhcyBiZWVuIGRyb3BwZWQgaW4gdGhlIGNoaXAgYXJlYSFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZHJvcHBlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SURyb3BEcm9wcGVkRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5kcm9wcGFibGUnKVxuICAgIHB1YmxpYyBkcm9wcGFibGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuZHJhZ092ZXInKVxuICAgIHB1YmxpYyBkcmFnb3ZlciA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZGVzdHJveSA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gICAgcHJvdGVjdGVkIF9kcm9wU3RyYXRlZ3k6IElEcm9wU3RyYXRlZ3k7XG5cbiAgICBwcml2YXRlIF9kYXRhOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBfem9uZTogTmdab25lKSB7XG4gICAgICAgIHRoaXMuX2Ryb3BTdHJhdGVneSA9IG5ldyBJZ3hEZWZhdWx0RHJvcFN0cmF0ZWd5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2lneERyb3AnLCBbJyRldmVudCddKVxuICAgIHB1YmxpYyBvbkRyYWdEcm9wKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0RyYWdMaW5rZWQoZXZlbnQuZGV0YWlsLm93bmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWxlbWVudFBvc1ggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxMZWZ0KCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NZID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IGV2ZW50LmRldGFpbC5wYWdlWCAtIGVsZW1lbnRQb3NYO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gZXZlbnQuZGV0YWlsLnBhZ2VZIC0gZWxlbWVudFBvc1k7XG4gICAgICAgIGNvbnN0IGFyZ3M6IElEcm9wRHJvcHBlZEV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQuZGV0YWlsLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWSxcbiAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZLFxuICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyb3BwZWQuZW1pdChhcmdzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTdHJhdGVneSAmJiAhYXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzQXRQb2ludCA9IGV2ZW50LmRldGFpbC5vd25lci5nZXRFbGVtZW50c0F0UG9pbnQoZXZlbnQuZGV0YWlsLnBhZ2VYLCBldmVudC5kZXRhaWwucGFnZVkpO1xuICAgICAgICAgICAgY29uc3QgaW5zZXJ0SW5kZXggPSB0aGlzLmdldEluc2VydEluZGV4QXQoZXZlbnQuZGV0YWlsLm93bmVyLCBlbGVtZW50c0F0UG9pbnQpO1xuICAgICAgICAgICAgdGhpcy5fZHJvcFN0cmF0ZWd5LmRyb3BBY3Rpb24oZXZlbnQuZGV0YWlsLm93bmVyLCB0aGlzLCBpbnNlcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2lneERyYWdFbnRlcicpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vbkRyYWdFbnRlcihyZXMgYXMgQ3VzdG9tRXZlbnQ8SWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscz4pKTtcblxuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnaWd4RHJhZ0xlYXZlJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uRHJhZ0xlYXZlKHJlcykpO1xuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnaWd4RHJhZ092ZXInKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25EcmFnT3ZlcihyZXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveS5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLl9kZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdPdmVyKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NYID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICBjb25zdCBlbGVtZW50UG9zWSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5kZXRhaWwucGFnZVggLSBlbGVtZW50UG9zWDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50LmRldGFpbC5wYWdlWSAtIGVsZW1lbnRQb3NZO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElEcm9wQmFzZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LmRldGFpbC5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWSxcbiAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vdmVyLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdFbnRlcihldmVudDogQ3VzdG9tRXZlbnQ8SWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscz4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ0xpbmtlZChldmVudC5kZXRhaWwub3duZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdvdmVyID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZWxlbWVudFBvc1ggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxMZWZ0KCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NZID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IGV2ZW50LmRldGFpbC5wYWdlWCAtIGVsZW1lbnRQb3NYO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gZXZlbnQuZGV0YWlsLnBhZ2VZIC0gZWxlbWVudFBvc1k7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSURyb3BCYXNlRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQuZGV0YWlsLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIGRyYWc6IGV2ZW50LmRldGFpbC5vd25lcixcbiAgICAgICAgICAgIGRyYWdEYXRhOiBldmVudC5kZXRhaWwub3duZXIuZGF0YSxcbiAgICAgICAgICAgIHN0YXJ0WDogZXZlbnQuZGV0YWlsLnN0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogZXZlbnQuZGV0YWlsLnN0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5kZXRhaWwucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXZlbnQuZGV0YWlsLnBhZ2VZLFxuICAgICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbnRlci5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25EcmFnTGVhdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ0xpbmtlZChldmVudC5kZXRhaWwub3duZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdvdmVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NYID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICBjb25zdCBlbGVtZW50UG9zWSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5kZXRhaWwucGFnZVggLSBlbGVtZW50UG9zWDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50LmRldGFpbC5wYWdlWSAtIGVsZW1lbnRQb3NZO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElEcm9wQmFzZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LmRldGFpbC5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWSxcbiAgICAgICAgICAgIG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGVhdmUuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0V2luZG93U2Nyb2xsVG9wKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFkgPyB3aW5kb3cuc2Nyb2xsWSA6ICh3aW5kb3cucGFnZVlPZmZzZXQgPyB3aW5kb3cucGFnZVlPZmZzZXQgOiAwKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0V2luZG93U2Nyb2xsTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxYID8gd2luZG93LnNjcm9sbFggOiAod2luZG93LnBhZ2VYT2Zmc2V0ID8gd2luZG93LnBhZ2VYT2Zmc2V0IDogMCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGlzRHJhZ0xpbmtlZChkcmFnOiBJZ3hEcmFnRGlyZWN0aXZlKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGRyYWdMaW5rQXJyYXkgPSBkcmFnLmRyYWdDaGFubmVsIGluc3RhbmNlb2YgQXJyYXk7XG4gICAgICAgIGNvbnN0IGRyb3BMaW5rQXJyYXkgPSB0aGlzLmRyb3BDaGFubmVsIGluc3RhbmNlb2YgQXJyYXk7XG5cbiAgICAgICAgaWYgKCFkcmFnTGlua0FycmF5ICYmICFkcm9wTGlua0FycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQ2hhbm5lbCA9PT0gZHJhZy5kcmFnQ2hhbm5lbDtcbiAgICAgICAgfSBlbHNlIGlmICghZHJhZ0xpbmtBcnJheSAmJiBkcm9wTGlua0FycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBkcm9wTGlua3MgPSB0aGlzLmRyb3BDaGFubmVsIGFzIGFueSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluayBvZiBkcm9wTGlua3MpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluayA9PT0gZHJhZy5kcmFnQ2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZHJhZ0xpbmtBcnJheSAmJiAhZHJvcExpbmtBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgZHJhZ0xpbmtzID0gZHJhZy5kcmFnQ2hhbm5lbCBhcyBhbnkgW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmsgb2YgZHJhZ0xpbmtzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsgPT09IHRoaXMuZHJvcENoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZHJhZ0xpbmtzID0gZHJhZy5kcmFnQ2hhbm5lbCBhcyBhbnkgW107XG4gICAgICAgICAgICBjb25zdCBkcm9wTGlua3MgPSB0aGlzLmRyb3BDaGFubmVsIGFzIGFueSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZHJhZ2xpbmsgb2YgZHJhZ0xpbmtzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkcm9wbGluayBvZiBkcm9wTGlua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdsaW5rID09PSBkcm9wbGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldEluc2VydEluZGV4QXQoZHJhZ2dlZERpcjogSWd4RHJhZ0RpcmVjdGl2ZSwgZWxlbWVudHNBdFBvaW50OiBhbnlbXSk6IG51bWJlciB7XG4gICAgICAgIGxldCBpbnNlcnRJbmRleCA9IC0xO1xuICAgICAgICBjb25zdCBkcm9wQ2hpbGRyZW4gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIGlmICghZHJvcENoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgY2hpbGRVbmRlciA9IG51bGw7XG4gICAgICAgIHdoaWxlICghY2hpbGRVbmRlciAmJiBpIDwgZWxlbWVudHNBdFBvaW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzQXRQb2ludFtpXS5wYXJlbnRFbGVtZW50ID09PSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkVW5kZXIgPSBlbGVtZW50c0F0UG9pbnRbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkcmFnZ2VkRWxlbUluZGV4ID0gZHJvcENoaWxkcmVuLmluZGV4T2YoZHJhZ2dlZERpci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBpbnNlcnRJbmRleCA9IGRyb3BDaGlsZHJlbi5pbmRleE9mKGNoaWxkVW5kZXIpO1xuICAgICAgICBpZiAoZHJhZ2dlZEVsZW1JbmRleCAhPT0gLTEgJiYgZHJhZ2dlZEVsZW1JbmRleCA8IGluc2VydEluZGV4KSB7XG4gICAgICAgICAgICBpbnNlcnRJbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluc2VydEluZGV4O1xuICAgIH1cbn1cblxuIl19